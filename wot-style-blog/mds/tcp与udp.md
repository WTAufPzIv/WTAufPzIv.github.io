---
date: 2020-03-08
categories: [技术,计算机通识,计算机网络]
thumbnail: /images/fe/tcpudp.jpg
toc: true
---
# TCP与UDP的区别
- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证

<!--more-->
# UDP——面向报文
> UDP是一个面向报文的协议，从这个字面意思来理解的话就是，udp协议只是充当了一个报文的搬运工，不会对报文本身进行修改，例如拆分和拼接等操作

## UDP的不可靠性
- UDP是面向无连接的，也就是说在传输数据时，不需要和接收方确认建立和断开连接
- UDP只负责搬运报文，不负责接收方有没有收到
- UDP没有拥塞控制，收到多少报文就发送多少报文，不管接收端有没有能力接受

## UDP的优点
- 高效：不需要复杂的首部字段，仅仅加一个UDP标识字段。
- 实时性好

## UDP的缺点
网络不好的情况下可能发生丢包

## UDP的应用场景
- 网络直播
- 网络实时游戏
- 视频通话，网络电话

# TCP——面向字节流
## 报文格式
![](/images/assets/20200308105555196.png)
- Sequence number（seq）**序号**，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号
- Acknowledgement Number（ack）**确认号**，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
- Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制

确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。**TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一**

同步SYN：**当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文**。因此，SYN=1表示这是一个连接请求，或连接接受报文**。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。**

终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

   PS：**ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号**

![](/images/assets/20200308110013334.png)

# tcp的三次握手
![](/images/assets/20200308110038707.png)
第一次握手

> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态
>x 表示客户端的数据通信初始序号。

第二次握手

> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN-RECEIVED 状态。

第三次握手

> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入 ESTABLISHED状态，此时连接建立成功

# TCP四次挥手
![](/images/assets/20200308112405934.png)
第一次挥手

> 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

第二次挥手

>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。


第三次挥手

> 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。


第四次挥手

> 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭

# 常见问题
1. *为什么连接的时候是三次握手，关闭的时候却是四次握手*？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

2. *为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态*？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
否则Client推断ACK已经被成功接收，则结束TCP连接。

3. *如果已经建立了连接，但是客户端突然出现故障了怎么办*
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

4. 为什么是三次握手而不是两次
防止失效的连接请求报文段被服务端接收，从而产生错误

> 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费